import {
  __commonJS
} from "./chunk-BUSYA2B4.js";

// node_modules/.pnpm/ws@8.18.3_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ws/browser.js
var require_browser = __commonJS({
  "node_modules/.pnpm/ws@8.18.3_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/ws/browser.js"(exports, module) {
    "use strict";
    module.exports = function() {
      throw new Error(
        "ws does not work in the browser. Browser clients must use the native WebSocket object"
      );
    };
  }
});

// node_modules/.pnpm/xrpl-connect@0.3.0/node_modules/xrpl-connect/xrpl-connect.mjs
var Aw = Object.defineProperty;
var Gl = (r) => {
  throw TypeError(r);
};
var Ow = (r, e, t) => e in r ? Aw(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;
var S = (r, e, t) => Ow(r, typeof e != "symbol" ? e + "" : e, t);
var Sw = (r, e, t) => e.has(r) || Gl("Cannot " + t);
var Vi = (r, e, t) => (Sw(r, e, "read from private field"), t ? t.call(r) : e.get(r));
var Hs = (r, e, t) => e.has(r) ? Gl("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(r) : e.set(r, t);
var B = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Cs(r) {
  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
}
function dp(r) {
  if (r.__esModule) return r;
  var e = r.default;
  if (typeof e == "function") {
    var t = function n() {
      return this instanceof n ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    t.prototype = e.prototype;
  } else t = {};
  return Object.defineProperty(t, "__esModule", { value: true }), Object.keys(r).forEach(function(n) {
    var s = Object.getOwnPropertyDescriptor(r, n);
    Object.defineProperty(t, n, s.get ? s : {
      enumerable: true,
      get: function() {
        return r[n];
      }
    });
  }), t;
}
var hp = { exports: {} };
(function(r) {
  var e = Object.prototype.hasOwnProperty, t = "~";
  function n() {
  }
  Object.create && (n.prototype = /* @__PURE__ */ Object.create(null), new n().__proto__ || (t = false));
  function s(u, c, l) {
    this.fn = u, this.context = c, this.once = l || false;
  }
  function i(u, c, l, d, h) {
    if (typeof l != "function")
      throw new TypeError("The listener must be a function");
    var f = new s(l, d || u, h), g = t ? t + c : c;
    return u._events[g] ? u._events[g].fn ? u._events[g] = [u._events[g], f] : u._events[g].push(f) : (u._events[g] = f, u._eventsCount++), u;
  }
  function o(u, c) {
    --u._eventsCount === 0 ? u._events = new n() : delete u._events[c];
  }
  function a() {
    this._events = new n(), this._eventsCount = 0;
  }
  a.prototype.eventNames = function() {
    var c = [], l, d;
    if (this._eventsCount === 0) return c;
    for (d in l = this._events)
      e.call(l, d) && c.push(t ? d.slice(1) : d);
    return Object.getOwnPropertySymbols ? c.concat(Object.getOwnPropertySymbols(l)) : c;
  }, a.prototype.listeners = function(c) {
    var l = t ? t + c : c, d = this._events[l];
    if (!d) return [];
    if (d.fn) return [d.fn];
    for (var h = 0, f = d.length, g = new Array(f); h < f; h++)
      g[h] = d[h].fn;
    return g;
  }, a.prototype.listenerCount = function(c) {
    var l = t ? t + c : c, d = this._events[l];
    return d ? d.fn ? 1 : d.length : 0;
  }, a.prototype.emit = function(c, l, d, h, f, g) {
    var p = t ? t + c : c;
    if (!this._events[p]) return false;
    var b = this._events[p], _ = arguments.length, D, v;
    if (b.fn) {
      switch (b.once && this.removeListener(c, b.fn, void 0, true), _) {
        case 1:
          return b.fn.call(b.context), true;
        case 2:
          return b.fn.call(b.context, l), true;
        case 3:
          return b.fn.call(b.context, l, d), true;
        case 4:
          return b.fn.call(b.context, l, d, h), true;
        case 5:
          return b.fn.call(b.context, l, d, h, f), true;
        case 6:
          return b.fn.call(b.context, l, d, h, f, g), true;
      }
      for (v = 1, D = new Array(_ - 1); v < _; v++)
        D[v - 1] = arguments[v];
      b.fn.apply(b.context, D);
    } else {
      var E = b.length, A;
      for (v = 0; v < E; v++)
        switch (b[v].once && this.removeListener(c, b[v].fn, void 0, true), _) {
          case 1:
            b[v].fn.call(b[v].context);
            break;
          case 2:
            b[v].fn.call(b[v].context, l);
            break;
          case 3:
            b[v].fn.call(b[v].context, l, d);
            break;
          case 4:
            b[v].fn.call(b[v].context, l, d, h);
            break;
          default:
            if (!D) for (A = 1, D = new Array(_ - 1); A < _; A++)
              D[A - 1] = arguments[A];
            b[v].fn.apply(b[v].context, D);
        }
    }
    return true;
  }, a.prototype.on = function(c, l, d) {
    return i(this, c, l, d, false);
  }, a.prototype.once = function(c, l, d) {
    return i(this, c, l, d, true);
  }, a.prototype.removeListener = function(c, l, d, h) {
    var f = t ? t + c : c;
    if (!this._events[f]) return this;
    if (!l)
      return o(this, f), this;
    var g = this._events[f];
    if (g.fn)
      g.fn === l && (!h || g.once) && (!d || g.context === d) && o(this, f);
    else {
      for (var p = 0, b = [], _ = g.length; p < _; p++)
        (g[p].fn !== l || h && !g[p].once || d && g[p].context !== d) && b.push(g[p]);
      b.length ? this._events[f] = b.length === 1 ? b[0] : b : o(this, f);
    }
    return this;
  }, a.prototype.removeAllListeners = function(c) {
    var l;
    return c ? (l = t ? t + c : c, this._events[l] && o(this, l)) : (this._events = new n(), this._eventsCount = 0), this;
  }, a.prototype.off = a.prototype.removeListener, a.prototype.addListener = a.prototype.on, a.prefixed = t, a.EventEmitter = a, r.exports = a;
})(hp);
var jw = hp.exports;
var Cw = Cs(jw);
var Ci = {
  mainnet: {
    id: "mainnet",
    name: "Mainnet",
    wss: "wss://xrplcluster.com",
    rpc: "https://xrplcluster.com",
    walletConnectId: "xrpl:0"
  },
  testnet: {
    id: "testnet",
    name: "Testnet",
    wss: "wss://s.altnet.rippletest.net:51233/",
    rpc: "https://testnet.xrpl-labs.com",
    walletConnectId: "xrpl:1"
  },
  devnet: {
    id: "devnet",
    name: "Devnet",
    wss: "wss://s.devnet.rippletest.net:51233/",
    rpc: "https://s.devnet.rippletest.net:51234/",
    walletConnectId: "xrpl:2"
  }
};
var Bt = ((r) => (r.WALLET_NOT_FOUND = "WALLET_NOT_FOUND", r.WALLET_NOT_INSTALLED = "WALLET_NOT_INSTALLED", r.WALLET_NOT_AVAILABLE = "WALLET_NOT_AVAILABLE", r.CONNECTION_FAILED = "CONNECTION_FAILED", r.CONNECTION_REJECTED = "CONNECTION_REJECTED", r.SIGN_FAILED = "SIGN_FAILED", r.SIGN_REJECTED = "SIGN_REJECTED", r.NETWORK_NOT_SUPPORTED = "NETWORK_NOT_SUPPORTED", r.NETWORK_MISMATCH = "NETWORK_MISMATCH", r.NOT_CONNECTED = "NOT_CONNECTED", r.ALREADY_CONNECTED = "ALREADY_CONNECTED", r.UNSUPPORTED_METHOD = "UNSUPPORTED_METHOD", r.UNKNOWN_ERROR = "UNKNOWN_ERROR", r))(Bt || {});
var St = class _St extends Error {
  constructor(e, t, n) {
    super(t), this.name = "WalletError", this.code = e, this.originalError = n, Error.captureStackTrace && Error.captureStackTrace(this, _St);
  }
  /**
   * Convert to JSON representation
   */
  toJSON() {
    return {
      name: this.name,
      code: this.code,
      message: this.message,
      stack: this.stack,
      originalError: this.originalError ? {
        name: this.originalError.name,
        message: this.originalError.message,
        stack: this.originalError.stack
      } : void 0
    };
  }
};
var me = {
  notFound: (r) => new St(
    Bt.WALLET_NOT_FOUND,
    `Wallet with id "${r}" was not found. Make sure the adapter is registered.`
  ),
  notInstalled: (r) => new St(
    Bt.WALLET_NOT_INSTALLED,
    `${r} is not installed. Please install the wallet extension or app.`
  ),
  notAvailable: (r) => new St(
    Bt.WALLET_NOT_AVAILABLE,
    `${r} is not currently available.`
  ),
  connectionFailed: (r, e) => new St(
    Bt.CONNECTION_FAILED,
    `Failed to connect to ${r}. ${(e == null ? void 0 : e.message) || ""}`,
    e
  ),
  connectionRejected: (r) => new St(
    Bt.CONNECTION_REJECTED,
    `Connection to ${r} was rejected by the user.`
  ),
  signFailed: (r) => new St(
    Bt.SIGN_FAILED,
    `Failed to sign transaction. ${(r == null ? void 0 : r.message) || ""}`,
    r
  ),
  signRejected: () => new St(Bt.SIGN_REJECTED, "Transaction signing was rejected by the user."),
  networkNotSupported: (r, e) => new St(
    Bt.NETWORK_NOT_SUPPORTED,
    `Network "${r}" is not supported by ${e}.`
  ),
  networkMismatch: (r, e) => new St(
    Bt.NETWORK_MISMATCH,
    `Network mismatch. Expected "${r}" but wallet is connected to "${e}".`
  ),
  notConnected: () => new St(
    Bt.NOT_CONNECTED,
    "No wallet is currently connected. Please connect a wallet first."
  ),
  alreadyConnected: (r) => new St(
    Bt.ALREADY_CONNECTED,
    `${r} is already connected. Disconnect first before connecting to another wallet.`
  ),
  unsupportedMethod: (r) => new St(Bt.UNSUPPORTED_METHOD, r),
  unknown: (r, e) => new St(Bt.UNKNOWN_ERROR, r, e)
};
function wz(r) {
  return r instanceof St;
}
function mz(r) {
  return r instanceof Error ? r.message : String(r);
}
var Wl = {
  debug: 0,
  info: 1,
  warn: 2,
  error: 3,
  none: 4
};
function Lw() {
  var r;
  return typeof process < "u" && ((r = process.env) != null && r.NODE_ENV) ? true : typeof window < "u" ? window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1" || window.location.hostname.includes("dev") : false;
}
var fp = class {
  constructor(e = {}) {
    this.level = e.level || (Lw() ? "debug" : "warn"), this.prefix = e.prefix || "[xrpl-connect]";
  }
  /**
   * Check if a log level should be output
   */
  shouldLog(e) {
    return Wl[e] >= Wl[this.level];
  }
  /**
   * Format log message with prefix
   */
  formatMessage(e, t) {
    const n = (/* @__PURE__ */ new Date()).toISOString();
    return `${this.prefix} [${e.toUpperCase()}] ${n} - ${t}`;
  }
  /**
   * Log debug message
   */
  debug(e, ...t) {
    this.shouldLog("debug") && console.debug(this.formatMessage("debug", e), ...t);
  }
  /**
   * Log info message
   */
  info(e, ...t) {
    this.shouldLog("info") && console.info(this.formatMessage("info", e), ...t);
  }
  /**
   * Log warning message
   */
  warn(e, ...t) {
    this.shouldLog("warn") && console.warn(this.formatMessage("warn", e), ...t);
  }
  /**
   * Log error message
   */
  error(e, ...t) {
    this.shouldLog("error") && console.error(this.formatMessage("error", e), ...t);
  }
  /**
   * Update log level
   */
  setLevel(e) {
    this.level = e;
  }
  /**
   * Get current log level
   */
  getLevel() {
    return this.level;
  }
};
function ra(r, e) {
  return new fp({ prefix: r, level: e });
}
var xn = ra("[Storage]");
var zw = class {
  constructor() {
    this.prefix = "xrpl-connect:";
  }
  async get(e) {
    try {
      return typeof window > "u" || !window.localStorage ? null : window.localStorage.getItem(this.prefix + e);
    } catch (t) {
      return xn.warn("Failed to read from localStorage:", t), null;
    }
  }
  async set(e, t) {
    try {
      if (typeof window > "u" || !window.localStorage)
        return;
      window.localStorage.setItem(this.prefix + e, t);
    } catch (n) {
      xn.warn("Failed to write to localStorage:", n);
    }
  }
  async remove(e) {
    try {
      if (typeof window > "u" || !window.localStorage)
        return;
      window.localStorage.removeItem(this.prefix + e);
    } catch (t) {
      xn.warn("Failed to remove from localStorage:", t);
    }
  }
  async clear() {
    try {
      if (typeof window > "u" || !window.localStorage)
        return;
      const e = [];
      for (let t = 0; t < window.localStorage.length; t++) {
        const n = window.localStorage.key(t);
        n != null && n.startsWith(this.prefix) && e.push(n);
      }
      e.forEach((t) => window.localStorage.removeItem(t));
    } catch (e) {
      xn.warn("Failed to clear localStorage:", e);
    }
  }
};
var kw = class {
  constructor() {
    this.storage = /* @__PURE__ */ new Map();
  }
  async get(e) {
    return this.storage.get(e) || null;
  }
  async set(e, t) {
    this.storage.set(e, t);
  }
  async remove(e) {
    this.storage.delete(e);
  }
  async clear() {
    this.storage.clear();
  }
};
var Xr;
var Uw = (Xr = class {
  constructor(e) {
    this.adapter = e || (typeof window < "u" && window.localStorage ? new zw() : new kw());
  }
  /**
   * Save wallet connection state
   */
  async saveState(e) {
    try {
      const t = JSON.stringify(e);
      await this.adapter.set(Xr.STATE_KEY, t);
    } catch (t) {
      xn.warn("Failed to save state:", t);
    }
  }
  /**
   * Load wallet connection state
   */
  async loadState() {
    try {
      const e = await this.adapter.get(Xr.STATE_KEY);
      return e ? JSON.parse(e) : null;
    } catch (e) {
      return xn.warn("Failed to load state:", e), null;
    }
  }
  /**
   * Clear wallet connection state
   */
  async clearState() {
    try {
      await this.adapter.remove(Xr.STATE_KEY);
    } catch (e) {
      xn.warn("Failed to clear state:", e);
    }
  }
  /**
   * Clear all storage
   */
  async clear() {
    try {
      await this.adapter.clear();
    } catch (e) {
      xn.warn("Failed to clear storage:", e);
    }
  }
}, Xr.STATE_KEY = "wallet-state", Xr);
var Pw = {
  /** Maximum age for stored wallet state before it's considered stale (7 days) */
  STATE_MAX_AGE: 7 * 24 * 60 * 60 * 1e3
};
var bz = class extends Cw {
  constructor(e) {
    super(), this.adapters = /* @__PURE__ */ new Map(), this.currentAdapter = null, this.currentAccount = null, this.options = e, this.logger = new fp(e.logger), this.storage = new Uw(e.storage), e.adapters.forEach((t) => {
      this.adapters.set(t.id, t), this.logger.debug(`Registered adapter: ${t.name} (${t.id})`);
    }), e.autoConnect && this.autoConnect();
  }
  /**
   * Attempt to auto-connect from stored state
   */
  async autoConnect() {
    try {
      const e = await this.storage.loadState();
      e && this.isStateValid(e) && (this.logger.debug("Attempting auto-reconnect", e), await this.reconnect());
    } catch (e) {
      this.logger.warn("Auto-connect failed:", e);
    }
  }
  /**
   * Check if stored state is still valid (not too old)
   */
  isStateValid(e) {
    return Date.now() - e.timestamp < Pw.STATE_MAX_AGE;
  }
  /**
   * Connect to a wallet
   */
  async connect(e, t) {
    this.logger.info(`Connecting to wallet: ${e}`);
    const n = this.adapters.get(e);
    if (!n)
      throw me.notFound(e);
    if (this.currentAdapter && this.currentAdapter.id !== e)
      throw me.alreadyConnected(this.currentAdapter.name);
    try {
      if (!await n.isAvailable())
        throw me.notAvailable(n.name);
      const i = {
        ...t,
        network: (t == null ? void 0 : t.network) || this.options.network
      }, o = await n.connect(i);
      this.currentAdapter = n, this.currentAccount = o;
      const a = {
        walletId: n.id,
        account: o,
        network: o.network,
        timestamp: Date.now()
      };
      return await this.storage.saveState(a), n.on && (n.on("disconnect", () => this.handleAdapterDisconnect()), n.on("accountChanged", (u) => this.handleAccountChanged(u)), n.on("networkChanged", (u) => this.handleNetworkChanged(u))), this.logger.info(`Connected to ${n.name}`, o), this.emit("connect", o), o;
    } catch (s) {
      throw this.logger.error(`Failed to connect to ${n.name}:`, s), me.connectionFailed(n.name, s);
    }
  }
  /**
   * Disconnect from current wallet
   */
  async disconnect() {
    if (!this.currentAdapter) {
      this.logger.warn("No wallet connected");
      return;
    }
    const e = this.currentAdapter.name;
    this.logger.info(`Disconnecting from ${e}`);
    try {
      await this.currentAdapter.disconnect(), await this.cleanup(), this.logger.info(`Disconnected from ${e}`), this.emit("disconnect");
    } catch (t) {
      throw this.logger.error(`Failed to disconnect from ${e}:`, t), t;
    }
  }
  /**
   * Reconnect to previously connected wallet
   */
  async reconnect() {
    const e = await this.storage.loadState();
    if (!e)
      return this.logger.debug("No stored state found for reconnection"), null;
    try {
      return await this.connect(e.walletId);
    } catch (t) {
      return this.logger.warn("Reconnection failed:", t), await this.storage.clearState(), null;
    }
  }
  /**
   * Sign and optionally submit a transaction to the ledger
   * This unified method works consistently across all wallets
   * @param transaction - The transaction to sign
   * @param submit - Whether to submit the transaction to the ledger (default: true)
   * @returns SubmittedTransaction with hash and optional submission details
   */
  async signAndSubmit(e, t = true) {
    if (!this.currentAdapter)
      throw me.notConnected();
    this.logger.debug(`${t ? "Signing and submitting" : "Signing"} transaction`, e);
    try {
      const n = await this.currentAdapter.signAndSubmit(e, t);
      return this.logger.info(
        `Transaction ${t ? "submitted" : "signed"}`,
        n.hash || n.id
      ), n;
    } catch (n) {
      throw this.logger.error(`Failed to ${t ? "submit" : "sign"} transaction:`, n), me.signFailed(n);
    }
  }
  /**
   * Sign a message
   */
  async signMessage(e) {
    if (!this.currentAdapter)
      throw me.notConnected();
    this.logger.debug("Signing message");
    try {
      const t = await this.currentAdapter.signMessage(e);
      return this.logger.info("Message signed"), t;
    } catch (t) {
      throw this.logger.error("Failed to sign message:", t), me.signFailed(t);
    }
  }
  /**
   * Get list of available wallets (installed/accessible)
   */
  async getAvailableWallets() {
    const e = [];
    for (const t of this.adapters.values())
      try {
        await t.isAvailable() && e.push(t);
      } catch (n) {
        this.logger.warn(`Failed to check availability for ${t.name}:`, n);
      }
    return e;
  }
  /**
   * Get current connection state
   */
  get connected() {
    return this.currentAdapter !== null && this.currentAccount !== null;
  }
  /**
   * Get current account
   */
  get account() {
    return this.currentAccount;
  }
  /**
   * Get current wallet adapter
   */
  get wallet() {
    return this.currentAdapter;
  }
  /**
   * Get all registered adapters
   */
  get wallets() {
    return Array.from(this.adapters.values());
  }
  /**
   * Handle adapter disconnect event
   */
  async handleAdapterDisconnect() {
    this.logger.info("Wallet disconnected (adapter event)"), await this.cleanup(), this.emit("disconnect");
  }
  /**
   * Handle account changed event
   */
  handleAccountChanged(e) {
    this.logger.info("Account changed", e), this.currentAccount = e, this.emit("accountChanged", e);
  }
  /**
   * Handle network changed event
   */
  handleNetworkChanged(e) {
    this.logger.info("Network changed", e), this.currentAccount && (this.currentAccount.network = e), this.emit("networkChanged", e);
  }
  /**
   * Cleanup connection state
   */
  async cleanup() {
    this.currentAdapter = null, this.currentAccount = null, await this.storage.clearState();
  }
};
var pp = { exports: {} };
(function(r, e) {
  (function(t, n) {
    r.exports = n();
  })(B, () => (() => {
    var t = { 873: (o, a) => {
      var u, c, l = function() {
        var d = function(z, j) {
          var I = z, y = _[j], m = null, N = 0, T = null, x = [], L = {}, V = function(Q, X) {
            m = function(Y) {
              for (var J = new Array(Y), ie = 0; ie < Y; ie += 1) {
                J[ie] = new Array(Y);
                for (var fe = 0; fe < Y; fe += 1) J[ie][fe] = null;
              }
              return J;
            }(N = 4 * I + 17), q(0, 0), q(N - 7, 0), q(0, N - 7), Z(), K(), ne(Q, X), I >= 7 && re(Q), T == null && (T = ue(I, y, x)), se(T, X);
          }, q = function(Q, X) {
            for (var Y = -1; Y <= 7; Y += 1) if (!(Q + Y <= -1 || N <= Q + Y)) for (var J = -1; J <= 7; J += 1) X + J <= -1 || N <= X + J || (m[Q + Y][X + J] = 0 <= Y && Y <= 6 && (J == 0 || J == 6) || 0 <= J && J <= 6 && (Y == 0 || Y == 6) || 2 <= Y && Y <= 4 && 2 <= J && J <= 4);
          }, K = function() {
            for (var Q = 8; Q < N - 8; Q += 1) m[Q][6] == null && (m[Q][6] = Q % 2 == 0);
            for (var X = 8; X < N - 8; X += 1) m[6][X] == null && (m[6][X] = X % 2 == 0);
          }, Z = function() {
            for (var Q = D.getPatternPosition(I), X = 0; X < Q.length; X += 1) for (var Y = 0; Y < Q.length; Y += 1) {
              var J = Q[X], ie = Q[Y];
              if (m[J][ie] == null) for (var fe = -2; fe <= 2; fe += 1) for (var ye = -2; ye <= 2; ye += 1) m[J + fe][ie + ye] = fe == -2 || fe == 2 || ye == -2 || ye == 2 || fe == 0 && ye == 0;
            }
          }, re = function(Q) {
            for (var X = D.getBCHTypeNumber(I), Y = 0; Y < 18; Y += 1) {
              var J = !Q && (X >> Y & 1) == 1;
              m[Math.floor(Y / 3)][Y % 3 + N - 8 - 3] = J;
            }
            for (Y = 0; Y < 18; Y += 1) J = !Q && (X >> Y & 1) == 1, m[Y % 3 + N - 8 - 3][Math.floor(Y / 3)] = J;
          }, ne = function(Q, X) {
            for (var Y = y << 3 | X, J = D.getBCHTypeInfo(Y), ie = 0; ie < 15; ie += 1) {
              var fe = !Q && (J >> ie & 1) == 1;
              ie < 6 ? m[ie][8] = fe : ie < 8 ? m[ie + 1][8] = fe : m[N - 15 + ie][8] = fe;
            }
            for (ie = 0; ie < 15; ie += 1) fe = !Q && (J >> ie & 1) == 1, ie < 8 ? m[8][N - ie - 1] = fe : ie < 9 ? m[8][15 - ie - 1 + 1] = fe : m[8][15 - ie - 1] = fe;
            m[N - 8][8] = !Q;
          }, se = function(Q, X) {
            for (var Y = -1, J = N - 1, ie = 7, fe = 0, ye = D.getMaskFunction(X), we = N - 1; we > 0; we -= 2) for (we == 6 && (we -= 1); ; ) {
              for (var Ie = 0; Ie < 2; Ie += 1) if (m[J][we - Ie] == null) {
                var Ee = false;
                fe < Q.length && (Ee = (Q[fe] >>> ie & 1) == 1), ye(J, we - Ie) && (Ee = !Ee), m[J][we - Ie] = Ee, (ie -= 1) == -1 && (fe += 1, ie = 7);
              }
              if ((J += Y) < 0 || N <= J) {
                J -= Y, Y = -Y;
                break;
              }
            }
          }, ue = function(Q, X, Y) {
            for (var J = A.getRSBlocks(Q, X), ie = k(), fe = 0; fe < Y.length; fe += 1) {
              var ye = Y[fe];
              ie.put(ye.getMode(), 4), ie.put(ye.getLength(), D.getLengthInBits(ye.getMode(), Q)), ye.write(ie);
            }
            var we = 0;
            for (fe = 0; fe < J.length; fe += 1) we += J[fe].dataCount;
            if (ie.getLengthInBits() > 8 * we) throw "code length overflow. (" + ie.getLengthInBits() + ">" + 8 * we + ")";
            for (ie.getLengthInBits() + 4 <= 8 * we && ie.put(0, 4); ie.getLengthInBits() % 8 != 0; ) ie.putBit(false);
            for (; !(ie.getLengthInBits() >= 8 * we || (ie.put(236, 8), ie.getLengthInBits() >= 8 * we)); ) ie.put(17, 8);
            return function(Ie, Ee) {
              for (var Me = 0, Ve = 0, Fe = 0, xe = new Array(Ee.length), _e = new Array(Ee.length), O = 0; O < Ee.length; O += 1) {
                var w = Ee[O].dataCount, M = Ee[O].totalCount - w;
                Ve = Math.max(Ve, w), Fe = Math.max(Fe, M), xe[O] = new Array(w);
                for (var C = 0; C < xe[O].length; C += 1) xe[O][C] = 255 & Ie.getBuffer()[C + Me];
                Me += w;
                var F = D.getErrorCorrectPolynomial(M), W = E(xe[O], F.getLength() - 1).mod(F);
                for (_e[O] = new Array(F.getLength() - 1), C = 0; C < _e[O].length; C += 1) {
                  var te = C + W.getLength() - _e[O].length;
                  _e[O][C] = te >= 0 ? W.getAt(te) : 0;
                }
              }
              var be = 0;
              for (C = 0; C < Ee.length; C += 1) be += Ee[C].totalCount;
              var ke = new Array(be), De = 0;
              for (C = 0; C < Ve; C += 1) for (O = 0; O < Ee.length; O += 1) C < xe[O].length && (ke[De] = xe[O][C], De += 1);
              for (C = 0; C < Fe; C += 1) for (O = 0; O < Ee.length; O += 1) C < _e[O].length && (ke[De] = _e[O][C], De += 1);
              return ke;
            }(ie, J);
          };
          L.addData = function(Q, X) {
            var Y = null;
            switch (X = X || "Byte") {
              case "Numeric":
                Y = U(Q);
                break;
              case "Alphanumeric":
                Y = P(Q);
                break;
              case "Byte":
                Y = $(Q);
                break;
              case "Kanji":
                Y = ee(Q);
                break;
              default:
                throw "mode:" + X;
            }
            x.push(Y), T = null;
          }, L.isDark = function(Q, X) {
            if (Q < 0 || N <= Q || X < 0 || N <= X) throw Q + "," + X;
            return m[Q][X];
          }, L.getModuleCount = function() {
            return N;
          }, L.make = function() {
            if (I < 1) {
              for (var Q = 1; Q < 40; Q++) {
                for (var X = A.getRSBlocks(Q, y), Y = k(), J = 0; J < x.length; J++) {
                  var ie = x[J];
                  Y.put(ie.getMode(), 4), Y.put(ie.getLength(), D.getLengthInBits(ie.getMode(), Q)), ie.write(Y);
                }
                var fe = 0;
                for (J = 0; J < X.length; J++) fe += X[J].dataCount;
                if (Y.getLengthInBits() <= 8 * fe) break;
              }
              I = Q;
            }
            V(false, function() {
              for (var ye = 0, we = 0, Ie = 0; Ie < 8; Ie += 1) {
                V(true, Ie);
                var Ee = D.getLostPoint(L);
                (Ie == 0 || ye > Ee) && (ye = Ee, we = Ie);
              }
              return we;
            }());
          }, L.createTableTag = function(Q, X) {
            Q = Q || 2;
            var Y = "";
            Y += '<table style="', Y += " border-width: 0px; border-style: none;", Y += " border-collapse: collapse;", Y += " padding: 0px; margin: " + (X = X === void 0 ? 4 * Q : X) + "px;", Y += '">', Y += "<tbody>";
            for (var J = 0; J < L.getModuleCount(); J += 1) {
              Y += "<tr>";
              for (var ie = 0; ie < L.getModuleCount(); ie += 1) Y += '<td style="', Y += " border-width: 0px; border-style: none;", Y += " border-collapse: collapse;", Y += " padding: 0px; margin: 0px;", Y += " width: " + Q + "px;", Y += " height: " + Q + "px;", Y += " background-color: ", Y += L.isDark(J, ie) ? "#000000" : "#ffffff", Y += ";", Y += '"/>';
              Y += "</tr>";
            }
            return (Y += "</tbody>") + "</table>";
          }, L.createSvgTag = function(Q, X, Y, J) {
            var ie = {};
            typeof arguments[0] == "object" && (Q = (ie = arguments[0]).cellSize, X = ie.margin, Y = ie.alt, J = ie.title), Q = Q || 2, X = X === void 0 ? 4 * Q : X, (Y = typeof Y == "string" ? { text: Y } : Y || {}).text = Y.text || null, Y.id = Y.text ? Y.id || "qrcode-description" : null, (J = typeof J == "string" ? { text: J } : J || {}).text = J.text || null, J.id = J.text ? J.id || "qrcode-title" : null;
            var fe, ye, we, Ie, Ee = L.getModuleCount() * Q + 2 * X, Me = "";
            for (Ie = "l" + Q + ",0 0," + Q + " -" + Q + ",0 0,-" + Q + "z ", Me += '<svg version="1.1" xmlns="http://www.w3.org/2000/svg"', Me += ie.scalable ? "" : ' width="' + Ee + 'px" height="' + Ee + 'px"', Me += ' viewBox="0 0 ' + Ee + " " + Ee + '" ', Me += ' preserveAspectRatio="xMinYMin meet"', Me += J.text || Y.text ? ' role="img" aria-labelledby="' + he([J.id, Y.id].join(" ").trim()) + '"' : "", Me += ">", Me += J.text ? '<title id="' + he(J.id) + '">' + he(J.text) + "</title>" : "", Me += Y.text ? '<description id="' + he(Y.id) + '">' + he(Y.text) + "</description>" : "", Me += '<rect width="100%" height="100%" fill="white" cx="0" cy="0"/>', Me += '<path d="', ye = 0; ye < L.getModuleCount(); ye += 1) for (we = ye * Q + X, fe = 0; fe < L.getModuleCount(); fe += 1) L.isDark(ye, fe) && (Me += "M" + (fe * Q + X) + "," + we + Ie);
            return (Me += '" stroke="transparent" fill="black"/>') + "</svg>";
          }, L.createDataURL = function(Q, X) {
            Q = Q || 2, X = X === void 0 ? 4 * Q : X;
            var Y = L.getModuleCount() * Q + 2 * X, J = X, ie = Y - X;
            return R(Y, Y, function(fe, ye) {
              if (J <= fe && fe < ie && J <= ye && ye < ie) {
                var we = Math.floor((fe - J) / Q), Ie = Math.floor((ye - J) / Q);
                return L.isDark(Ie, we) ? 0 : 1;
              }
              return 1;
            });
          }, L.createImgTag = function(Q, X, Y) {
            Q = Q || 2, X = X === void 0 ? 4 * Q : X;
            var J = L.getModuleCount() * Q + 2 * X, ie = "";
            return ie += "<img", ie += ' src="', ie += L.createDataURL(Q, X), ie += '"', ie += ' width="', ie += J, ie += '"', ie += ' height="', ie += J, ie += '"', Y && (ie += ' alt="', ie += he(Y), ie += '"'), ie + "/>";
          };
          var he = function(Q) {
            for (var X = "", Y = 0; Y < Q.length; Y += 1) {
              var J = Q.charAt(Y);
              switch (J) {
                case "<":
                  X += "&lt;";
                  break;
                case ">":
                  X += "&gt;";
                  break;
                case "&":
                  X += "&amp;";
                  break;
                case '"':
                  X += "&quot;";
                  break;
                default:
                  X += J;
              }
            }
            return X;
          };
          return L.createASCII = function(Q, X) {
            if ((Q = Q || 1) < 2) return function(xe) {
              xe = xe === void 0 ? 2 : xe;
              var _e, O, w, M, C, F = 1 * L.getModuleCount() + 2 * xe, W = xe, te = F - xe, be = { "██": "█", "█ ": "▀", " █": "▄", "  ": " " }, ke = { "██": "▀", "█ ": "▀", " █": " ", "  ": " " }, De = "";
              for (_e = 0; _e < F; _e += 2) {
                for (w = Math.floor((_e - W) / 1), M = Math.floor((_e + 1 - W) / 1), O = 0; O < F; O += 1) C = "█", W <= O && O < te && W <= _e && _e < te && L.isDark(w, Math.floor((O - W) / 1)) && (C = " "), W <= O && O < te && W <= _e + 1 && _e + 1 < te && L.isDark(M, Math.floor((O - W) / 1)) ? C += " " : C += "█", De += xe < 1 && _e + 1 >= te ? ke[C] : be[C];
                De += `
`;
              }
              return F % 2 && xe > 0 ? De.substring(0, De.length - F - 1) + Array(F + 1).join("▀") : De.substring(0, De.length - 1);
            }(X);
            Q -= 1, X = X === void 0 ? 2 * Q : X;
            var Y, J, ie, fe, ye = L.getModuleCount() * Q + 2 * X, we = X, Ie = ye - X, Ee = Array(Q + 1).join("██"), Me = Array(Q + 1).join("  "), Ve = "", Fe = "";
            for (Y = 0; Y < ye; Y += 1) {
              for (ie = Math.floor((Y - we) / Q), Fe = "", J = 0; J < ye; J += 1) fe = 1, we <= J && J < Ie && we <= Y && Y < Ie && L.isDark(ie, Math.floor((J - we) / Q)) && (fe = 0), Fe += fe ? Ee : Me;
              for (ie = 0; ie < Q; ie += 1) Ve += Fe + `
`;
            }
            return Ve.substring(0, Ve.length - 1);
          }, L.renderTo2dContext = function(Q, X) {
            X = X || 2;
            for (var Y = L.getModuleCount(), J = 0; J < Y; J++) for (var ie = 0; ie < Y; ie++) Q.fillStyle = L.isDark(J, ie) ? "black" : "white", Q.fillRect(J * X, ie * X, X, X);
          }, L;
        };
        d.stringToBytes = (d.stringToBytesFuncs = { default: function(z) {
          for (var j = [], I = 0; I < z.length; I += 1) {
            var y = z.charCodeAt(I);
            j.push(255 & y);
          }
          return j;
        } }).default, d.createStringToBytes = function(z, j) {
          var I = function() {
            for (var m = H(z), N = function() {
              var K = m.read();
              if (K == -1) throw "eof";
              return K;
            }, T = 0, x = {}; ; ) {
              var L = m.read();
              if (L == -1) break;
              var V = N(), q = N() << 8 | N();
              x[String.fromCharCode(L << 8 | V)] = q, T += 1;
            }
            if (T != j) throw T + " != " + j;
            return x;
          }(), y = 63;
          return function(m) {
            for (var N = [], T = 0; T < m.length; T += 1) {
              var x = m.charCodeAt(T);
              if (x < 128) N.push(x);
              else {
                var L = I[m.charAt(T)];
                typeof L == "number" ? (255 & L) == L ? N.push(L) : (N.push(L >>> 8), N.push(255 & L)) : N.push(y);
              }
            }
            return N;
          };
        };
        var h, f, g, p, b, _ = { L: 1, M: 0, Q: 3, H: 2 }, D = (h = [[], [6, 18], [6, 22], [6, 26], [6, 30], [6, 34], [6, 22, 38], [6, 24, 42], [6, 26, 46], [6, 28, 50], [6, 30, 54], [6, 32, 58], [6, 34, 62], [6, 26, 46, 66], [6, 26, 48, 70], [6, 26, 50, 74], [6, 30, 54, 78], [6, 30, 56, 82], [6, 30, 58, 86], [6, 34, 62, 90], [6, 28, 50, 72, 94], [6, 26, 50, 74, 98], [6, 30, 54, 78, 102], [6, 28, 54, 80, 106], [6, 32, 58, 84, 110], [6, 30, 58, 86, 114], [6, 34, 62, 90, 118], [6, 26, 50, 74, 98, 122], [6, 30, 54, 78, 102, 126], [6, 26, 52, 78, 104, 130], [6, 30, 56, 82, 108, 134], [6, 34, 60, 86, 112, 138], [6, 30, 58, 86, 114, 142], [6, 34, 62, 90, 118, 146], [6, 30, 54, 78, 102, 126, 150], [6, 24, 50, 76, 102, 128, 154], [6, 28, 54, 80, 106, 132, 158], [6, 32, 58, 84, 110, 136, 162], [6, 26, 54, 82, 110, 138, 166], [6, 30, 58, 86, 114, 142, 170]], f = 1335, g = 7973, b = function(z) {
          for (var j = 0; z != 0; ) j += 1, z >>>= 1;
          return j;
        }, (p = {}).getBCHTypeInfo = function(z) {
          for (var j = z << 10; b(j) - b(f) >= 0; ) j ^= f << b(j) - b(f);
          return 21522 ^ (z << 10 | j);
        }, p.getBCHTypeNumber = function(z) {
          for (var j = z << 12; b(j) - b(g) >= 0; ) j ^= g << b(j) - b(g);
          return z << 12 | j;
        }, p.getPatternPosition = function(z) {
          return h[z - 1];
        }, p.getMaskFunction = function(z) {
          switch (z) {
            case 0:
              return function(j, I) {
                return (j + I) % 2 == 0;
              };
            case 1:
              return function(j, I) {
                return j % 2 == 0;
              };
            case 2:
              return function(j, I) {
                return I % 3 == 0;
              };
            case 3:
              return function(j, I) {
                return (j + I) % 3 == 0;
              };
            case 4:
              return function(j, I) {
                return (Math.floor(j / 2) + Math.floor(I / 3)) % 2 == 0;
              };
            case 5:
              return function(j, I) {
                return j * I % 2 + j * I % 3 == 0;
              };
            case 6:
              return function(j, I) {
                return (j * I % 2 + j * I % 3) % 2 == 0;
              };
            case 7:
              return function(j, I) {
                return (j * I % 3 + (j + I) % 2) % 2 == 0;
              };
            default:
              throw "bad maskPattern:" + z;
          }
        }, p.getErrorCorrectPolynomial = function(z) {
          for (var j = E([1], 0), I = 0; I < z; I += 1) j = j.multiply(E([1, v.gexp(I)], 0));
          return j;
        }, p.getLengthInBits = function(z, j) {
          if (1 <= j && j < 10) switch (z) {
            case 1:
              return 10;
            case 2:
              return 9;
            case 4:
            case 8:
              return 8;
            default:
              throw "mode:" + z;
          }
          else if (j < 27) switch (z) {
            case 1:
              return 12;
            case 2:
              return 11;
            case 4:
              return 16;
            case 8:
              return 10;
            default:
              throw "mode:" + z;
          }
          else {
            if (!(j < 41)) throw "type:" + j;
            switch (z) {
              case 1:
                return 14;
              case 2:
                return 13;
              case 4:
                return 16;
              case 8:
                return 12;
              default:
                throw "mode:" + z;
            }
          }
        }, p.getLostPoint = function(z) {
          for (var j = z.getModuleCount(), I = 0, y = 0; y < j; y += 1) for (var m = 0; m < j; m += 1) {
            for (var N = 0, T = z.isDark(y, m), x = -1; x <= 1; x += 1) if (!(y + x < 0 || j <= y + x)) for (var L = -1; L <= 1; L += 1) m + L < 0 || j <= m + L || x == 0 && L == 0 || T == z.isDark(y + x, m + L) && (N += 1);
            N > 5 && (I += 3 + N - 5);
          }
          for (y = 0; y < j - 1; y += 1) for (m = 0; m < j - 1; m += 1) {
            var V = 0;
            z.isDark(y, m) && (V += 1), z.isDark(y + 1, m) && (V += 1), z.isDark(y, m + 1) && (V += 1), z.isDark(y + 1, m + 1) && (V += 1), V != 0 && V != 4 || (I += 3);
          }
          for (y = 0; y < j; y += 1) for (m = 0; m < j - 6; m += 1) z.isDark(y, m) && !z.isDark(y, m + 1) && z.isDark(y, m + 2) && z.isDark(y, m + 3) && z.isDark(y, m + 4) && !z.isDark(y, m + 5) && z.isDark(y, m + 6) && (I += 40);
          for (m = 0; m < j; m += 1) for (y = 0; y < j - 6; y += 1) z.isDark(y, m) && !z.isDark(y + 1, m) && z.isDark(y + 2, m) && z.isDark(y + 3, m) && z.isDark(y + 4, m) && !z.isDark(y + 5, m) && z.isDark(y + 6, m) && (I += 40);
          var q = 0;
          for (m = 0; m < j; m += 1) for (y = 0; y < j; y += 1) z.isDark(y, m) && (q += 1);
          return I + Math.abs(100 * q / j / j - 50) / 5 * 10;
        }, p), v = function() {
          for (var z = new Array(256), j = new Array(256), I = 0; I < 8; I += 1) z[I] = 1 << I;
          for (I = 8; I < 256; I += 1) z[I] = z[I - 4] ^ z[I - 5] ^ z[I - 6] ^ z[I - 8];
          for (I = 0; I < 255; I += 1) j[z[I]] = I;
          return { glog: function(y) {
            if (y < 1) throw "glog(" + y + ")";
            return j[y];
          }, gexp: function(y) {
            for (; y < 0; ) y += 255;
            for (; y >= 256; ) y -= 255;
            return z[y];
          } };
        }();
        function E(z, j) {
          if (z.length === void 0) throw z.length + "/" + j;
          var I = function() {
            for (var m = 0; m < z.length && z[m] == 0; ) m += 1;
            for (var N = new Array(z.length - m + j), T = 0; T < z.length - m; T += 1) N[T] = z[T + m];
            return N;
          }(), y = { getAt: function(m) {
            return I[m];
          }, getLength: function() {
            return I.length;
          }, multiply: function(m) {
            for (var N = new Array(y.getLength() + m.getLength() - 1), T = 0; T < y.getLength(); T += 1) for (var x = 0; x < m.getLength(); x += 1) N[T + x] ^= v.gexp(v.glog(y.getAt(T)) + v.glog(m.getAt(x)));
            return E(N, 0);
          }, mod: function(m) {
            if (y.getLength() - m.getLength() < 0) return y;
            for (var N = v.glog(y.getAt(0)) - v.glog(m.getAt(0)), T = new Array(y.getLength()), x = 0; x < y.getLength(); x += 1) T[x] = y.getAt(x);
            for (x = 0; x < m.getLength(); x += 1) T[x] ^= v.gexp(v.glog(m.getAt(x)) + N);
            return E(T, 0).mod(m);
          } };
          return y;
        }
        var A = /* @__PURE__ */ function() {
          var z = [[1, 26, 19], [1, 26, 16], [1, 26, 13], [1, 26, 9], [1, 44, 34], [1, 44, 28], [1, 44, 22], [1, 44, 16], [1, 70, 55], [1, 70, 44], [2, 35, 17], [2, 35, 13], [1, 100, 80], [2, 50, 32], [2, 50, 24], [4, 25, 9], [1, 134, 108], [2, 67, 43], [2, 33, 15, 2, 34, 16], [2, 33, 11, 2, 34, 12], [2, 86, 68], [4, 43, 27], [4, 43, 19], [4, 43, 15], [2, 98, 78], [4, 49, 31], [2, 32, 14, 4, 33, 15], [4, 39, 13, 1, 40, 14], [2, 121, 97], [2, 60, 38, 2, 61, 39], [4, 40, 18, 2, 41, 19], [4, 40, 14, 2, 41, 15], [2, 146, 116], [3, 58, 36, 2, 59, 37], [4, 36, 16, 4, 37, 17], [4, 36, 12, 4, 37, 13], [2, 86, 68, 2, 87, 69], [4, 69, 43, 1, 70, 44], [6, 43, 19, 2, 44, 20], [6, 43, 15, 2, 44, 16], [4, 101, 81], [1, 80, 50, 4, 81, 51], [4, 50, 22, 4, 51, 23], [3, 36, 12, 8, 37, 13], [2, 116, 92, 2, 117, 93], [6, 58, 36, 2, 59, 37], [4, 46, 20, 6, 47, 21], [7, 42, 14, 4, 43, 15], [4, 133, 107], [8, 59, 37, 1, 60, 38], [8, 44, 20, 4, 45, 21], [12, 33, 11, 4, 34, 12], [3, 145, 115, 1, 146, 116], [4, 64, 40, 5, 65, 41], [11, 36, 16, 5, 37, 17], [11, 36, 12, 5, 37, 13], [5, 109, 87, 1, 110, 88], [5, 65, 41, 5, 66, 42], [5, 54, 24, 7, 55, 25], [11, 36, 12, 7, 37, 13], [5, 122, 98, 1, 123, 99], [7, 73, 45, 3, 74, 46], [15, 43, 19, 2, 44, 20], [3, 45, 15, 13, 46, 16], [1, 135, 107, 5, 136, 108], [10, 74, 46, 1, 75, 47], [1, 50, 22, 15, 51, 23], [2, 42, 14, 17, 43, 15], [5, 150, 120, 1, 151, 121], [9, 69, 43, 4, 70, 44], [17, 50, 22, 1, 51, 23], [2, 42, 14, 19, 43, 15], [3, 141, 113, 4, 142, 114], [3, 70, 44, 11, 71, 45], [17, 47, 21, 4, 48, 22], [9, 39, 13, 16, 40, 14], [3, 135, 107, 5, 136, 108], [3, 67, 41, 13, 68, 42], [15, 54, 24, 5, 55, 25], [15, 43, 15, 10, 44, 16], [4, 144, 116, 4, 145, 117], [17, 68, 42], [17, 50, 22, 6, 51, 23], [19, 46, 16, 6, 47, 17], [2, 139, 111, 7, 140, 112], [17, 74, 46], [7, 54, 24, 16, 55, 25], [34, 37, 13], [4, 151, 121, 5, 152, 122], [4, 75, 47, 14, 76, 48], [11, 54, 24, 14, 55, 25], [16, 45, 15, 14, 46, 16], [6, 147, 117, 4, 148, 118], [6, 73, 45, 14, 74, 46], [11, 54, 24, 16, 55, 25], [30, 46, 16, 2, 47, 17], [8, 132, 106, 4, 133, 107], [8, 75, 47, 13, 76, 48], [7, 54, 24, 22, 55, 25], [22, 45, 15, 13, 46, 16], [10, 142, 114, 2, 143, 115], [19, 74, 46, 4, 75, 47], [28, 50, 22, 6, 51, 23], [33, 46, 16, 4, 47, 17], [8, 152, 122, 4, 153, 123], [22, 73, 45, 3, 74, 46], [8, 53, 23, 26, 54, 24], [12, 45, 15, 28, 46, 16], [3, 147, 117, 10, 148, 118], [3, 73, 45, 23, 74, 46], [4, 54, 24, 31, 55, 25], [11, 45, 15, 31, 46, 16], [7, 146, 116, 7, 147, 117], [21, 73, 45, 7, 74, 46], [1, 53, 23, 37, 54, 24], [19, 45, 15, 26, 46, 16], [5, 145, 115, 10, 146, 116], [19, 75, 47, 10, 76, 48], [15, 54, 24, 25, 55, 25], [23, 45, 15, 25, 46, 16], [13, 145, 115, 3, 146, 116], [2, 74, 46, 29, 75, 47], [42, 54, 24, 1, 55, 25], [23, 45, 15, 28, 46, 16], [17, 145, 115], [10, 74, 46, 23, 75, 47], [10, 54, 24, 35, 55, 25], [19, 45, 15, 35, 46, 16], [17, 145, 115, 1, 146, 116], [14, 74, 46, 21, 75, 47], [29, 54, 24, 19, 55, 25], [11, 45, 15, 46, 46, 16], [13, 145, 115, 6, 146, 116], [14, 74, 46, 23, 75, 47], [44, 54, 24, 7, 55, 25], [59, 46, 16, 1, 47, 17], [12, 151, 121, 7, 152, 122], [12, 75, 47, 26, 76, 48], [39, 54, 24, 14, 55, 25], [22, 45, 15, 41, 46, 16], [6, 151, 121, 14, 152, 122], [6, 75, 47, 34, 76, 48], [46, 54, 24, 10, 55, 25], [2, 45, 15, 64, 46, 16], [17, 152, 122, 4, 153, 123], [29, 74, 46, 14, 75, 47], [49, 54, 24, 10, 55, 25], [24, 45, 15, 46, 46, 16], [4, 152, 122, 18, 153, 123], [13, 74, 46, 32, 75, 47], [48, 54, 24, 14, 55, 25], [42, 45, 15, 32, 46, 16], [20, 147, 117, 4, 148, 118], [40, 75, 47, 7, 76, 48], [43, 54, 24, 22, 55, 25], [10, 45, 15, 67, 46, 16], [19, 148, 118, 6, 149, 119], [18, 75, 47, 31, 76, 48], [34, 54, 24, 34, 55, 25], [20, 45, 15, 61, 46, 16]], j = function(y, m) {
            var N = {};
            return N.totalCount = y, N.dataCount = m, N;
          }, I = { getRSBlocks: function(y, m) {
            var N = function(re, ne) {
              switch (ne) {
                case _.L:
                  return z[4 * (re - 1) + 0];
                case _.M:
                  return z[4 * (re - 1) + 1];
                case _.Q:
                  return z[4 * (re - 1) + 2];
                case _.H:
                  return z[4 * (re - 1) + 3];
                default:
                  return;
              }
            }(y, m);
            if (N === void 0) throw "bad rs block @ typeNumber:" + y + "/errorCorrectionLevel:" + m;
            for (var T = N.length / 3, x = [], L = 0; L < T; L += 1) for (var V = N[3 * L + 0], q = N[3 * L + 1], K = N[3 * L + 2], Z = 0; Z < V; Z += 1) x.push(j(q, K));
            return x;
          } };
          return I;
        }(), k = function() {
          var z = [], j = 0, I = { getBuffer: function() {
            return z;
          }, getAt: function(y) {
            var m = Math.floor(y / 8);
            return (z[m] >>> 7 - y % 8 & 1) == 1;
          }, put: function(y, m) {
            for (var N = 0; N < m; N += 1) I.putBit((y >>> m - N - 1 & 1) == 1);
          }, getLengthInBits: function() {
            return j;
          }, putBit: function(y) {
            var m = Math.floor(j / 8);
            z.length <= m && z.push(0), y && (z[m] |= 128 >>> j % 8), j += 1;
          } };
          return I;
        }, U = function(z) {
          var j = z, I = { getMode: function() {
            return 1;
          }, getLength: function(N) {
            return j.length;
          }, write: function(N) {
            for (var T = j, x = 0; x + 2 < T.length; ) N.put(y(T.substring(x, x + 3)), 10), x += 3;
            x < T.length && (T.length - x == 1 ? N.put(y(T.substring(x, x + 1)), 4) : T.length - x == 2 && N.put(y(T.substring(x, x + 2)), 7));
          } }, y = function(N) {
            for (var T = 0, x = 0; x < N.length; x += 1) T = 10 * T + m(N.charAt(x));
            return T;
          }, m = function(N) {
            if ("0" <= N && N <= "9") return N.charCodeAt(0) - 48;
            throw "illegal char :" + N;
          };
          return I;
        }, P = function(z) {
          var j = z, I = { getMode: function() {
            return 2;
          }, getLength: function(m) {
            return j.length;
          }, write: function(m) {
            for (var N = j, T = 0; T + 1 < N.length; ) m.put(45 * y(N.charAt(T)) + y(N.charAt(T + 1)), 11), T += 2;
            T < N.length && m.put(y(N.charAt(T)), 6);
          } }, y = function(m) {
            if ("0" <= m && m <= "9") return m.charCodeAt(0) - 48;
            if ("A" <= m && m <= "Z") return m.charCodeAt(0) - 65 + 10;
            switch (m) {
              case " ":
                return 36;
              case "$":
                return 37;
              case "%":
                return 38;
              case "*":
                return 39;
              case "+":
                return 40;
              case "-":
                return 41;
              case ".":
                return 42;
              case "/":
                return 43;
              case ":":
                return 44;
              default:
                throw "illegal char :" + m;
            }
          };
          return I;
        }, $ = function(z) {
          var j = d.stringToBytes(z);
          return { getMode: function() {
            return 4;
          }, getLength: function(I) {
            return j.length;
          }, write: function(I) {
            for (var y = 0; y < j.length; y += 1) I.put(j[y], 8);
          } };
        }, ee = function(z) {
          var j = d.stringToBytesFuncs.SJIS;
          if (!j) throw "sjis not supported.";
          (function() {
            var m = j("友");
            if (m.length != 2 || (m[0] << 8 | m[1]) != 38726) throw "sjis not supported.";
          })();
          var I = j(z), y = { getMode: function() {
            return 8;
          }, getLength: function(m) {
            return ~~(I.length / 2);
          }, write: function(m) {
            for (var N = I, T = 0; T + 1 < N.length; ) {
              var x = (255 & N[T]) << 8 | 255 & N[T + 1];
              if (33088 <= x && x <= 40956) x -= 33088;
              else {
                if (!(57408 <= x && x <= 60351)) throw "illegal char at " + (T + 1) + "/" + x;
                x -= 49472;
              }
              x = 192 * (x >>> 8 & 255) + (255 & x), m.put(x, 13), T += 2;
            }
            if (T < N.length) throw "illegal char at " + (T + 1);
          } };
          return y;
        }, G = function() {
          var z = [], j = { writeByte: function(I) {
            z.push(255 & I);
          }, writeShort: function(I) {
            j.writeByte(I), j.writeByte(I >>> 8);
          }, writeBytes: function(I, y, m) {
            y = y || 0, m = m || I.length;
            for (var N = 0; N < m; N += 1) j.writeByte(I[N + y]);
          }, writeString: function(I) {
            for (var y = 0; y < I.length; y += 1) j.writeByte(I.charCodeAt(y));
          }, toByteArray: function() {
            return z;
          }, toString: function() {
            var I = "";
            I += "[";
            for (var y = 0; y < z.length; y += 1) y > 0 && (I += ","), I += z[y];
            return I + "]";
          } };
          return j;
        }, H = function(z) {
          var j = z, I = 0, y = 0, m = 0, N = { read: function() {
            for (; m < 8; ) {
              if (I >= j.length) {
                if (m == 0) return -1;
                throw "unexpected end of file./" + m;
              }
              var x = j.charAt(I);
              if (I += 1, x == "=") return m = 0, -1;
              x.match(/^\s$/) || (y = y << 6 | T(x.charCodeAt(0)), m += 6);
            }
            var L = y >>> m - 8 & 255;
            return m -= 8, L;
          } }, T = function(x) {
            if (65 <= x && x <= 90) return x - 65;
            if (97 <= x && x <= 122) return x - 97 + 26;
            if (48 <= x && x <= 57) return x - 48 + 52;
            if (x == 43) return 62;
            if (x == 47) return 63;
            throw "c:" + x;
          };
          return N;
        }, R = function(z, j, I) {
          for (var y = function(q, K) {
            var Z = q, re = K, ne = new Array(q * K), se = { setPixel: function(Q, X, Y) {
              ne[X * Z + Q] = Y;
            }, write: function(Q) {
              Q.writeString("GIF87a"), Q.writeShort(Z), Q.writeShort(re), Q.writeByte(128), Q.writeByte(0), Q.writeByte(0), Q.writeByte(0), Q.writeByte(0), Q.writeByte(0), Q.writeByte(255), Q.writeByte(255), Q.writeByte(255), Q.writeString(","), Q.writeShort(0), Q.writeShort(0), Q.writeShort(Z), Q.writeShort(re), Q.writeByte(0);
              var X = ue(2);
              Q.writeByte(2);
              for (var Y = 0; X.length - Y > 255; ) Q.writeByte(255), Q.writeBytes(X, Y, 255), Y += 255;
              Q.writeByte(X.length - Y), Q.writeBytes(X, Y, X.length - Y), Q.writeByte(0), Q.writeString(";");
            } }, ue = function(Q) {
              for (var X = 1 << Q, Y = 1 + (1 << Q), J = Q + 1, ie = he(), fe = 0; fe < X; fe += 1) ie.add(String.fromCharCode(fe));
              ie.add(String.fromCharCode(X)), ie.add(String.fromCharCode(Y));
              var ye, we, Ie, Ee = G(), Me = (ye = Ee, we = 0, Ie = 0, { write: function(_e, O) {
                if (_e >>> O) throw "length over";
                for (; we + O >= 8; ) ye.writeByte(255 & (_e << we | Ie)), O -= 8 - we, _e >>>= 8 - we, Ie = 0, we = 0;
                Ie |= _e << we, we += O;
              }, flush: function() {
                we > 0 && ye.writeByte(Ie);
              } });
              Me.write(X, J);
              var Ve = 0, Fe = String.fromCharCode(ne[Ve]);
              for (Ve += 1; Ve < ne.length; ) {
                var xe = String.fromCharCode(ne[Ve]);
                Ve += 1, ie.contains(Fe + xe) ? Fe += xe : (Me.write(ie.indexOf(Fe), J), ie.size() < 4095 && (ie.size() == 1 << J && (J += 1), ie.add(Fe + xe)), Fe = xe);
              }
              return Me.write(ie.indexOf(Fe), J), Me.write(Y, J), Me.flush(), Ee.toByteArray();
            }, he = function() {
              var Q = {}, X = 0, Y = { add: function(J) {
                if (Y.contains(J)) throw "dup key:" + J;
                Q[J] = X, X += 1;
              }, size: function() {
                return X;
              }, indexOf: function(J) {
                return Q[J];
              }, contains: function(J) {
                return Q[J] !== void 0;
              } };
              return Y;
            };
            return se;
          }(z, j), m = 0; m < j; m += 1) for (var N = 0; N < z; N += 1) y.setPixel(N, m, I(N, m));
          var T = G();
          y.write(T);
          for (var x = function() {
            var q = 0, K = 0, Z = 0, re = "", ne = {}, se = function(he) {
              re += String.fromCharCode(ue(63 & he));
            }, ue = function(he) {
              if (!(he < 0)) {
                if (he < 26) return 65 + he;
                if (he < 52) return he - 26 + 97;
                if (he < 62) return he - 52 + 48;
                if (he == 62) return 43;
                if (he == 63) return 47;
              }
              throw "n:" + he;
            };
            return ne.writeByte = function(he) {
              for (q = q << 8 | 255 & he, K += 8, Z += 1; K >= 6; ) se(q >>> K - 6), K -= 6;
            }, ne.flush = function() {
              if (K > 0 && (se(q << 6 - K), q = 0, K = 0), Z % 3 != 0) for (var he = 3 - Z % 3, Q = 0; Q < he; Q += 1) re += "=";
            }, ne.toString = function() {
              return re;
            }, ne;
          }(), L = T.toByteArray(), V = 0; V < L.length; V += 1) x.writeByte(L[V]);
          return x.flush(), "data:image/gif;base64," + x;
        };
        return d;
      }();
      l.stringToBytesFuncs["UTF-8"] = function(d) {
        return function(h) {
          for (var f = [], g = 0; g < h.length; g++) {
            var p = h.charCodeAt(g);
            p < 128 ? f.push(p) : p < 2048 ? f.push(192 | p >> 6, 128 | 63 & p) : p < 55296 || p >= 57344 ? f.push(224 | p >> 12, 128 | p >> 6 & 63, 128 | 63 & p) : (g++, p = 65536 + ((1023 & p) << 10 | 1023 & h.charCodeAt(g)), f.push(240 | p >> 18, 128 | p >> 12 & 63, 128 | p >> 6 & 63, 128 | 63 & p));
          }
          return f;
        }(d);
      }, (c = typeof (u = function() {
        return l;
      }) == "function" ? u.apply(a, []) : u) === void 0 || (o.exports = c);
    } }, n = {};
    function s(o) {
      var a = n[o];
      if (a !== void 0) return a.exports;
      var u = n[o] = { exports: {} };
      return t[o](u, u.exports, s), u.exports;
    }
    s.n = (o) => {
      var a = o && o.__esModule ? () => o.default : () => o;
      return s.d(a, { a }), a;
    }, s.d = (o, a) => {
      for (var u in a) s.o(a, u) && !s.o(o, u) && Object.defineProperty(o, u, { enumerable: true, get: a[u] });
    }, s.o = (o, a) => Object.prototype.hasOwnProperty.call(o, a);
    var i = {};
    return (() => {
      s.d(i, { default: () => j });
      const o = (I) => !!I && typeof I == "object" && !Array.isArray(I);
      function a(I, ...y) {
        if (!y.length) return I;
        const m = y.shift();
        return m !== void 0 && o(I) && o(m) ? (I = Object.assign({}, I), Object.keys(m).forEach((N) => {
          const T = I[N], x = m[N];
          Array.isArray(T) && Array.isArray(x) ? I[N] = x : o(T) && o(x) ? I[N] = a(Object.assign({}, T), x) : I[N] = x;
        }), a(I, ...y)) : I;
      }
      function u(I, y) {
        const m = document.createElement("a");
        m.download = y, m.href = I, document.body.appendChild(m), m.click(), document.body.removeChild(m);
      }
      const c = { L: 0.07, M: 0.15, Q: 0.25, H: 0.3 };
      class l {
        constructor({ svg: y, type: m, window: N }) {
          this._svg = y, this._type = m, this._window = N;
        }
        draw(y, m, N, T) {
          let x;
          switch (this._type) {
            case "dots":
              x = this._drawDot;
              break;
            case "classy":
              x = this._drawClassy;
              break;
            case "classy-rounded":
              x = this._drawClassyRounded;
              break;
            case "rounded":
              x = this._drawRounded;
              break;
            case "extra-rounded":
              x = this._drawExtraRounded;
              break;
            default:
              x = this._drawSquare;
          }
          x.call(this, { x: y, y: m, size: N, getNeighbor: T });
        }
        _rotateFigure({ x: y, y: m, size: N, rotation: T = 0, draw: x }) {
          var L;
          const V = y + N / 2, q = m + N / 2;
          x(), (L = this._element) === null || L === void 0 || L.setAttribute("transform", `rotate(${180 * T / Math.PI},${V},${q})`);
        }
        _basicDot(y) {
          const { size: m, x: N, y: T } = y;
          this._rotateFigure(Object.assign(Object.assign({}, y), { draw: () => {
            this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "circle"), this._element.setAttribute("cx", String(N + m / 2)), this._element.setAttribute("cy", String(T + m / 2)), this._element.setAttribute("r", String(m / 2));
          } }));
        }
        _basicSquare(y) {
          const { size: m, x: N, y: T } = y;
          this._rotateFigure(Object.assign(Object.assign({}, y), { draw: () => {
            this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "rect"), this._element.setAttribute("x", String(N)), this._element.setAttribute("y", String(T)), this._element.setAttribute("width", String(m)), this._element.setAttribute("height", String(m));
          } }));
        }
        _basicSideRounded(y) {
          const { size: m, x: N, y: T } = y;
          this._rotateFigure(Object.assign(Object.assign({}, y), { draw: () => {
            this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "path"), this._element.setAttribute("d", `M ${N} ${T}v ${m}h ` + m / 2 + `a ${m / 2} ${m / 2}, 0, 0, 0, 0 ${-m}`);
          } }));
        }
        _basicCornerRounded(y) {
          const { size: m, x: N, y: T } = y;
          this._rotateFigure(Object.assign(Object.assign({}, y), { draw: () => {
            this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "path"), this._element.setAttribute("d", `M ${N} ${T}v ${m}h ${m}v ` + -m / 2 + `a ${m / 2} ${m / 2}, 0, 0, 0, ${-m / 2} ${-m / 2}`);
          } }));
        }
        _basicCornerExtraRounded(y) {
          const { size: m, x: N, y: T } = y;
          this._rotateFigure(Object.assign(Object.assign({}, y), { draw: () => {
            this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "path"), this._element.setAttribute("d", `M ${N} ${T}v ${m}h ${m}a ${m} ${m}, 0, 0, 0, ${-m} ${-m}`);
          } }));
        }
        _basicCornersRounded(y) {
          const { size: m, x: N, y: T } = y;
          this._rotateFigure(Object.assign(Object.assign({}, y), { draw: () => {
            this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "path"), this._element.setAttribute("d", `M ${N} ${T}v ` + m / 2 + `a ${m / 2} ${m / 2}, 0, 0, 0, ${m / 2} ${m / 2}h ` + m / 2 + "v " + -m / 2 + `a ${m / 2} ${m / 2}, 0, 0, 0, ${-m / 2} ${-m / 2}`);
          } }));
        }
        _drawDot({ x: y, y: m, size: N }) {
          this._basicDot({ x: y, y: m, size: N, rotation: 0 });
        }
        _drawSquare({ x: y, y: m, size: N }) {
          this._basicSquare({ x: y, y: m, size: N, rotation: 0 });
        }
        _drawRounded({ x: y, y: m, size: N, getNeighbor: T }) {
          const x = T ? +T(-1, 0) : 0, L = T ? +T(1, 0) : 0, V = T ? +T(0, -1) : 0, q = T ? +T(0, 1) : 0, K = x + L + V + q;
          if (K !== 0) if (K > 2 || x && L || V && q) this._basicSquare({ x: y, y: m, size: N, rotation: 0 });
          else {
            if (K === 2) {
              let Z = 0;
              return x && V ? Z = Math.PI / 2 : V && L ? Z = Math.PI : L && q && (Z = -Math.PI / 2), void this._basicCornerRounded({ x: y, y: m, size: N, rotation: Z });
            }
            if (K === 1) {
              let Z = 0;
              return V ? Z = Math.PI / 2 : L ? Z = Math.PI : q && (Z = -Math.PI / 2), void this._basicSideRounded({ x: y, y: m, size: N, rotation: Z });
            }
          }
          else this._basicDot({ x: y, y: m, size: N, rotation: 0 });
        }
        _drawExtraRounded({ x: y, y: m, size: N, getNeighbor: T }) {
          const x = T ? +T(-1, 0) : 0, L = T ? +T(1, 0) : 0, V = T ? +T(0, -1) : 0, q = T ? +T(0, 1) : 0, K = x + L + V + q;
          if (K !== 0) if (K > 2 || x && L || V && q) this._basicSquare({ x: y, y: m, size: N, rotation: 0 });
          else {
            if (K === 2) {
              let Z = 0;
              return x && V ? Z = Math.PI / 2 : V && L ? Z = Math.PI : L && q && (Z = -Math.PI / 2), void this._basicCornerExtraRounded({ x: y, y: m, size: N, rotation: Z });
            }
            if (K === 1) {
              let Z = 0;
              return V ? Z = Math.PI / 2 : L ? Z = Math.PI : q && (Z = -Math.PI / 2), void this._basicSideRounded({ x: y, y: m, size: N, rotation: Z });
            }
          }
          else this._basicDot({ x: y, y: m, size: N, rotation: 0 });
        }
        _drawClassy({ x: y, y: m, size: N, getNeighbor: T }) {
          const x = T ? +T(-1, 0) : 0, L = T ? +T(1, 0) : 0, V = T ? +T(0, -1) : 0, q = T ? +T(0, 1) : 0;
          x + L + V + q !== 0 ? x || V ? L || q ? this._basicSquare({ x: y, y: m, size: N, rotation: 0 }) : this._basicCornerRounded({ x: y, y: m, size: N, rotation: Math.PI / 2 }) : this._basicCornerRounded({ x: y, y: m, size: N, rotation: -Math.PI / 2 }) : this._basicCornersRounded({ x: y, y: m, size: N, rotation: Math.PI / 2 });
        }
        _drawClassyRounded({ x: y, y: m, size: N, getNeighbor: T }) {
          const x = T ? +T(-1, 0) : 0, L = T ? +T(1, 0) : 0, V = T ? +T(0, -1) : 0, q = T ? +T(0, 1) : 0;
          x + L + V + q !== 0 ? x || V ? L || q ? this._basicSquare({ x: y, y: m, size: N, rotation: 0 }) : this._basicCornerExtraRounded({ x: y, y: m, size: N, rotation: Math.PI / 2 }) : this._basicCornerExtraRounded({ x: y, y: m, size: N, rotation: -Math.PI / 2 }) : this._basicCornersRounded({ x: y, y: m, size: N, rotation: Math.PI / 2 });
        }
      }
      const d = { dot: "dot", square: "square", extraRounded: "extra-rounded" }, h = Object.values(d);
      class f {
        constructor({ svg: y, type: m, window: N }) {
          this._svg = y, this._type = m, this._window = N;
        }
        draw(y, m, N, T) {
          let x;
          switch (this._type) {
            case d.square:
              x = this._drawSquare;
              break;
            case d.extraRounded:
              x = this._drawExtraRounded;
              break;
            default:
              x = this._drawDot;
          }
          x.call(this, { x: y, y: m, size: N, rotation: T });
        }
        _rotateFigure({ x: y, y: m, size: N, rotation: T = 0, draw: x }) {
          var L;
          const V = y + N / 2, q = m + N / 2;
          x(), (L = this._element) === null || L === void 0 || L.setAttribute("transform", `rotate(${180 * T / Math.PI},${V},${q})`);
        }
        _basicDot(y) {
          const { size: m, x: N, y: T } = y, x = m / 7;
          this._rotateFigure(Object.assign(Object.assign({}, y), { draw: () => {
            this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "path"), this._element.setAttribute("clip-rule", "evenodd"), this._element.setAttribute("d", `M ${N + m / 2} ${T}a ${m / 2} ${m / 2} 0 1 0 0.1 0zm 0 ${x}a ${m / 2 - x} ${m / 2 - x} 0 1 1 -0.1 0Z`);
          } }));
        }
        _basicSquare(y) {
          const { size: m, x: N, y: T } = y, x = m / 7;
          this._rotateFigure(Object.assign(Object.assign({}, y), { draw: () => {
            this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "path"), this._element.setAttribute("clip-rule", "evenodd"), this._element.setAttribute("d", `M ${N} ${T}v ${m}h ${m}v ` + -m + `zM ${N + x} ${T + x}h ` + (m - 2 * x) + "v " + (m - 2 * x) + "h " + (2 * x - m) + "z");
          } }));
        }
        _basicExtraRounded(y) {
          const { size: m, x: N, y: T } = y, x = m / 7;
          this._rotateFigure(Object.assign(Object.assign({}, y), { draw: () => {
            this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "path"), this._element.setAttribute("clip-rule", "evenodd"), this._element.setAttribute("d", `M ${N} ${T + 2.5 * x}v ` + 2 * x + `a ${2.5 * x} ${2.5 * x}, 0, 0, 0, ${2.5 * x} ${2.5 * x}h ` + 2 * x + `a ${2.5 * x} ${2.5 * x}, 0, 0, 0, ${2.5 * x} ${2.5 * -x}v ` + -2 * x + `a ${2.5 * x} ${2.5 * x}, 0, 0, 0, ${2.5 * -x} ${2.5 * -x}h ` + -2 * x + `a ${2.5 * x} ${2.5 * x}, 0, 0, 0, ${2.5 * -x} ${2.5 * x}M ${N + 2.5 * x} ${T + x}h ` + 2 * x + `a ${1.5 * x} ${1.5 * x}, 0, 0, 1, ${1.5 * x} ${1.5 * x}v ` + 2 * x + `a ${1.5 * x} ${1.5 * x}, 0, 0, 1, ${1.5 * -x} ${1.5 * x}h ` + -2 * x + `a ${1.5 * x} ${1.5 * x}, 0, 0, 1, ${1.5 * -x} ${1.5 * -x}v ` + -2 * x + `a ${1.5 * x} ${1.5 * x}, 0, 0, 1, ${1.5 * x} ${1.5 * -x}`);
          } }));
        }
        _drawDot({ x: y, y: m, size: N, rotation: T }) {
          this._basicDot({ x: y, y: m, size: N, rotation: T });
        }
        _drawSquare({ x: y, y: m, size: N, rotation: T }) {
          this._basicSquare({ x: y, y: m, size: N, rotation: T });
        }
        _drawExtraRounded({ x: y, y: m, size: N, rotation: T }) {
          this._basicExtraRounded({ x: y, y: m, size: N, rotation: T });
        }
      }
      const g = { dot: "dot", square: "square" }, p = Object.values(g);
      class b {
        constructor({ svg: y, type: m, window: N }) {
          this._svg = y, this._type = m, this._window = N;
        }
        draw(y, m, N, T) {
          let x;
          x = this._type === g.square ? this._drawSquare : this._drawDot, x.call(this, { x: y, y: m, size: N, rotation: T });
        }
        _rotateFigure({ x: y, y: m, size: N, rotation: T = 0, draw: x }) {
          var L;
          const V = y + N / 2, q = m + N / 2;
          x(), (L = this._element) === null || L === void 0 || L.setAttribute("transform", `rotate(${180 * T / Math.PI},${V},${q})`);
        }
        _basicDot(y) {
          const { size: m, x: N, y: T } = y;
          this._rotateFigure(Object.assign(Object.assign({}, y), { draw: () => {
            this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "circle"), this._element.setAttribute("cx", String(N + m / 2)), this._element.setAttribute("cy", String(T + m / 2)), this._element.setAttribute("r", String(m / 2));
          } }));
        }
        _basicSquare(y) {
          const { size: m, x: N, y: T } = y;
          this._rotateFigure(Object.assign(Object.assign({}, y), { draw: () => {
            this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "rect"), this._element.setAttribute("x", String(N)), this._element.setAttribute("y", String(T)), this._element.setAttribute("width", String(m)), this._element.setAttribute("height", String(m));
          } }));
        }
        _drawDot({ x: y, y: m, size: N, rotation: T }) {
          this._basicDot({ x: y, y: m, size: N, rotation: T });
        }
        _drawSquare({ x: y, y: m, size: N, rotation: T }) {
          this._basicSquare({ x: y, y: m, size: N, rotation: T });
        }
      }
      const _ = "circle", D = [[1, 1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1, 1]], v = [[0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0]];
      class E {
        constructor(y, m) {
          this._roundSize = (N) => this._options.dotsOptions.roundSize ? Math.floor(N) : N, this._window = m, this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "svg"), this._element.setAttribute("width", String(y.width)), this._element.setAttribute("height", String(y.height)), this._element.setAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink"), y.dotsOptions.roundSize || this._element.setAttribute("shape-rendering", "crispEdges"), this._element.setAttribute("viewBox", `0 0 ${y.width} ${y.height}`), this._defs = this._window.document.createElementNS("http://www.w3.org/2000/svg", "defs"), this._element.appendChild(this._defs), this._imageUri = y.image, this._instanceId = E.instanceCount++, this._options = y;
        }
        get width() {
          return this._options.width;
        }
        get height() {
          return this._options.height;
        }
        getElement() {
          return this._element;
        }
        async drawQR(y) {
          const m = y.getModuleCount(), N = Math.min(this._options.width, this._options.height) - 2 * this._options.margin, T = this._options.shape === _ ? N / Math.sqrt(2) : N, x = this._roundSize(T / m);
          let L = { hideXDots: 0, hideYDots: 0, width: 0, height: 0 };
          if (this._qr = y, this._options.image) {
            if (await this.loadImage(), !this._image) return;
            const { imageOptions: V, qrOptions: q } = this._options, K = V.imageSize * c[q.errorCorrectionLevel], Z = Math.floor(K * m * m);
            L = function({ originalHeight: re, originalWidth: ne, maxHiddenDots: se, maxHiddenAxisDots: ue, dotSize: he }) {
              const Q = { x: 0, y: 0 }, X = { x: 0, y: 0 };
              if (re <= 0 || ne <= 0 || se <= 0 || he <= 0) return { height: 0, width: 0, hideYDots: 0, hideXDots: 0 };
              const Y = re / ne;
              return Q.x = Math.floor(Math.sqrt(se / Y)), Q.x <= 0 && (Q.x = 1), ue && ue < Q.x && (Q.x = ue), Q.x % 2 == 0 && Q.x--, X.x = Q.x * he, Q.y = 1 + 2 * Math.ceil((Q.x * Y - 1) / 2), X.y = Math.round(X.x * Y), (Q.y * Q.x > se || ue && ue < Q.y) && (ue && ue < Q.y ? (Q.y = ue, Q.y % 2 == 0 && Q.x--) : Q.y -= 2, X.y = Q.y * he, Q.x = 1 + 2 * Math.ceil((Q.y / Y - 1) / 2), X.x = Math.round(X.y / Y)), { height: X.y, width: X.x, hideYDots: Q.y, hideXDots: Q.x };
            }({ originalWidth: this._image.width, originalHeight: this._image.height, maxHiddenDots: Z, maxHiddenAxisDots: m - 14, dotSize: x });
          }
          this.drawBackground(), this.drawDots((V, q) => {
            var K, Z, re, ne, se, ue;
            return !(this._options.imageOptions.hideBackgroundDots && V >= (m - L.hideYDots) / 2 && V < (m + L.hideYDots) / 2 && q >= (m - L.hideXDots) / 2 && q < (m + L.hideXDots) / 2 || !((K = D[V]) === null || K === void 0) && K[q] || !((Z = D[V - m + 7]) === null || Z === void 0) && Z[q] || !((re = D[V]) === null || re === void 0) && re[q - m + 7] || !((ne = v[V]) === null || ne === void 0) && ne[q] || !((se = v[V - m + 7]) === null || se === void 0) && se[q] || !((ue = v[V]) === null || ue === void 0) && ue[q - m + 7]);
          }), this.drawCorners(), this._options.image && await this.drawImage({ width: L.width, height: L.height, count: m, dotSize: x });
        }
        drawBackground() {
          var y, m, N;
          const T = this._element, x = this._options;
          if (T) {
            const L = (y = x.backgroundOptions) === null || y === void 0 ? void 0 : y.gradient, V = (m = x.backgroundOptions) === null || m === void 0 ? void 0 : m.color;
            let q = x.height, K = x.width;
            if (L || V) {
              const Z = this._window.document.createElementNS("http://www.w3.org/2000/svg", "rect");
              this._backgroundClipPath = this._window.document.createElementNS("http://www.w3.org/2000/svg", "clipPath"), this._backgroundClipPath.setAttribute("id", `clip-path-background-color-${this._instanceId}`), this._defs.appendChild(this._backgroundClipPath), !((N = x.backgroundOptions) === null || N === void 0) && N.round && (q = K = Math.min(x.width, x.height), Z.setAttribute("rx", String(q / 2 * x.backgroundOptions.round))), Z.setAttribute("x", String(this._roundSize((x.width - K) / 2))), Z.setAttribute("y", String(this._roundSize((x.height - q) / 2))), Z.setAttribute("width", String(K)), Z.setAttribute("height", String(q)), this._backgroundClipPath.appendChild(Z), this._createColor({ options: L, color: V, additionalRotation: 0, x: 0, y: 0, height: x.height, width: x.width, name: `background-color-${this._instanceId}` });
            }
          }
        }
        drawDots(y) {
          var m, N;
          if (!this._qr) throw "QR code is not defined";
          const T = this._options, x = this._qr.getModuleCount();
          if (x > T.width || x > T.height) throw "The canvas is too small.";
          const L = Math.min(T.width, T.height) - 2 * T.margin, V = T.shape === _ ? L / Math.sqrt(2) : L, q = this._roundSize(V / x), K = this._roundSize((T.width - x * q) / 2), Z = this._roundSize((T.height - x * q) / 2), re = new l({ svg: this._element, type: T.dotsOptions.type, window: this._window });
          this._dotsClipPath = this._window.document.createElementNS("http://www.w3.org/2000/svg", "clipPath"), this._dotsClipPath.setAttribute("id", `clip-path-dot-color-${this._instanceId}`), this._defs.appendChild(this._dotsClipPath), this._createColor({ options: (m = T.dotsOptions) === null || m === void 0 ? void 0 : m.gradient, color: T.dotsOptions.color, additionalRotation: 0, x: 0, y: 0, height: T.height, width: T.width, name: `dot-color-${this._instanceId}` });
          for (let ne = 0; ne < x; ne++) for (let se = 0; se < x; se++) y && !y(ne, se) || !((N = this._qr) === null || N === void 0) && N.isDark(ne, se) && (re.draw(K + se * q, Z + ne * q, q, (ue, he) => !(se + ue < 0 || ne + he < 0 || se + ue >= x || ne + he >= x) && !(y && !y(ne + he, se + ue)) && !!this._qr && this._qr.isDark(ne + he, se + ue)), re._element && this._dotsClipPath && this._dotsClipPath.appendChild(re._element));
          if (T.shape === _) {
            const ne = this._roundSize((L / q - x) / 2), se = x + 2 * ne, ue = K - ne * q, he = Z - ne * q, Q = [], X = this._roundSize(se / 2);
            for (let Y = 0; Y < se; Y++) {
              Q[Y] = [];
              for (let J = 0; J < se; J++) Y >= ne - 1 && Y <= se - ne && J >= ne - 1 && J <= se - ne || Math.sqrt((Y - X) * (Y - X) + (J - X) * (J - X)) > X ? Q[Y][J] = 0 : Q[Y][J] = this._qr.isDark(J - 2 * ne < 0 ? J : J >= x ? J - 2 * ne : J - ne, Y - 2 * ne < 0 ? Y : Y >= x ? Y - 2 * ne : Y - ne) ? 1 : 0;
            }
            for (let Y = 0; Y < se; Y++) for (let J = 0; J < se; J++) Q[Y][J] && (re.draw(ue + J * q, he + Y * q, q, (ie, fe) => {
              var ye;
              return !!(!((ye = Q[Y + fe]) === null || ye === void 0) && ye[J + ie]);
            }), re._element && this._dotsClipPath && this._dotsClipPath.appendChild(re._element));
          }
        }
        drawCorners() {
          if (!this._qr) throw "QR code is not defined";
          const y = this._element, m = this._options;
          if (!y) throw "Element code is not defined";
          const N = this._qr.getModuleCount(), T = Math.min(m.width, m.height) - 2 * m.margin, x = m.shape === _ ? T / Math.sqrt(2) : T, L = this._roundSize(x / N), V = 7 * L, q = 3 * L, K = this._roundSize((m.width - N * L) / 2), Z = this._roundSize((m.height - N * L) / 2);
          [[0, 0, 0], [1, 0, Math.PI / 2], [0, 1, -Math.PI / 2]].forEach(([re, ne, se]) => {
            var ue, he, Q, X, Y, J, ie, fe, ye, we, Ie, Ee, Me, Ve;
            const Fe = K + re * L * (N - 7), xe = Z + ne * L * (N - 7);
            let _e = this._dotsClipPath, O = this._dotsClipPath;
            if ((!((ue = m.cornersSquareOptions) === null || ue === void 0) && ue.gradient || !((he = m.cornersSquareOptions) === null || he === void 0) && he.color) && (_e = this._window.document.createElementNS("http://www.w3.org/2000/svg", "clipPath"), _e.setAttribute("id", `clip-path-corners-square-color-${re}-${ne}-${this._instanceId}`), this._defs.appendChild(_e), this._cornersSquareClipPath = this._cornersDotClipPath = O = _e, this._createColor({ options: (Q = m.cornersSquareOptions) === null || Q === void 0 ? void 0 : Q.gradient, color: (X = m.cornersSquareOptions) === null || X === void 0 ? void 0 : X.color, additionalRotation: se, x: Fe, y: xe, height: V, width: V, name: `corners-square-color-${re}-${ne}-${this._instanceId}` })), ((Y = m.cornersSquareOptions) === null || Y === void 0 ? void 0 : Y.type) && h.includes(m.cornersSquareOptions.type)) {
              const w = new f({ svg: this._element, type: m.cornersSquareOptions.type, window: this._window });
              w.draw(Fe, xe, V, se), w._element && _e && _e.appendChild(w._element);
            } else {
              const w = new l({ svg: this._element, type: ((J = m.cornersSquareOptions) === null || J === void 0 ? void 0 : J.type) || m.dotsOptions.type, window: this._window });
              for (let M = 0; M < D.length; M++) for (let C = 0; C < D[M].length; C++) !((ie = D[M]) === null || ie === void 0) && ie[C] && (w.draw(Fe + C * L, xe + M * L, L, (F, W) => {
                var te;
                return !!(!((te = D[M + W]) === null || te === void 0) && te[C + F]);
              }), w._element && _e && _e.appendChild(w._element));
            }
            if ((!((fe = m.cornersDotOptions) === null || fe === void 0) && fe.gradient || !((ye = m.cornersDotOptions) === null || ye === void 0) && ye.color) && (O = this._window.document.createElementNS("http://www.w3.org/2000/svg", "clipPath"), O.setAttribute("id", `clip-path-corners-dot-color-${re}-${ne}-${this._instanceId}`), this._defs.appendChild(O), this._cornersDotClipPath = O, this._createColor({ options: (we = m.cornersDotOptions) === null || we === void 0 ? void 0 : we.gradient, color: (Ie = m.cornersDotOptions) === null || Ie === void 0 ? void 0 : Ie.color, additionalRotation: se, x: Fe + 2 * L, y: xe + 2 * L, height: q, width: q, name: `corners-dot-color-${re}-${ne}-${this._instanceId}` })), ((Ee = m.cornersDotOptions) === null || Ee === void 0 ? void 0 : Ee.type) && p.includes(m.cornersDotOptions.type)) {
              const w = new b({ svg: this._element, type: m.cornersDotOptions.type, window: this._window });
              w.draw(Fe + 2 * L, xe + 2 * L, q, se), w._element && O && O.appendChild(w._element);
            } else {
              const w = new l({ svg: this._element, type: ((Me = m.cornersDotOptions) === null || Me === void 0 ? void 0 : Me.type) || m.dotsOptions.type, window: this._window });
              for (let M = 0; M < v.length; M++) for (let C = 0; C < v[M].length; C++) !((Ve = v[M]) === null || Ve === void 0) && Ve[C] && (w.draw(Fe + C * L, xe + M * L, L, (F, W) => {
                var te;
                return !!(!((te = v[M + W]) === null || te === void 0) && te[C + F]);
              }), w._element && O && O.appendChild(w._element));
            }
          });
        }
        loadImage() {
          return new Promise((y, m) => {
            var N;
            const T = this._options;
            if (!T.image) return m("Image is not defined");
            if (!((N = T.nodeCanvas) === null || N === void 0) && N.loadImage) T.nodeCanvas.loadImage(T.image).then((x) => {
              var L, V;
              if (this._image = x, this._options.imageOptions.saveAsBlob) {
                const q = (L = T.nodeCanvas) === null || L === void 0 ? void 0 : L.createCanvas(this._image.width, this._image.height);
                (V = q == null ? void 0 : q.getContext("2d")) === null || V === void 0 || V.drawImage(x, 0, 0), this._imageUri = q == null ? void 0 : q.toDataURL();
              }
              y();
            }).catch(m);
            else {
              const x = new this._window.Image();
              typeof T.imageOptions.crossOrigin == "string" && (x.crossOrigin = T.imageOptions.crossOrigin), this._image = x, x.onload = async () => {
                this._options.imageOptions.saveAsBlob && (this._imageUri = await async function(L, V) {
                  return new Promise((q) => {
                    const K = new V.XMLHttpRequest();
                    K.onload = function() {
                      const Z = new V.FileReader();
                      Z.onloadend = function() {
                        q(Z.result);
                      }, Z.readAsDataURL(K.response);
                    }, K.open("GET", L), K.responseType = "blob", K.send();
                  });
                }(T.image || "", this._window)), y();
              }, x.src = T.image;
            }
          });
        }
        async drawImage({ width: y, height: m, count: N, dotSize: T }) {
          const x = this._options, L = this._roundSize((x.width - N * T) / 2), V = this._roundSize((x.height - N * T) / 2), q = L + this._roundSize(x.imageOptions.margin + (N * T - y) / 2), K = V + this._roundSize(x.imageOptions.margin + (N * T - m) / 2), Z = y - 2 * x.imageOptions.margin, re = m - 2 * x.imageOptions.margin, ne = this._window.document.createElementNS("http://www.w3.org/2000/svg", "image");
          ne.setAttribute("href", this._imageUri || ""), ne.setAttribute("xlink:href", this._imageUri || ""), ne.setAttribute("x", String(q)), ne.setAttribute("y", String(K)), ne.setAttribute("width", `${Z}px`), ne.setAttribute("height", `${re}px`), this._element.appendChild(ne);
        }
        _createColor({ options: y, color: m, additionalRotation: N, x: T, y: x, height: L, width: V, name: q }) {
          const K = V > L ? V : L, Z = this._window.document.createElementNS("http://www.w3.org/2000/svg", "rect");
          if (Z.setAttribute("x", String(T)), Z.setAttribute("y", String(x)), Z.setAttribute("height", String(L)), Z.setAttribute("width", String(V)), Z.setAttribute("clip-path", `url('#clip-path-${q}')`), y) {
            let re;
            if (y.type === "radial") re = this._window.document.createElementNS("http://www.w3.org/2000/svg", "radialGradient"), re.setAttribute("id", q), re.setAttribute("gradientUnits", "userSpaceOnUse"), re.setAttribute("fx", String(T + V / 2)), re.setAttribute("fy", String(x + L / 2)), re.setAttribute("cx", String(T + V / 2)), re.setAttribute("cy", String(x + L / 2)), re.setAttribute("r", String(K / 2));
            else {
              const ne = ((y.rotation || 0) + N) % (2 * Math.PI), se = (ne + 2 * Math.PI) % (2 * Math.PI);
              let ue = T + V / 2, he = x + L / 2, Q = T + V / 2, X = x + L / 2;
              se >= 0 && se <= 0.25 * Math.PI || se > 1.75 * Math.PI && se <= 2 * Math.PI ? (ue -= V / 2, he -= L / 2 * Math.tan(ne), Q += V / 2, X += L / 2 * Math.tan(ne)) : se > 0.25 * Math.PI && se <= 0.75 * Math.PI ? (he -= L / 2, ue -= V / 2 / Math.tan(ne), X += L / 2, Q += V / 2 / Math.tan(ne)) : se > 0.75 * Math.PI && se <= 1.25 * Math.PI ? (ue += V / 2, he += L / 2 * Math.tan(ne), Q -= V / 2, X -= L / 2 * Math.tan(ne)) : se > 1.25 * Math.PI && se <= 1.75 * Math.PI && (he += L / 2, ue += V / 2 / Math.tan(ne), X -= L / 2, Q -= V / 2 / Math.tan(ne)), re = this._window.document.createElementNS("http://www.w3.org/2000/svg", "linearGradient"), re.setAttribute("id", q), re.setAttribute("gradientUnits", "userSpaceOnUse"), re.setAttribute("x1", String(Math.round(ue))), re.setAttribute("y1", String(Math.round(he))), re.setAttribute("x2", String(Math.round(Q))), re.setAttribute("y2", String(Math.round(X)));
            }
            y.colorStops.forEach(({ offset: ne, color: se }) => {
              const ue = this._window.document.createElementNS("http://www.w3.org/2000/svg", "stop");
              ue.setAttribute("offset", 100 * ne + "%"), ue.setAttribute("stop-color", se), re.appendChild(ue);
            }), Z.setAttribute("fill", `url('#${q}')`), this._defs.appendChild(re);
          } else m && Z.setAttribute("fill", m);
          this._element.appendChild(Z);
        }
      }
      E.instanceCount = 0;
      const A = E, k = "canvas", U = {};
      for (let I = 0; I <= 40; I++) U[I] = I;
      const P = { type: k, shape: "square", width: 300, height: 300, data: "", margin: 0, qrOptions: { typeNumber: U[0], mode: void 0, errorCorrectionLevel: "Q" }, imageOptions: { saveAsBlob: true, hideBackgroundDots: true, imageSize: 0.4, crossOrigin: void 0, margin: 0 }, dotsOptions: { type: "square", color: "#000", roundSize: true }, backgroundOptions: { round: 0, color: "#fff" } };
      function $(I) {
        const y = Object.assign({}, I);
        if (!y.colorStops || !y.colorStops.length) throw "Field 'colorStops' is required in gradient";
        return y.rotation ? y.rotation = Number(y.rotation) : y.rotation = 0, y.colorStops = y.colorStops.map((m) => Object.assign(Object.assign({}, m), { offset: Number(m.offset) })), y;
      }
      function ee(I) {
        const y = Object.assign({}, I);
        return y.width = Number(y.width), y.height = Number(y.height), y.margin = Number(y.margin), y.imageOptions = Object.assign(Object.assign({}, y.imageOptions), { hideBackgroundDots: !!y.imageOptions.hideBackgroundDots, imageSize: Number(y.imageOptions.imageSize), margin: Number(y.imageOptions.margin) }), y.margin > Math.min(y.width, y.height) && (y.margin = Math.min(y.width, y.height)), y.dotsOptions = Object.assign({}, y.dotsOptions), y.dotsOptions.gradient && (y.dotsOptions.gradient = $(y.dotsOptions.gradient)), y.cornersSquareOptions && (y.cornersSquareOptions = Object.assign({}, y.cornersSquareOptions), y.cornersSquareOptions.gradient && (y.cornersSquareOptions.gradient = $(y.cornersSquareOptions.gradient))), y.cornersDotOptions && (y.cornersDotOptions = Object.assign({}, y.cornersDotOptions), y.cornersDotOptions.gradient && (y.cornersDotOptions.gradient = $(y.cornersDotOptions.gradient))), y.backgroundOptions && (y.backgroundOptions = Object.assign({}, y.backgroundOptions), y.backgroundOptions.gradient && (y.backgroundOptions.gradient = $(y.backgroundOptions.gradient))), y;
      }
      var G = s(873), H = s.n(G);
      function R(I) {
        if (!I) throw new Error("Extension must be defined");
        I[0] === "." && (I = I.substring(1));
        const y = { bmp: "image/bmp", gif: "image/gif", ico: "image/vnd.microsoft.icon", jpeg: "image/jpeg", jpg: "image/jpeg", png: "image/png", svg: "image/svg+xml", tif: "image/tiff", tiff: "image/tiff", webp: "image/webp", pdf: "application/pdf" }[I.toLowerCase()];
        if (!y) throw new Error(`Extension "${I}" is not supported`);
        return y;
      }
      class z {
        constructor(y) {
          y != null && y.jsdom ? this._window = new y.jsdom("", { resources: "usable" }).window : this._window = window, this._options = y ? ee(a(P, y)) : P, this.update();
        }
        static _clearContainer(y) {
          y && (y.innerHTML = "");
        }
        _setupSvg() {
          if (!this._qr) return;
          const y = new A(this._options, this._window);
          this._svg = y.getElement(), this._svgDrawingPromise = y.drawQR(this._qr).then(() => {
            var m;
            this._svg && ((m = this._extension) === null || m === void 0 || m.call(this, y.getElement(), this._options));
          });
        }
        _setupCanvas() {
          var y, m;
          this._qr && (!((y = this._options.nodeCanvas) === null || y === void 0) && y.createCanvas ? (this._nodeCanvas = this._options.nodeCanvas.createCanvas(this._options.width, this._options.height), this._nodeCanvas.width = this._options.width, this._nodeCanvas.height = this._options.height) : (this._domCanvas = document.createElement("canvas"), this._domCanvas.width = this._options.width, this._domCanvas.height = this._options.height), this._setupSvg(), this._canvasDrawingPromise = (m = this._svgDrawingPromise) === null || m === void 0 ? void 0 : m.then(() => {
            var N;
            if (!this._svg) return;
            const T = this._svg, x = new this._window.XMLSerializer().serializeToString(T), L = btoa(x), V = `data:${R("svg")};base64,${L}`;
            if (!((N = this._options.nodeCanvas) === null || N === void 0) && N.loadImage) return this._options.nodeCanvas.loadImage(V).then((q) => {
              var K, Z;
              q.width = this._options.width, q.height = this._options.height, (Z = (K = this._nodeCanvas) === null || K === void 0 ? void 0 : K.getContext("2d")) === null || Z === void 0 || Z.drawImage(q, 0, 0);
            });
            {
              const q = new this._window.Image();
              return new Promise((K) => {
                q.onload = () => {
                  var Z, re;
                  (re = (Z = this._domCanvas) === null || Z === void 0 ? void 0 : Z.getContext("2d")) === null || re === void 0 || re.drawImage(q, 0, 0), K();
                }, q.src = V;
              });
            }
          }));
        }
        async _getElement(y = "png") {
          if (!this._qr) throw "QR code is empty";
          return y.toLowerCase() === "svg" ? (this._svg && this._svgDrawingPromise || this._setupSvg(), await this._svgDrawingPromise, this._svg) : ((this._domCanvas || this._nodeCanvas) && this._canvasDrawingPromise || this._setupCanvas(), await this._canvasDrawingPromise, this._domCanvas || this._nodeCanvas);
        }
        update(y) {
          z._clearContainer(this._container), this._options = y ? ee(a(this._options, y)) : this._options, this._options.data && (this._qr = H()(this._options.qrOptions.typeNumber, this._options.qrOptions.errorCorrectionLevel), this._qr.addData(this._options.data, this._options.qrOptions.mode || function(m) {
            switch (true) {
              case /^[0-9]*$/.test(m):
                return "Numeric";
              case /^[0-9A-Z $%*+\-./:]*$/.test(m):
                return "Alphanumeric";
              default:
                return "Byte";
            }
          }(this._options.data)), this._qr.make(), this._options.type === k ? this._setupCanvas() : this._setupSvg(), this.append(this._container));
        }
        append(y) {
          if (y) {
            if (typeof y.appendChild != "function") throw "Container should be a single DOM node";
            this._options.type === k ? this._domCanvas && y.appendChild(this._domCanvas) : this._svg && y.appendChild(this._svg), this._container = y;
          }
        }
        applyExtension(y) {
          if (!y) throw "Extension function should be defined.";
          this._extension = y, this.update();
        }
        deleteExtension() {
          this._extension = void 0, this.update();
        }
        async getRawData(y = "png") {
          if (!this._qr) throw "QR code is empty";
          const m = await this._getElement(y), N = R(y);
          if (!m) return null;
          if (y.toLowerCase() === "svg") {
            const T = `<?xml version="1.0" standalone="no"?>\r
${new this._window.XMLSerializer().serializeToString(m)}`;
            return typeof Blob > "u" || this._options.jsdom ? Buffer.from(T) : new Blob([T], { type: N });
          }
          return new Promise((T) => {
            const x = m;
            if ("toBuffer" in x) if (N === "image/png") T(x.toBuffer(N));
            else if (N === "image/jpeg") T(x.toBuffer(N));
            else {
              if (N !== "application/pdf") throw Error("Unsupported extension");
              T(x.toBuffer(N));
            }
            else "toBlob" in x && x.toBlob(T, N, 1);
          });
        }
        async download(y) {
          if (!this._qr) throw "QR code is empty";
          if (typeof Blob > "u") throw "Cannot download in Node.js, call getRawData instead.";
          let m = "png", N = "qr";
          typeof y == "string" ? (m = y, console.warn("Extension is deprecated as argument for 'download' method, please pass object { name: '...', extension: '...' } as argument")) : typeof y == "object" && y !== null && (y.name && (N = y.name), y.extension && (m = y.extension));
          const T = await this._getElement(m);
          if (T) if (m.toLowerCase() === "svg") {
            let x = new XMLSerializer().serializeToString(T);
            x = `<?xml version="1.0" standalone="no"?>\r
` + x, u(`data:${R(m)};charset=utf-8,${encodeURIComponent(x)}`, `${N}.svg`);
          } else u(T.toDataURL(R(m)), `${N}.${m}`);
        }
      }
      const j = z;
    })(), i.default;
  })());
})(pp);
var Bw = pp.exports;
var Kl = Cs(Bw);
var Re = {
  QR_CODE: 260,
  LOADING_LOGO: 80,
  MODAL_WIDTH: 343,
  MODAL_BORDER_RADIUS: 20,
  QR_CARD_PADDING: 28,
  BUTTON_PADDING_VERTICAL: 16,
  BUTTON_PADDING_HORIZONTAL: 20,
  BUTTON_BORDER_RADIUS: 12,
  ICON_SMALL: 24,
  ICON_MEDIUM: 28,
  ICON_LARGE: 80,
  CLOSE_BUTTON_SIZE: 34,
  HEADER_PADDING: 18
};
var Cn = {
  QR_RENDER_DELAY: 100,
  COPY_FEEDBACK_DURATION: 2e3,
  ANIMATION_DURATION: 200,
  SAFARI_CONNECT_DELAY: 0,
  NON_SAFARI_CONNECT_DELAY: 100
};
var Gs = {
  OVERLAY: 9999,
  LOADING_BORDER_AFTER: 1,
  LOADING_LOGO: 2
};
var vz = {
  BACKGROUND_COLOR: "#000637",
  TEXT_COLOR: "#F5F4E7",
  PRIMARY_COLOR: "#0ea5e9",
  FONT_FAMILY: "'Karla', sans-serif"
};
var lt = {
  SIZE: 260,
  MARGIN: 0,
  IMAGE_MARGIN: 6,
  IMAGE_SIZE: 0.25,
  DOT_COLOR: "#000637",
  ERROR_CORRECTION_LEVEL: "Q",
  DOT_TYPE: "rounded",
  BACKGROUND_COLOR: "transparent"
};
var Fr = {
  THRESHOLD: 0.5,
  GAMMA_CORRECTION_THRESHOLD: 0.03928,
  GAMMA_CORRECTION_DIVISOR: 12.92,
  GAMMA_CORRECTION_OFFSET: 0.055,
  GAMMA_CORRECTION_POWER: 2.4,
  GAMMA_CORRECTION_BASE: 1.055,
  RED_WEIGHT: 0.2126,
  GREEN_WEIGHT: 0.7152,
  BLUE_WEIGHT: 0.0722
};
var Hn = {
  HOVER_BRIGHTNESS: 0.15,
  MAX_COLOR_VALUE: 255
};
var gp = {
  SAFARI: /^((?!chrome|android).)*safari/i,
  MOBILE: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i
};
var Xl = {
  USER_REJECTED: 4001,
  POPUP_CLOSED: -32002
};
var Mz = {
  QR_URL_PATTERN: "xumm.app/sign",
  QR_IMAGE_EXTENSION: ".png"
};
var rr = {
  LIGHT: 300,
  REGULAR: 400,
  MEDIUM: 500,
  SEMIBOLD: 600
};
function Rw(r) {
  const e = r.replace("#", ""), t = parseInt(e.substring(0, 2), 16) / Hn.MAX_COLOR_VALUE, n = parseInt(e.substring(2, 4), 16) / Hn.MAX_COLOR_VALUE, s = parseInt(e.substring(4, 6), 16) / Hn.MAX_COLOR_VALUE, [i, o, a] = [t, n, s].map((u) => u <= Fr.GAMMA_CORRECTION_THRESHOLD ? u / Fr.GAMMA_CORRECTION_DIVISOR : Math.pow(
    (u + Fr.GAMMA_CORRECTION_OFFSET) / Fr.GAMMA_CORRECTION_BASE,
    Fr.GAMMA_CORRECTION_POWER
  ));
  return Fr.RED_WEIGHT * i + Fr.GREEN_WEIGHT * o + Fr.BLUE_WEIGHT * a;
}
function Ez(r) {
  return Rw(r) < Fr.THRESHOLD ? "#ffffff" : "#000000";
}
function Zl(r, e) {
  const t = r.replace("#", ""), n = parseInt(t, 16), s = Math.round(Hn.MAX_COLOR_VALUE * e);
  let i = (n >> 16) + s, o = (n >> 8 & 255) + s, a = (n & 255) + s;
  return i = Math.max(0, Math.min(Hn.MAX_COLOR_VALUE, i)), o = Math.max(0, Math.min(Hn.MAX_COLOR_VALUE, o)), a = Math.max(0, Math.min(Hn.MAX_COLOR_VALUE, a)), `#${(i << 16 | o << 8 | a).toString(16).padStart(6, "0")}`;
}
function $w() {
  return gp.SAFARI.test(navigator.userAgent);
}
function Fw() {
  return gp.MOBILE.test(navigator.userAgent);
}
function Qw(r) {
  return r.includes("xumm.app/sign") && r.includes(".png");
}
function Nz(r, e) {
  return r.length <= e ? r : r.substring(0, e) + "...";
}
function qw(r) {
  return new Promise((e) => setTimeout(e, r));
}
var Ce = ra("[WalletConnector]");
var Jl = null;
if (typeof window < "u" && typeof HTMLElement < "u") {
  class r extends HTMLElement {
    constructor() {
      super(), this.walletManager = null, this.isOpen = false, this.isFirstOpen = true, this.primaryWalletId = null, this.viewState = "list", this.qrCodeData = null, this.loadingData = null, this.errorData = null, this.previousModalHeight = 0, this.preGeneratedQRCode = null, this.preGeneratedURI = null, this.specifiedWalletIds = [], this.availableWallets = [], this.walletAvailabilityChecked = false, this.accountModalOpen = false, this.accountBalance = null, this.shadow = this.attachShadow({ mode: "open" });
    }
    // Cached account balance
    // Observed attributes
    static get observedAttributes() {
      return ["primary-wallet", "wallets"];
    }
    connectedCallback() {
      this.render(), requestAnimationFrame(() => this.updateDerivedColors()), new MutationObserver(() => {
        this.updateDerivedColors();
      }).observe(this, {
        attributes: true,
        attributeFilter: ["style"]
      });
    }
    /**
     * Update derived colors (like hover states) based on color changes
     */
    updateDerivedColors() {
      const t = window.getComputedStyle(this), n = t.getPropertyValue("--xc-primary-color").trim() || "#0EA5E9", s = t.getPropertyValue("--xc-background-color").trim() || "#000637", i = Zl(n, 0.15), o = Zl(s, 0.15);
      this.style.setProperty("--xc-primary-button-hover-background", i), this.style.setProperty("--xc-connect-button-hover-background", o), this.style.setProperty("--xc-account-address-button-hover-color", i);
    }
    attributeChangedCallback(t, n, s) {
      this.shadow.children.length > 0 && this.render();
    }
    /**
     * Set the WalletManager instance
     */
    setWalletManager(t) {
      this.walletManager = t, this.walletManager.on("connect", () => {
        this.close(), this.render();
      }), this.walletManager.on("disconnect", () => {
        this.render();
      }), this.walletManager.on("accountChanged", () => {
        this.render();
      }), this.render();
    }
    /**
     * Parse wallet IDs from the 'wallets' attribute
     */
    parseWalletAttribute() {
      var n;
      const t = this.getAttribute("wallets") || "";
      return t ? t.split(",").map((s) => s.trim()).filter((s) => s.length > 0) : ((n = this.walletManager) == null ? void 0 : n.wallets.map((s) => s.id)) || [];
    }
    /**
     * Check which wallets are available
     * Filters wallets based on 'wallets' attribute and checks isAvailable() on each
     */
    async checkWalletAvailability() {
      if (!this.walletManager || !this.walletManager.wallets.length) {
        Ce.warn("No wallet manager or wallets registered"), this.availableWallets = [];
        return;
      }
      try {
        this.specifiedWalletIds = this.parseWalletAttribute(), Ce.debug("Checking availability for wallets:", this.specifiedWalletIds);
        const t = this.walletManager.wallets.filter(
          (s) => this.specifiedWalletIds.includes(s.id)
        ), n = await Promise.all(
          t.map(async (s) => {
            try {
              const i = await s.isAvailable();
              return Ce.debug(`Wallet ${s.id} availability: ${i}`), { wallet: s, available: i };
            } catch (i) {
              return Ce.warn(`Error checking availability for ${s.id}:`, i), { wallet: s, available: false };
            }
          })
        );
        this.availableWallets = this.specifiedWalletIds.map((s) => {
          var i;
          return (i = n.find((o) => o.wallet.id === s)) == null ? void 0 : i.wallet;
        }).filter(
          (s) => {
            var i;
            return (s !== void 0 && ((i = n.find((o) => o.wallet.id === s.id)) == null ? void 0 : i.available)) ?? false;
          }
        ), Ce.debug(
          "Available wallets:",
          this.availableWallets.map((s) => s.id)
        );
      } catch (t) {
        Ce.error("Error checking wallet availability:", t), this.availableWallets = [];
      }
    }
    /**
     * Open the modal
     */
    async open() {
      this.isOpen = true, this.isFirstOpen = true, document.body.style.overflow = "hidden", this.walletAvailabilityChecked || (await this.checkWalletAvailability(), this.walletAvailabilityChecked = true), this.render(), this.dispatchEvent(new CustomEvent("open")), this.preInitializeWalletConnect();
    }
    /**
     * Close the modal
     */
    close() {
      this.isOpen = false, document.body.style.overflow = "", this.viewState = "list", this.qrCodeData = null, this.loadingData = null, this.errorData = null, this.render(), this.dispatchEvent(new CustomEvent("close"));
    }
    /**
     * Toggle the modal
     */
    toggle() {
      this.isOpen ? this.close() : this.open();
    }
    /**
     * Open the account details modal
     */
    openAccountModal() {
      this.accountModalOpen = true, this.render();
    }
    /**
     * Close the account details modal
     */
    closeAccountModal() {
      this.accountModalOpen = false, this.render();
    }
    /**
     * Disconnect wallet from the account modal
     */
    async disconnectFromAccountModal() {
      var t;
      try {
        await ((t = this.walletManager) == null ? void 0 : t.disconnect()), this.closeAccountModal(), this.render();
      } catch (n) {
        Ce.error("Failed to disconnect:", n);
      }
    }
    /**
     * Set the account balance to display in the account modal
     */
    setAccountBalance(t) {
      this.accountBalance = t, this.render();
    }
    /**
     * Get the current account balance
     */
    getAccountBalance() {
      return this.accountBalance;
    }
    /**
     * Pre-initialize WalletConnect when modal opens to reduce loading time
     * Based on ConnectKit's eager initialization pattern
     */
    async preInitializeWalletConnect() {
      var n, s;
      if (!this.walletManager) return;
      const t = this.walletManager.wallets.find((i) => i.id === "walletconnect");
      if (t && typeof t.preInitialize == "function")
        try {
          Ce.debug("Pre-initializing WalletConnect...");
          const i = (n = t.options) == null ? void 0 : n.projectId, o = (s = this.walletManager.options) == null ? void 0 : s.network;
          t.options || (t.options = {}), t.options.onQRCode = (a) => {
            Ce.debug("Pre-generating QR code..."), this.preGenerateQRCode(a);
          }, await t.preInitialize(i, o);
        } catch (i) {
          Ce.warn("Failed to pre-initialize WalletConnect:", i);
        }
    }
    /**
     * Pre-generate QR code to have it ready when user clicks WalletConnect
     */
    async preGenerateQRCode(t) {
      var n;
      try {
        this.preGeneratedURI = t;
        const s = (n = this.walletManager) == null ? void 0 : n.wallets.find((o) => o.id === "walletconnect"), i = new Kl({
          width: lt.SIZE,
          height: lt.SIZE,
          type: "svg",
          data: t,
          image: s == null ? void 0 : s.icon,
          margin: lt.MARGIN,
          qrOptions: {
            errorCorrectionLevel: lt.ERROR_CORRECTION_LEVEL
          },
          dotsOptions: {
            type: lt.DOT_TYPE,
            color: lt.DOT_COLOR
          },
          backgroundOptions: {
            color: lt.BACKGROUND_COLOR
          },
          imageOptions: {
            crossOrigin: "anonymous",
            margin: lt.IMAGE_MARGIN,
            imageSize: lt.IMAGE_SIZE
          }
        });
        this.preGeneratedQRCode = i, Ce.debug("QR code pre-generated successfully");
      } catch (s) {
        Ce.warn("Failed to pre-generate QR code:", s);
      }
    }
    /**
     * Connect to a specific wallet
     */
    async connectWallet(t, n) {
      var s;
      if (!this.walletManager) {
        Ce.error("WalletManager not set");
        return;
      }
      try {
        const i = this.walletManager.wallets.find((o) => o.id === t);
        if (!i)
          throw new Error("Wallet not found");
        if (Ce.debug("Connecting to wallet:", t), t === "walletconnect") {
          Ce.debug("Showing QR view for", t), this.showQRCodeView(t);
          const o = {
            ...n,
            onQRCode: (a) => {
              Ce.debug("QR code callback received:", a.substring(0, 50) + "..."), this.setQRCode(t, a);
            }
          };
          this.dispatchEvent(new CustomEvent("connecting", { detail: { walletId: t } })), await this.walletManager.connect(t, o), this.dispatchEvent(new CustomEvent("connected", { detail: { walletId: t } }));
        } else {
          if (!await i.isAvailable())
            throw new Error(`${i.name} is not installed. Please install the extension first.`);
          this.showLoadingView(t, i.name, i.icon), this.dispatchEvent(new CustomEvent("connecting", { detail: { walletId: t } })), $w() || await qw(Cn.NON_SAFARI_CONNECT_DELAY), await this.walletManager.connect(t, n), this.dispatchEvent(new CustomEvent("connected", { detail: { walletId: t } }));
        }
      } catch (i) {
        const o = (s = this.walletManager) == null ? void 0 : s.wallets.find((c) => c.id === t);
        let a = i.message || "An unexpected error occurred", u = "failed";
        i.code === Xl.USER_REJECTED || a.toLowerCase().includes("user rejected") ? (u = "rejected", a = "Connection request was cancelled") : i.code === Xl.POPUP_CLOSED || a.toLowerCase().includes("already pending") ? (u = "unavailable", a = "Wallet popup was closed or did not respond. Please try again.") : a.toLowerCase().includes("not installed") && (u = "unavailable"), Ce.debug("Connection error type:", u, "Code:", i.code), this.showErrorView(t, (o == null ? void 0 : o.name) || "Wallet", new Error(a)), this.dispatchEvent(new CustomEvent("error", { detail: { error: i, walletId: t, errorType: u } })), Ce.error("Failed to connect:", i);
      }
    }
    /**
     * Show QR code view
     */
    showQRCodeView(t, n) {
      this.viewState = "qr", this.qrCodeData = { walletId: t, uri: n || "" }, this.loadingData = null, this.errorData = null, this.render();
    }
    /**
     * Show loading view
     */
    showLoadingView(t, n, s) {
      this.viewState = "loading", this.loadingData = { walletId: t, walletName: n, walletIcon: s }, this.qrCodeData = null, this.errorData = null, this.render();
    }
    /**
     * Show error view
     */
    showErrorView(t, n, s) {
      this.viewState = "error", this.errorData = { walletId: t, walletName: n, error: s }, this.qrCodeData = null, this.loadingData = null, this.render();
    }
    /**
     * Show wallet list view
     */
    showWalletList() {
      this.viewState = "list", this.qrCodeData = null, this.loadingData = null, this.errorData = null, this.render();
    }
    /**
     * Update QR code with URI
     * Called by wallet adapters when QR code URI is ready
     */
    setQRCode(t, n) {
      var s, i;
      Ce.debug("setQRCode called:", {
        walletId: t,
        uri: n.substring(0, 60) + "...",
        viewState: this.viewState,
        qrCodeData: this.qrCodeData
      }), this.viewState === "qr" && ((s = this.qrCodeData) == null ? void 0 : s.walletId) === t ? (this.qrCodeData.uri = n, setTimeout(() => {
        Ce.debug("Attempting to render QR code...");
        const o = this.shadow.querySelector("#qr-container");
        Ce.debug("QR container found:", !!o), this.renderQRCode(n);
      }, Cn.QR_RENDER_DELAY)) : Ce.warn("QR code view not active or wallet mismatch", {
        viewState: this.viewState,
        expectedWallet: t,
        currentDataWallet: (i = this.qrCodeData) == null ? void 0 : i.walletId
      });
    }
    /**
     * Render QR code using QRCodeStyling library
     * Supports both URI strings and direct image URLs (for Xaman)
     */
    async renderQRCode(t) {
      var s;
      Ce.debug("renderQRCode called with URI:", t.substring(0, 60) + "...");
      const n = this.shadow.querySelector("#qr-container");
      if (!n || !t) {
        Ce.warn("No container or URI for QR code rendering");
        return;
      }
      try {
        if (Qw(t)) {
          Ce.debug("Using direct QR code image from Xaman"), n.innerHTML = `
          <img
            src="${t}"
            alt="QR Code"
            style="width: ${Re.QR_CODE}px; height: ${Re.QR_CODE}px; border-radius: 16px; display: block;"
          />
        `;
          return;
        }
        if (this.preGeneratedQRCode && this.preGeneratedURI === t) {
          Ce.debug("Using pre-generated QR code - instant render!"), n.innerHTML = "", this.preGeneratedQRCode.append(n);
          return;
        }
        Ce.debug("Generating modern QR code from URI");
        const i = (s = this.walletManager) == null ? void 0 : s.wallets.find((a) => {
          var u;
          return a.id === ((u = this.qrCodeData) == null ? void 0 : u.walletId);
        }), o = new Kl({
          width: lt.SIZE,
          height: lt.SIZE,
          type: "svg",
          data: t,
          image: i == null ? void 0 : i.icon,
          margin: lt.MARGIN,
          qrOptions: {
            errorCorrectionLevel: lt.ERROR_CORRECTION_LEVEL
          },
          dotsOptions: {
            type: lt.DOT_TYPE,
            color: lt.DOT_COLOR
          },
          backgroundOptions: {
            color: lt.BACKGROUND_COLOR
          },
          imageOptions: {
            crossOrigin: "anonymous",
            margin: lt.IMAGE_MARGIN,
            imageSize: lt.IMAGE_SIZE
          }
        });
        n.innerHTML = "", o.append(n), Ce.debug("Modern QR code generated successfully");
      } catch (i) {
        Ce.error("Failed to generate QR code:", i), n.innerHTML = `
        <div class="qr-loading" style="color: #ef4444;">
          Failed to generate QR code
        </div>
      `;
      }
    }
    /**
     * Truncate address for display
     */
    truncateAddress(t, n = 6) {
      return t.length <= n * 2 ? t : `${t.substring(0, n)}...${t.substring(t.length - n)}`;
    }
    /**
     * Generate a deterministic gradient from wallet address
     * Creates a unique color pair based on the address hash
     */
    generateGradientFromAddress(t) {
      let n = 0;
      for (let u = 0; u < t.length; u++) {
        const c = t.charCodeAt(u);
        n = (n << 5) - n + c, n = n & n;
      }
      const s = Math.abs(n % 360), i = (s + 60) % 360, o = `hsl(${s}, 70%, 55%)`, a = `hsl(${i}, 70%, 55%)`;
      return { color1: o, color2: a };
    }
    /**
     * Render the component
     */
    render() {
      var h, f, g;
      const t = this.shadow.querySelector(".modal");
      t && (this.previousModalHeight = t.offsetHeight), this.primaryWalletId = this.getAttribute("primary-wallet");
      const n = ((h = this.walletManager) == null ? void 0 : h.connected) || false, s = (f = this.walletManager) == null ? void 0 : f.account, i = n && s ? this.truncateAddress(s.address, 4) : "Connect Wallet", o = this.walletAvailabilityChecked && this.availableWallets.length > 0 ? this.availableWallets : ((g = this.walletManager) == null ? void 0 : g.wallets) || [], a = this.primaryWalletId ? o.find((p) => p.id === this.primaryWalletId) : null, u = o.filter((p) => p.id !== this.primaryWalletId);
      let c = "";
      this.viewState === "qr" && this.qrCodeData ? c = this.renderQRView() : this.viewState === "loading" && this.loadingData ? c = this.renderLoadingView() : this.viewState === "error" && this.errorData ? c = this.renderErrorView() : c = this.renderWalletListView(a, u);
      const l = this.isFirstOpen ? "overlay fade-in" : "overlay", d = this.isFirstOpen ? "modal slide-up" : "modal";
      this.isFirstOpen && (this.isFirstOpen = false), this.shadow.innerHTML = `
    <style>
      @import url('https://fonts.googleapis.com/css2?family=Karla:wght@300;400;600&display=swap');

      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
        font-family: var(--font-family);
        color: var(--text-color);
      }

      html, body {
        overflow-y: overlay;
      }

      :host {
        /* Defaults for CSS variables - can be overridden via style attribute or CSS */
        /* General */
        --xc-font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        --xc-border-radius: 12px;
        --xc-overlay-background: rgba(0, 0, 0, 0.7);
        --xc-overlay-backdrop-filter: blur(0px);

        /* Colors */
        --xc-primary-color: #0EA5E9;
        --xc-background-color: #000637;
        --xc-text-color: #F5F4E7;
        --xc-text-muted-color: rgba(245, 244, 231, 0.6);
        --xc-background-secondary: #1a1a3e;
        --xc-background-tertiary: #242452;
        --xc-loading-border-color: #0EA5E9;

        /* Connect Button */
        --xc-connect-button-font-size: 16px;
        --xc-connect-button-border-radius: 8px;
        --xc-connect-button-color: var(--xc-text-color);
        --xc-connect-button-background: var(--xc-background-color);
        --xc-connect-button-border: 1px solid rgba(255, 255, 255, 0.1);
        --xc-connect-button-hover-background: var(--xc-background-color);
        --xc-connect-button-font-weight: 600;

        /* Primary Button */
        --xc-primary-button-color: #ffffff;
        --xc-primary-button-background: var(--xc-primary-color);
        --xc-primary-button-border-radius: 8px;
        --xc-primary-button-font-weight: 600;
        --xc-primary-button-hover-background: var(--xc-primary-color);

        /* Secondary Button */
        --xc-secondary-button-color: var(--xc-text-color);
        --xc-secondary-button-background: var(--xc-background-secondary);
        --xc-secondary-button-border-radius: 8px;
        --xc-secondary-button-font-weight: 500;
        --xc-secondary-button-hover-background: var(--xc-background-tertiary);

        /* Account Address Button */
        --xc-account-address-button-hover-color: var(--xc-primary-color);

        /* Modal */
        --xc-modal-background: var(--xc-background-color);
        --xc-modal-border-radius: 12px;
        --xc-modal-box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);

        /* Miscellaneous */
        --xc-focus-color: var(--xc-primary-color);
        --xc-danger-color: #ef4444;
        --xc-success-color: #10b981;
        --xc-warning-color: #f59e0b;

        /* Internal aliases */
        --bg-color: var(--xc-background-color);
        --text-color: var(--xc-text-color);
        --primary-color: var(--xc-primary-color);
        --primary-bn-hover: var(--xc-primary-button-hover-background);
        --font-family: var(--xc-font-family);
        --wallet-btn-bg: var(--xc-background-secondary);
        --wallet-btn-hover: var(--xc-background-tertiary);
      }

      @keyframes heightChange {
        from { height: var(--old-height); }
        to { height: var(--new-height); }
      }

      .overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: var(--xc-overlay-background);
        backdrop-filter: var(--xc-overlay-backdrop-filter);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: ${Gs.OVERLAY};
      }

      .overlay.fade-in {
        animation: fadeIn ${Cn.ANIMATION_DURATION}ms ease-out;
      }

      @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
      }

      .modal {
        background: var(--xc-modal-background);
        color: var(--xc-text-color);
        border-radius: var(--xc-modal-border-radius);
        width: ${Re.MODAL_WIDTH}px;
        max-width: calc(100vw - 32px);
        max-height: 85vh;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        box-shadow: var(--xc-modal-box-shadow);
        border: 1px solid rgba(255, 255, 255, 0.08);
        transition: height ${Cn.ANIMATION_DURATION}ms cubic-bezier(0.25, 0.1, 0.25, 1);
      }

      .modal.slide-up {
        animation: slideUp 0.3s ease-out;
      }

      @keyframes slideUp {
        from { transform: translateY(20px); opacity: 0; }
        to { transform: translateY(0); opacity: 1; }
      }

      .header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: ${Re.HEADER_PADDING}px 20px 16px;
      }

      .header-with-back {
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .back-button {
        width: ${Re.CLOSE_BUTTON_SIZE}px;
        height: ${Re.CLOSE_BUTTON_SIZE}px;
        border-radius: 50%;
        border: none;
        background: transparent;
        color: var(--text-color);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 20px;
        opacity: 0.7;
        transition: all 0.2s;
      }

      .back-button:hover {
        opacity: 1;
        background: var(--wallet-btn-bg);
      }

      .title {
        font-size: 22px;
        font-weight: ${rr.SEMIBOLD};
        letter-spacing: -0.3px;
        flex: 1;
      }

      .close-button {
        width: ${Re.CLOSE_BUTTON_SIZE}px;
        height: ${Re.CLOSE_BUTTON_SIZE}px;
        border-radius: 50%;
        border: none;
        background: transparent;
        color: var(--text-color);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 24px;
        opacity: 0.7;
        transition: all 0.2s;
      }

      .close-button:hover {
        opacity: 1;
        background: var(--wallet-btn-bg);
      }

      .content {
        flex: 1;
        overflow-y: hidden;
        padding: 0 24px 24px;
        transition: opacity 0.3s ease;
        -ms-overflow-style: none;
        scrollbar-width: none;
      }

      .content::-webkit-scrollbar {
        display: none;
      }

      .connect-button {
        padding: ${Re.BUTTON_PADDING_VERTICAL}px ${Re.BUTTON_PADDING_HORIZONTAL}px;
        border-radius: var(--xc-connect-button-border-radius);
        border: var(--xc-connect-button-border);
        background: var(--xc-connect-button-background);
        color: var(--xc-connect-button-color);
        font-size: var(--xc-connect-button-font-size);
        font-weight: var(--xc-connect-button-font-weight);
        cursor: pointer;
        transition: all 0.2s;
        font-family: var(--xc-font-family);
      }

      .connect-button:hover {
        background: var(--xc-connect-button-hover-background);
      }

      .primary-button {
        width: 100%;
        padding: ${Re.BUTTON_PADDING_VERTICAL}px ${Re.BUTTON_PADDING_HORIZONTAL}px;
        border-radius: var(--xc-primary-button-border-radius);
        border: none;
        margin-bottom: 20px;
        background: var(--xc-primary-button-background);
        color: var(--xc-primary-button-color);
        font-size: 16px;
        font-weight: var(--xc-primary-button-font-weight);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 10px;
        transition: all 0.2s;
      }

      .primary-button:hover {
          background: var(--xc-primary-button-hover-background);
      }

      .wallet-list {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .wallet-button {
        width: 100%;
        padding: ${Re.BUTTON_PADDING_VERTICAL}px ${Re.BUTTON_PADDING_HORIZONTAL}px;
        border-radius: var(--xc-secondary-button-border-radius);
        border: none;
        background: var(--xc-secondary-button-background);
        color: var(--xc-secondary-button-color);
        font-size: 16px;
        font-weight: var(--xc-secondary-button-font-weight);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: space-between;
        transition: background 0.2s;
      }

      .wallet-button:hover {
        background: var(--xc-secondary-button-hover-background);
      }

      .wallet-button img {
        border-radius: 6px;
      }

      .qr-view {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
        padding: 20px 0;
      }

.qr-card {
  background: #fff;
  border-radius: ${Re.MODAL_BORDER_RADIUS}px;
  padding: ${Re.QR_CARD_PADDING}px;
  width: 100%;
  max-width: 295px;
  box-shadow: 0 10px 30px rgba(0,0,0,0.12), 0 0 0 1px rgba(0,0,0,0.05);
  border: 1px solid rgba(0,0,0,0.06);
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 18px;
}

.qr-header {
  font-size: 16px;
  font-weight: ${rr.SEMIBOLD};
  color: #111;
}

.qr-container {
  width: ${Re.QR_CODE}px;
  height: ${Re.QR_CODE}px;
  border-radius: 16px;
  overflow: hidden;
  display: flex;
  align-items: center;
  justify-content: center;
  background: white;
}

.qr-container img {
  width: 100%;
  height: 100%;
  object-fit: contain;
}

.qr-loading {
  font-size: 14px;
  color: #555;
}

.qr-footer {
  width: 100%;
  display: flex;
  justify-content: center;
}

.copy-button {
  padding: 12px 16px;
  border: none;
  border-radius: 10px;
  background: #f3f3f3;
  color: #111;
  font-weight: ${rr.MEDIUM};
  cursor: pointer;
  transition: all 0.2s ease;
}

.copy-button:hover {
  background: #e5e5e5;
}

      .qr-placeholder {
        width: 280px;
        height: 280px;
        background: white;
        border-radius: 16px;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 20px;
      }

      .qr-instructions {
        text-align: center;
        font-size: 14px;
        opacity: 0.8;
        line-height: 1.5;
      }

      .qr-deeplink {
        width: 100%;
        margin-top: 10px;
      }

      .deeplink-button {
        width: 100%;
        padding: 14px ${Re.BUTTON_PADDING_HORIZONTAL}px;
        border-radius: ${Re.BUTTON_BORDER_RADIUS}px;
        border: none;
        background: var(--primary-color);
        color: white;
        font-size: 15px;
        font-weight: ${rr.SEMIBOLD};
        cursor: pointer;
        transition: all 0.2s;
      }

      .deeplink-button:hover {
        transform: translateY(-1px);
        box-shadow: 0 4px 8px rgba(14, 165, 233, 0.3);
      }

      /* Loading View */
      .loading-view {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 24px;
        padding: 40px 0;
      }

      .loading-logo-container {
        position: relative;
        width: 120px;
        height: 120px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .loading-logo {
        width: ${Re.LOADING_LOGO}px;
        height: ${Re.LOADING_LOGO}px;
        border-radius: 16px;
        z-index: ${Gs.LOADING_LOGO};
        position: relative;
      }

.loading-border {
  position: absolute;
  top: -4px;
  left: -4px;
  right: -4px;
  bottom: -4px;
  border-radius: 20px;
  overflow: hidden;
}

.loading-border::before {
  content: '';
  position: absolute;
  top: -50%;
  left: -50%;
  width: 200%;
  height: 200%;
  background: conic-gradient(
    transparent 0deg 90deg,
    var(--xc-loading-border-color) 90deg 180deg,
    transparent 180deg 270deg,
    var(--xc-loading-border-color) 270deg 360deg
  );
  animation: rotate 2s linear infinite;
}

.loading-border::after {
  content: '';
  position: absolute;
  top: 4px;
  left: 4px;
  right: 4px;
  bottom: 4px;
  background: var(--xc-background-color);
  border-radius: 16px;
  z-index: ${Gs.LOADING_BORDER_AFTER};
}

@keyframes rotate {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}
        .loading-text {
        text-align: center;
        font-size: 16px;
        font-weight: ${rr.LIGHT};
        opacity: 0.9;
      }

      /* Error View */
      .error-view {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
        padding: 30px 0;
      }

      .error-icon {
        width: ${Re.ICON_LARGE}px;
        height: ${Re.ICON_LARGE}px;
        border-radius: 50%;
        background: rgba(239, 68, 68, 0.1);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 48px;
        color: #ef4444;
      }

      .error-text {
        text-align: center;
      }

      .error-title {
        font-size: 18px;
        font-weight: ${rr.SEMIBOLD};
        margin-bottom: 8px;
      }

      .error-message {
        font-size: 14px;
        font-weight: ${rr.LIGHT};
        opacity: 0.8;
        line-height: 1.5;
      }

      .error-buttons {
        width: 100%;
        display: flex;
        gap: 12px;
        margin-top: 10px;
      }

      .error-button {
        flex: 1;
        padding: 14px ${Re.BUTTON_PADDING_HORIZONTAL}px;
        border-radius: ${Re.BUTTON_BORDER_RADIUS}px;
        border: none;
        font-size: 15px;
        font-weight: ${rr.SEMIBOLD};
        cursor: pointer;
        transition: all 0.2s;
      }

      .error-button-primary {
        background: var(--primary-color);
        color: white;
      }

      .error-button-primary:hover {
        transform: translateY(-1px);
        box-shadow: 0 4px 8px rgba(14, 165, 233, 0.3);
      }

      .error-button-secondary {
        background: var(--wallet-btn-bg);
        color: var(--text-color);
      }

      .error-button-secondary:hover {
        background: var(--wallet-btn-hover);
      }

      /* Account Modal Styles */
      .account-modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: var(--xc-overlay-background);
        backdrop-filter: var(--xc-overlay-backdrop-filter);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: ${Gs.OVERLAY};
        animation: fadeIn ${Cn.ANIMATION_DURATION}ms ease-out;
      }

      .account-modal {
        background: var(--xc-modal-background);
        color: var(--xc-text-color);
        border-radius: var(--xc-modal-border-radius);
        width: 100%;
        max-width: 280px;
        padding: 0;
        box-shadow: var(--xc-modal-box-shadow);
        border: 1px solid rgba(255, 255, 255, 0.08);
        animation: slideUp 0.3s ease-out;
        overflow: hidden;
      }

      .account-modal-header {
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 16px 20px;
        background: rgba(255, 255, 255, 0.02);
        position: relative;
      }

      .account-modal-title {
        font-size: 16px;
        font-weight: ${rr.SEMIBOLD};
        letter-spacing: -0.3px;
        flex: 1;
        text-align: center;
      }

      .account-modal-close {
        position: absolute;
        right: 8px;
        width: 28px;
        height: 28px;
        border-radius: 50%;
        border: none;
        background: transparent;
        color: var(--text-color);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 20px;
        opacity: 0.6;
        transition: all 0.2s;
        flex-shrink: 0;
      }

      .account-modal-close:hover {
        opacity: 1;
        background: var(--wallet-btn-bg);
      }

      .account-modal-content {
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 40px 24px 32px;
        gap: 0;
        text-align: center;
      }

      .account-avatar-container {
        width: 100px;
        height: 100px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 50%;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        margin-bottom: 28px;
        flex-shrink: 0;
      }

      .account-info-section {
        width: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 16px;
        margin-bottom: 24px;
      }

      .account-address-button {
        background: none;
        border: none;
        color: var(--text-color);
        cursor: pointer;
        font-size: 14px;
        font-weight: ${rr.SEMIBOLD};
        font-family: var(--font-family);
        padding: 0;
        transition: opacity 0.2s;
        letter-spacing: 0.3px;
        display: flex;
        align-items: center;
        gap: 8px;
        justify-content: center;
      }

      .account-address-button:hover {
        color: var(--xc-account-address-button-hover-color);
      }

      .copy-icon {
        width: 20px;
        height: 20px;
        opacity: 0.5;
        transition: opacity 0.2s ease;
        flex-shrink: 0;
      }

      .account-address-button:hover .copy-icon {
        opacity: 1;
        color: var(--xc-account-address-button-hover-color);
      }

      .account-balance-display {
        display: flex;
        align-items: baseline;
        justify-content: center;
        gap: 8px;
      }

      .account-balance-value {
        font-size: 28px;
        font-weight: ${rr.SEMIBOLD};
        color: var(--primary-color);
      }

      .account-balance-unit {
        font-size: 14px;
        font-weight: ${rr.MEDIUM};
        opacity: 0.8;
      }

      .account-disconnect-button {
        width: 100%;
        padding: 12px ${Re.BUTTON_PADDING_HORIZONTAL}px;
        border-radius: var(--xc-secondary-button-border-radius);
        border: none;
        background: var(--xc-secondary-button-background);
        color: var(--xc-secondary-button-color);
        font-size: 14px;
        font-weight: var(--xc-secondary-button-font-weight);
        cursor: pointer;
        transition: all 0.2s;
        font-family: var(--xc-font-family);
        margin-top: 16px;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
      }

      .account-disconnect-button:hover {
        background: var(--xc-secondary-button-hover-background);
      }

      .disconnect-icon {
        width: 15px;
        height: 14px;
        transition: opacity 0.2s ease;
        flex-shrink: 0;
      }

      .account-disconnect-button:hover .disconnect-icon {
        opacity: 1;
      }

      .account-disconnect-button:hover .disconnect-icon path {
        fill: #ef4444;
      }
    </style>

    <button class="connect-button" id="connect-wallet-button" part="connect-button">${i}</button>

    ${this.isOpen ? `
    <div class="${l}" part="overlay">
      <div class="${d}" part="modal">
        ${c}
      </div>
    </div>
    ` : ""}

    ${this.accountModalOpen ? this.renderAccountModal() : ""}
  `, this.attachEventListeners(), requestAnimationFrame(() => {
        this.updateModalHeight();
      });
    }
    /**
     * Update modal height with smooth transition
     */
    updateModalHeight() {
      const t = this.shadow.querySelector(".modal");
      if (!t) return;
      const n = this.previousModalHeight, s = t.offsetHeight;
      n > 0 && s > 0 && n !== s && (t.style.height = `${n}px`, t.offsetHeight, requestAnimationFrame(() => {
        t.style.height = `${s}px`;
      })), this.previousModalHeight = s;
    }
    /**
     * Render wallet list view
     */
    renderWalletListView(t, n) {
      return `
      <div class="header">
        <h2 class="title">Connect Wallet</h2>
        <button class="close-button" part="close-button" aria-label="Close">×</button>
      </div>

      <div class="content">
        ${t ? `
          <button class="primary-button" data-wallet-id="${t.id}">
            ${t.icon ? `<img src="${t.icon}" width="24" height="24" alt="${t.name}">` : ""}
            <span>Continue with ${t.name}</span>
          </button>
        ` : ""}
        <div class="wallet-list">
          ${n.map(
        (s) => `
            <button class="wallet-button" data-wallet-id="${s.id}">
              <span>${s.name}</span>
              ${s.icon ? `<img src="${s.icon}" width="28" height="28" alt="${s.name}">` : ""}
            </button>`
      ).join("")}
        </div>
      </div>
    `;
    }
    /**
     * Render QR code view
     */
    renderQRView() {
      var s;
      const t = (s = this.walletManager) == null ? void 0 : s.wallets.find((i) => {
        var o;
        return i.id === ((o = this.qrCodeData) == null ? void 0 : o.walletId);
      });
      return `
    <div class="header">
      <div class="header-with-back">
        <button class="back-button" id="back-button" aria-label="Back">←</button>
        <h2 class="title">${(t == null ? void 0 : t.name) || "Wallet"}</h2>
      </div>
      <button class="close-button" part="close-button" aria-label="Close">×</button>
    </div>

    <div class="content">
      <div class="qr-view">
        <div class="qr-card">
          <div class="qr-header">Scan with Phone</div>
          <div class="qr-container" id="qr-container">
            <div class="qr-loading">Loading QR...</div>
          </div>
          <div class="qr-footer">
            <button class="copy-button" id="copy-button">Copy to Clipboard</button>
          </div>
        </div>
      </div>
    </div>
  `;
    }
    /**
     * Render loading view
     */
    renderLoadingView() {
      if (!this.loadingData) return "";
      const { walletName: t, walletIcon: n } = this.loadingData;
      return `
      <div class="header">
        <div class="header-with-back">
          <button class="back-button" id="loading-back-button" aria-label="Back">←</button>
          <h2 class="title">Connect Wallet</h2>
        </div>
        <button class="close-button" part="close-button" aria-label="Close">×</button>
      </div>

      <div class="content loading-content">
        <div class="loading-view">
          <div class="loading-logo-container">
            ${n ? `<img src="${n}" alt="${t}" class="loading-logo">` : ""}
            <div class="loading-border"></div>
          </div>
          <div class="loading-text">
            <p>Requesting connection...</p>
            <p style="margin-top: 8px; font-size: 14px; opacity: 0.7;">Check your ${t}</p>
          </div>
        </div>
      </div>
    `;
    }
    /**
     * Render error view
     */
    renderErrorView() {
      if (!this.errorData) return "";
      const { walletName: t } = this.errorData;
      return `
      <div class="header">
        <h2 class="title">Connection Failed</h2>
        <button class="close-button" part="close-button" aria-label="Close">×</button>
      </div>

      <div class="content">
        <div class="error-view">
          <div class="error-icon">⚠</div>
          <div class="error-text">
            <div class="error-title">Failed to connect to ${t}</div>
          </div>
          <div class="error-buttons">
            <button class="error-button error-button-secondary" id="error-back-button">
              Back
            </button>
            <button class="error-button error-button-primary" id="error-retry-button">
              Try Again
            </button>
          </div>
        </div>
      </div>
    `;
    }
    /**
     * Render account details modal
     */
    renderAccountModal() {
      var o;
      const t = (o = this.walletManager) == null ? void 0 : o.account;
      if (!t) return "";
      const n = this.truncateAddress(t.address, 6), { color1: s, color2: i } = this.generateGradientFromAddress(t.address);
      return `
      <div id="account-modal-overlay" class="account-modal-overlay">
        <div class="account-modal">
          <div class="account-modal-header">
            <h2 class="account-modal-title">Connected</h2>
            <button class="account-modal-close" id="account-modal-close" aria-label="Close">×</button>
          </div>

          <div class="account-modal-content">
            <div class="account-avatar-container" style="background: linear-gradient(135deg, ${s}, ${i});">
            </div>

            <div class="account-info-section">
              <button class="account-address-button" id="copy-account-address" title="Click to copy full address">
                <span>${n}</span>
                <svg
                  aria-hidden="true"
                  width="20"
                  height="20"
                  viewBox="0 0 24 24"
                  fill="none"
                  xmlns="http://www.w3.org/2000/svg"
                  class="copy-icon"
                >
                  <path d="M14 9.5V7C14 5.89543 13.1046 5 12 5H7C5.89543 5 5 5.89543 5 7V12C5 13.1046 5.89543 14 7 14H9.5" stroke="currentColor" stroke-width="2"></path>
                  <rect x="10" y="10" width="9" height="9" rx="2" stroke="currentColor" stroke-width="2"></rect>
                </svg>
              </button>

              ${this.accountBalance ? `
                <div class="account-balance-display">
                  <span class="account-balance-value">${this.accountBalance}</span>
                  <span class="account-balance-unit">XRP</span>
                </div>
              ` : ""}
            </div>

            <button class="account-disconnect-button" id="account-modal-disconnect">
              <svg
                aria-hidden="true"
                width="15"
                height="14"
                viewBox="0 0 15 14"
                fill="none"
                xmlns="http://www.w3.org/2000/svg"
                class="disconnect-icon"
              >
                <path
                  fill-rule="evenodd"
                  clip-rule="evenodd"
                  d="M4 0C1.79086 0 0 1.79086 0 4V10C0 12.2091 1.79086 14 4 14H6C6.55228 14 7 13.5523 7 13C7 12.4477 6.55228 12 6 12H4C2.89543 12 2 11.1046 2 10V4C2 2.89543 2.89543 2 4 2H6C6.55228 2 7 1.55228 7 1C7 0.447715 6.55228 0 6 0H4ZM11.7071 3.29289C11.3166 2.90237 10.6834 2.90237 10.2929 3.29289C9.90237 3.68342 9.90237 4.31658 10.2929 4.70711L11.5858 6H9.5H6C5.44772 6 5 6.44772 5 7C5 7.55228 5.44772 8 6 8H9.5H11.5858L10.2929 9.29289C9.90237 9.68342 9.90237 10.3166 10.2929 10.7071C10.6834 11.0976 11.3166 11.0976 11.7071 10.7071L14.7071 7.70711C15.0976 7.31658 15.0976 6.68342 14.7071 6.29289L11.7071 3.29289Z"
                  fill="currentColor"
                  fill-opacity="0.4"
                ></path>
              </svg>
              <span>Disconnect</span>
            </button>
          </div>
        </div>
      </div>
    `;
    }
    /**
     * Attach event listeners
     */
    attachEventListeners() {
      var t, n, s, i, o, a, u, c, l, d, h, f, g;
      (t = this.shadow.querySelector("#connect-wallet-button")) == null || t.addEventListener("click", async () => {
        var b;
        ((b = this.walletManager) == null ? void 0 : b.connected) || false ? this.openAccountModal() : this.open();
      }), (n = this.shadow.querySelector("#account-modal-close")) == null || n.addEventListener("click", () => {
        this.closeAccountModal();
      }), (s = this.shadow.querySelector("#account-modal-disconnect")) == null || s.addEventListener("click", () => {
        this.disconnectFromAccountModal();
      }), (i = this.shadow.querySelector("#account-modal-overlay")) == null || i.addEventListener("click", (p) => {
        p.target === p.currentTarget && this.closeAccountModal();
      }), (o = this.shadow.querySelector("#copy-account-address")) == null || o.addEventListener("click", async () => {
        var b, _;
        const p = (_ = (b = this.walletManager) == null ? void 0 : b.account) == null ? void 0 : _.address;
        if (p)
          try {
            await navigator.clipboard.writeText(p);
            const D = this.shadow.querySelector("#copy-account-address"), v = D.innerHTML;
            D.innerHTML = "<span>Copied!</span>", setTimeout(() => {
              D && (D.innerHTML = v);
            }, Cn.COPY_FEEDBACK_DURATION);
          } catch (D) {
            Ce.error("Failed to copy address:", D);
          }
      }), (a = this.shadow.querySelector(".close-button")) == null || a.addEventListener("click", () => this.close()), (u = this.shadow.querySelector(".overlay")) == null || u.addEventListener("click", (p) => {
        p.target === p.currentTarget && this.close();
      }), this.shadow.querySelectorAll("[data-wallet-id]").forEach((p) => {
        p.addEventListener("click", () => {
          const b = p.dataset.walletId;
          b && this.connectWallet(b);
        });
      }), (c = this.shadow.querySelector("#back-button")) == null || c.addEventListener("click", () => {
        this.showWalletList();
      }), (l = this.shadow.querySelector("#loading-back-button")) == null || l.addEventListener("click", () => {
        this.showWalletList();
      }), (d = this.shadow.querySelector("#copy-button")) == null || d.addEventListener("click", async () => {
        var p;
        if ((p = this.qrCodeData) != null && p.uri)
          try {
            await navigator.clipboard.writeText(this.qrCodeData.uri);
            const b = this.shadow.querySelector("#copy-button");
            b && (b.textContent = "Copied!", setTimeout(
              () => b.textContent = "Copy to Clipboard",
              Cn.COPY_FEEDBACK_DURATION
            ));
          } catch (b) {
            Ce.error("Failed to copy to clipboard:", b);
          }
      }), (h = this.shadow.querySelector("#deeplink-button")) == null || h.addEventListener("click", () => {
        var p, b, _;
        if ((p = this.qrCodeData) != null && p.uri && ((b = this.qrCodeData) != null && b.walletId)) {
          const D = (_ = this.walletManager) == null ? void 0 : _.wallets.find(
            (E) => {
              var A;
              return E.id === ((A = this.qrCodeData) == null ? void 0 : A.walletId);
            }
          );
          let v = this.qrCodeData.uri;
          D && typeof D.getDeepLinkURI == "function" && (v = D.getDeepLinkURI(this.qrCodeData.uri)), Fw() ? window.location.href = v : window.open(v, "_blank");
        }
      }), (f = this.shadow.querySelector("#error-retry-button")) == null || f.addEventListener("click", () => {
        var p;
        (p = this.errorData) != null && p.walletId && this.connectWallet(this.errorData.walletId);
      }), (g = this.shadow.querySelector("#error-back-button")) == null || g.addEventListener("click", () => {
        this.showWalletList();
      });
    }
  }
  Jl = r, customElements.get("xrpl-wallet-connector") || customElements.define("xrpl-wallet-connector", Jl);
}
var Ju = {};
var Li = {};
var el = { exports: {} };
var Ti = typeof Reflect == "object" ? Reflect : null;
var ed = Ti && typeof Ti.apply == "function" ? Ti.apply : function(e, t, n) {
  return Function.prototype.apply.call(e, t, n);
};
var Eo;
Ti && typeof Ti.ownKeys == "function" ? Eo = Ti.ownKeys : Object.getOwnPropertySymbols ? Eo = function(e) {
  return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
} : Eo = function(e) {
  return Object.getOwnPropertyNames(e);
};
function Yw(r) {
  console && console.warn && console.warn(r);
}
var yp = Number.isNaN || function(e) {
  return e !== e;
};
function Pe() {
  Pe.init.call(this);
}
el.exports = Pe;
el.exports.once = Ww;
Pe.EventEmitter = Pe;
Pe.prototype._events = void 0;
Pe.prototype._eventsCount = 0;
Pe.prototype._maxListeners = void 0;
var td = 10;
function na(r) {
  if (typeof r != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof r);
}
Object.defineProperty(Pe, "defaultMaxListeners", {
  enumerable: true,
  get: function() {
    return td;
  },
  set: function(r) {
    if (typeof r != "number" || r < 0 || yp(r))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + r + ".");
    td = r;
  }
});
Pe.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
Pe.prototype.setMaxListeners = function(e) {
  if (typeof e != "number" || e < 0 || yp(e))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
  return this._maxListeners = e, this;
};
function wp(r) {
  return r._maxListeners === void 0 ? Pe.defaultMaxListeners : r._maxListeners;
}
Pe.prototype.getMaxListeners = function() {
  return wp(this);
};
Pe.prototype.emit = function(e) {
  for (var t = [], n = 1; n < arguments.length; n++) t.push(arguments[n]);
  var s = e === "error", i = this._events;
  if (i !== void 0)
    s = s && i.error === void 0;
  else if (!s)
    return false;
  if (s) {
    var o;
    if (t.length > 0 && (o = t[0]), o instanceof Error)
      throw o;
    var a = new Error("Unhandled error." + (o ? " (" + o.message + ")" : ""));
    throw a.context = o, a;
  }
  var u = i[e];
  if (u === void 0)
    return false;
  if (typeof u == "function")
    ed(u, this, t);
  else
    for (var c = u.length, l = Ep(u, c), n = 0; n < c; ++n)
      ed(l[n], this, t);
  return true;
};
function mp(r, e, t, n) {
  var s, i, o;
  if (na(t), i = r._events, i === void 0 ? (i = r._events = /* @__PURE__ */ Object.create(null), r._eventsCount = 0) : (i.newListener !== void 0 && (r.emit(
    "newListener",
    e,
    t.listener ? t.listener : t
  ), i = r._events), o = i[e]), o === void 0)
    o = i[e] = t, ++r._eventsCount;
  else if (typeof o == "function" ? o = i[e] = n ? [t, o] : [o, t] : n ? o.unshift(t) : o.push(t), s = wp(r), s > 0 && o.length > s && !o.warned) {
    o.warned = true;
    var a = new Error("Possible EventEmitter memory leak detected. " + o.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    a.name = "MaxListenersExceededWarning", a.emitter = r, a.type = e, a.count = o.length, Yw(a);
  }
  return r;
}
Pe.prototype.addListener = function(e, t) {
  return mp(this, e, t, false);
};
Pe.prototype.on = Pe.prototype.addListener;
Pe.prototype.prependListener = function(e, t) {
  return mp(this, e, t, true);
};
function Vw() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function bp(r, e, t) {
  var n = { fired: false, wrapFn: void 0, target: r, type: e, listener: t }, s = Vw.bind(n);
  return s.listener = t, n.wrapFn = s, s;
}
Pe.prototype.once = function(e, t) {
  return na(t), this.on(e, bp(this, e, t)), this;
};
Pe.prototype.prependOnceListener = function(e, t) {
  return na(t), this.prependListener(e, bp(this, e, t)), this;
};
Pe.prototype.removeListener = function(e, t) {
  var n, s, i, o, a;
  if (na(t), s = this._events, s === void 0)
    return this;
  if (n = s[e], n === void 0)
    return this;
  if (n === t || n.listener === t)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete s[e], s.removeListener && this.emit("removeListener", e, n.listener || t));
  else if (typeof n != "function") {
    for (i = -1, o = n.length - 1; o >= 0; o--)
      if (n[o] === t || n[o].listener === t) {
        a = n[o].listener, i = o;
        break;
      }
    if (i < 0)
      return this;
    i === 0 ? n.shift() : Hw(n, i), n.length === 1 && (s[e] = n[0]), s.removeListener !== void 0 && this.emit("removeListener", e, a || t);
  }
  return this;
};
Pe.prototype.off = Pe.prototype.removeListener;
Pe.prototype.removeAllListeners = function(e) {
  var t, n, s;
  if (n = this._events, n === void 0)
    return this;
  if (n.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : n[e] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete n[e]), this;
  if (arguments.length === 0) {
    var i = Object.keys(n), o;
    for (s = 0; s < i.length; ++s)
      o = i[s], o !== "removeListener" && this.removeAllListeners(o);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (t = n[e], typeof t == "function")
    this.removeListener(e, t);
  else if (t !== void 0)
    for (s = t.length - 1; s >= 0; s--)
      this.removeListener(e, t[s]);
  return this;
};
function vp(r, e, t) {
  var n = r._events;
  if (n === void 0)
    return [];
  var s = n[e];
  return s === void 0 ? [] : typeof s == "function" ? t ? [s.listener || s] : [s] : t ? Gw(s) : Ep(s, s.length);
}
Pe.prototype.listeners = function(e) {
  return vp(this, e, true);
};
Pe.prototype.rawListeners = function(e) {
  return vp(this, e, false);
};
Pe.listenerCount = function(r, e) {
  return typeof r.listenerCount == "function" ? r.listenerCount(e) : Mp.call(r, e);
};
Pe.prototype.listenerCount = Mp;
function Mp(r) {
  var e = this._events;
  if (e !== void 0) {
    var t = e[r];
    if (typeof t == "function")
      return 1;
    if (t !== void 0)
      return t.length;
  }
  return 0;
}
Pe.prototype.eventNames = function() {
  return this._eventsCount > 0 ? Eo(this._events) : [];
};
function Ep(r, e) {
  for (var t = new Array(e), n = 0; n < e; ++n)
    t[n] = r[n];
  return t;
}
function Hw(r, e) {
  for (; e + 1 < r.length; e++)
    r[e] = r[e + 1];
  r.pop();
}
function Gw(r) {
  for (var e = new Array(r.length), t = 0; t < e.length; ++t)
    e[t] = r[t].listener || r[t];
  return e;
}
function Ww(r, e) {
  return new Promise(function(t, n) {
    function s(o) {
      r.removeListener(e, i), n(o);
    }
    function i() {
      typeof r.removeListener == "function" && r.removeListener("error", s), t([].slice.call(arguments));
    }
    Np(r, e, i, { once: true }), e !== "error" && Kw(r, s, { once: true });
  });
}
function Kw(r, e, t) {
  typeof r.on == "function" && Np(r, "error", e, t);
}
function Np(r, e, t, n) {
  if (typeof r.on == "function")
    n.once ? r.once(e, t) : r.on(e, t);
  else if (typeof r.addEventListener == "function")
    r.addEventListener(e, function s(i) {
      n.once && r.removeEventListener(e, s), t(i);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof r);
}
var Gt = el.exports;
var xp = Cs(Gt);
var Ln = {};
var nu = { exports: {} };
var ec;
var rd;
function Xw() {
  if (rd) return ec;
  rd = 1;
  var r = 1e3, e = r * 60, t = e * 60, n = t * 24, s = n * 7, i = n * 365.25;
  ec = function(l, d) {
    d = d || {};
    var h = typeof l;
    if (h === "string" && l.length > 0)
      return o(l);
    if (h === "number" && isFinite(l))
      return d.long ? u(l) : a(l);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(l)
    );
  };
  function o(l) {
    if (l = String(l), !(l.length > 100)) {
      var d = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        l
      );
      if (d) {
        var h = parseFloat(d[1]), f = (d[2] || "ms").toLowerCase();
        switch (f) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return h * i;
          case "weeks":
          case "week":
          case "w":
            return h * s;
          case "days":
          case "day":
          case "d":
            return h * n;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return h * t;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return h * e;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return h * r;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return h;
          default:
            return;
        }
      }
    }
  }
  function a(l) {
    var d = Math.abs(l);
    return d >= n ? Math.round(l / n) + "d" : d >= t ? Math.round(l / t) + "h" : d >= e ? Math.round(l / e) + "m" : d >= r ? Math.round(l / r) + "s" : l + "ms";
  }
  function u(l) {
    var d = Math.abs(l);
    return d >= n ? c(l, d, n, "day") : d >= t ? c(l, d, t, "hour") : d >= e ? c(l, d, e, "minute") : d >= r ? c(l, d, r, "second") : l + " ms";
  }
  function c(l, d, h, f) {
    var g = d >= h * 1.5;
    return Math.round(l / h) + " " + f + (g ? "s" : "");
  }
  return ec;
}
function Zw(r) {
  t.debug = t, t.default = t, t.coerce = u, t.disable = o, t.enable = s, t.enabled = a, t.humanize = Xw(), t.destroy = c, Object.keys(r).forEach((l) => {
    t[l] = r[l];
  }), t.names = [], t.skips = [], t.formatters = {};
  function e(l) {
    let d = 0;
    for (let h = 0; h < l.length; h++)
      d = (d << 5) - d + l.charCodeAt(h), d |= 0;
    return t.colors[Math.abs(d) % t.colors.length];
  }
  t.selectColor = e;
  function t(l) {
    let d, h = null, f, g;
    function p(...b) {
      if (!p.enabled)
        return;
      const _ = p, D = Number(/* @__PURE__ */ new Date()), v = D - (d || D);
      _.diff = v, _.prev = d, _.curr = D, d = D, b[0] = t.coerce(b[0]), typeof b[0] != "string" && b.unshift("%O");
      let E = 0;
      b[0] = b[0].replace(/%([a-zA-Z%])/g, (k, U) => {
        if (k === "%%")
          return "%";
        E++;
        const P = t.formatters[U];
        if (typeof P == "function") {
          const $ = b[E];
          k = P.call(_, $), b.splice(E, 1), E--;
        }
        return k;
      }), t.formatArgs.call(_, b), (_.log || t.log).apply(_, b);
    }
    return p.namespace = l, p.useColors = t.useColors(), p.color = t.selectColor(l), p.extend = n, p.destroy = t.destroy, Object.defineProperty(p, "enabled", {
      enumerable: true,
      configurable: false,
      get: () => h !== null ? h : (f !== t.namespaces && (f = t.namespaces, g = t.enabled(l)), g),
      set: (b) => {
        h = b;
      }
    }), typeof t.init == "function" && t.init(p), p;
  }
  function n(l, d) {
    const h = t(this.namespace + (typeof d > "u" ? ":" : d) + l);
    return h.log = this.log, h;
  }
  function s(l) {
    t.save(l), t.namespaces = l, t.names = [], t.skips = [];
    const d = (typeof l == "string" ? l : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
    for (const h of d)
      h[0] === "-" ? t.skips.push(h.slice(1)) : t.names.push(h);
  }
  function i(l, d) {
    let h = 0, f = 0, g = -1, p = 0;
    for (; h < l.length; )
      if (f < d.length && (d[f] === l[h] || d[f] === "*"))
        d[f] === "*" ? (g = f, p = h, f++) : (h++, f++);
      else if (g !== -1)
        f = g + 1, p++, h = p;
      else
        return false;
    for (; f < d.length && d[f] === "*"; )
      f++;
    return f === d.length;
  }
  function o() {
    const l = [
      ...t.names,
      ...t.skips.map((d) => "-" + d)
    ].join(",");
    return t.enable(""), l;
  }
  function a(l) {
    for (const d of t.skips)
      if (i(l, d))
        return false;
    for (const d of t.names)
      if (i(l, d))
        return true;
    return false;
  }
  function u(l) {
    return l instanceof Error ? l.stack || l.message : l;
  }
  function c() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  return t.enable(t.load()), t;
}
var Jw = Zw;
(function(r, e) {
  e.formatArgs = n, e.save = s, e.load = i, e.useColors = t, e.storage = o(), e.destroy = /* @__PURE__ */ (() => {
    let u = false;
    return () => {
      u || (u = true, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
    };
  })(), e.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function t() {
    if (typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs))
      return true;
    if (typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))
      return false;
    let u;
    return typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator < "u" && navigator.userAgent && (u = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(u[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function n(u) {
    if (u[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + u[0] + (this.useColors ? "%c " : " ") + "+" + r.exports.humanize(this.diff), !this.useColors)
      return;
    const c = "color: " + this.color;
    u.splice(1, 0, c, "color: inherit");
    let l = 0, d = 0;
    u[0].replace(/%[a-zA-Z%]/g, (h) => {
      h !== "%%" && (l++, h === "%c" && (d = l));
    }), u.splice(d, 0, c);
  }
  e.log = console.debug || console.log || (() => {
  });
  function s(u) {
    try {
      u ? e.storage.setItem("debug", u) : e.storage.removeItem("debug");
    } catch {
    }
  }
  function i() {
    let u;
    try {
      u = e.storage.getItem("debug") || e.storage.getItem("DEBUG");
    } catch {
    }
    return !u && typeof process < "u" && "env" in process && (u = process.env.DEBUG), u;
  }
  function o() {
    try {
      return localStorage;
    } catch {
    }
  }
  r.exports = Jw(e);
  const { formatters: a } = r.exports;
  a.j = function(u) {
    try {
      return JSON.stringify(u);
    } catch (c) {
      return "[UnexpectedJSONParseError]: " + c.message;
    }
  };
})(nu, nu.exports);
var oi = nu.exports;
var Hi = {};
var iu = { exports: {} };
(function(r, e) {
  (function(t) {
    function n(s) {
      var i = s && s.Promise || t.Promise, o = s && s.XMLHttpRequest || t.XMLHttpRequest;
      return function() {
        var a = Object.create(t, {
          fetch: {
            value: void 0,
            writable: true
          }
        });
        return function(u, c) {
          c(e);
        }(this, function(u) {
          var c = typeof a < "u" && a || typeof self < "u" && self || typeof c < "u" && c, l = {
            searchParams: "URLSearchParams" in c,
            iterable: "Symbol" in c && "iterator" in Symbol,
            blob: "FileReader" in c && "Blob" in c && function() {
              try {
                return new Blob(), true;
              } catch {
                return false;
              }
            }(),
            formData: "FormData" in c,
            arrayBuffer: "ArrayBuffer" in c
          };
          function d(y) {
            return y && DataView.prototype.isPrototypeOf(y);
          }
          if (l.arrayBuffer)
            var h = [
              "[object Int8Array]",
              "[object Uint8Array]",
              "[object Uint8ClampedArray]",
              "[object Int16Array]",
              "[object Uint16Array]",
              "[object Int32Array]",
              "[object Uint32Array]",
              "[object Float32Array]",
              "[object Float64Array]"
            ], f = ArrayBuffer.isView || function(y) {
              return y && h.indexOf(Object.prototype.toString.call(y)) > -1;
            };
          function g(y) {
            if (typeof y != "string" && (y = String(y)), /[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(y) || y === "")
              throw new TypeError("Invalid character in header field name");
            return y.toLowerCase();
          }
          function p(y) {
            return typeof y != "string" && (y = String(y)), y;
          }
          function b(y) {
            var m = {
              next: function() {
                var N = y.shift();
                return { done: N === void 0, value: N };
              }
            };
            return l.iterable && (m[Symbol.iterator] = function() {
              return m;
            }), m;
          }
          function _(y) {
            this.map = {}, y instanceof _ ? y.forEach(function(m, N) {
              this.append(N, m);
            }, this) : Array.isArray(y) ? y.forEach(function(m) {
              this.append(m[0], m[1]);
            }, this) : y && Object.getOwnPropertyNames(y).forEach(function(m) {
              this.append(m, y[m]);
            }, this);
          }
          _.prototype.append = function(y, m) {
            y = g(y), m = p(m);
            var N = this.map[y];
            this.map[y] = N ? N + ", " + m : m;
          }, _.prototype.delete = function(y) {
            delete this.map[g(y)];
          }, _.prototype.get = function(y) {
            return y = g(y), this.has(y) ? this.map[y] : null;
          }, _.prototype.has = function(y) {
            return this.map.hasOwnProperty(g(y));
          }, _.prototype.set = function(y, m) {
            this.map[g(y)] = p(m);
          }, _.prototype.forEach = function(y, m) {
            for (var N in this.map)
              this.map.hasOwnProperty(N) && y.call(m, this.map[N], N, this);
          }, _.prototype.keys = function() {
            var y = [];
            return this.forEach(function(m, N) {
              y.push(N);
            }), b(y);
          }, _.prototype.values = function() {
            var y = [];
            return this.forEach(function(m) {
              y.push(m);
            }), b(y);
          }, _.prototype.entries = function() {
            var y = [];
            return this.forEach(function(m, N) {
              y.push([N, m]);
            }), b(y);
          }, l.iterable && (_.prototype[Symbol.iterator] = _.prototype.entries);
          function D(y) {
            if (y.bodyUsed)
              return i.reject(new TypeError("Already read"));
            y.bodyUsed = true;
          }
          function v(y) {
            return new i(function(m, N) {
              y.onload = function() {
                m(y.result);
              }, y.onerror = function() {
                N(y.error);
              };
            });
          }
          function E(y) {
            var m = new FileReader(), N = v(m);
            return m.readAsArrayBuffer(y), N;
          }
          function A(y) {
            var m = new FileReader(), N = v(m);
            return m.readAsText(y), N;
          }
          function k(y) {
            for (var m = new Uint8Array(y), N = new Array(m.length), T = 0; T < m.length; T++)
              N[T] = String.fromCharCode(m[T]);
            return N.join("");
          }
          function U(y) {
            if (y.slice)
              return y.slice(0);
            var m = new Uint8Array(y.byteLength);
            return m.set(new Uint8Array(y)), m.buffer;
          }
          function P() {
            return this.bodyUsed = false, this._initBody = function(y) {
              this.bodyUsed = this.bodyUsed, this._bodyInit = y, y ? typeof y == "string" ? this._bodyText = y : l.blob && Blob.prototype.isPrototypeOf(y) ? this._bodyBlob = y : l.formData && FormData.prototype.isPrototypeOf(y) ? this._bodyFormData = y : l.searchParams && URLSearchParams.prototype.isPrototypeOf(y) ? this._bodyText = y.toString() : l.arrayBuffer && l.blob && d(y) ? (this._bodyArrayBuffer = U(y.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : l.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(y) || f(y)) ? this._bodyArrayBuffer = U(y) : this._bodyText = y = Object.prototype.toString.call(y) : this._bodyText = "", this.headers.get("content-type") || (typeof y == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : l.searchParams && URLSearchParams.prototype.isPrototypeOf(y) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"));
            }, l.blob && (this.blob = function() {
              var y = D(this);
              if (y)
                return y;
              if (this._bodyBlob)
                return i.resolve(this._bodyBlob);
              if (this._bodyArrayBuffer)
                return i.resolve(new Blob([this._bodyArrayBuffer]));
              if (this._bodyFormData)
                throw new Error("could not read FormData body as blob");
              return i.resolve(new Blob([this._bodyText]));
            }, this.arrayBuffer = function() {
              if (this._bodyArrayBuffer) {
                var y = D(this);
                return y || (ArrayBuffer.isView(this._bodyArrayBuffer) ? i.resolve(
                  this._bodyArrayBuffer.buffer.slice(
                    this._bodyArrayBuffer.byteOffset,
                    this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
                  )
                ) : i.resolve(this._bodyArrayBuffer));
              } else
                return this.blob().then(E);
            }), this.text = function() {
              var y = D(this);
              if (y)
                return y;
              if (this._bodyBlob)
                return A(this._bodyBlob);
              if (this._bodyArrayBuffer)
                return i.resolve(k(this._bodyArrayBuffer));
              if (this._bodyFormData)
                throw new Error("could not read FormData body as text");
              return i.resolve(this._bodyText);
            }, l.formData && (this.formData = function() {
              return this.text().then(H);
            }), this.json = function() {
              return this.text().then(JSON.parse);
            }, this;
          }
          var $ = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
          function ee(y) {
            var m = y.toUpperCase();
            return $.indexOf(m) > -1 ? m : y;
          }
          function G(y, m) {
            if (!(this instanceof G))
              throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
            m = m || {};
            var N = m.body;
            if (y instanceof G) {
              if (y.bodyUsed)
                throw new TypeError("Already read");
              this.url = y.url, this.credentials = y.credentials, m.headers || (this.headers = new _(y.headers)), this.method = y.method, this.mode = y.mode, this.signal = y.signal, !N && y._bodyInit != null && (N = y._bodyInit, y.bodyUsed = true);
            } else
              this.url = String(y);
            if (this.credentials = m.credentials || this.credentials || "same-origin", (m.headers || !this.headers) && (this.headers = new _(m.headers)), this.method = ee(m.method || this.method || "GET"), this.mode = m.mode || this.mode || null, this.signal = m.signal || this.signal, this.referrer = null, (this.method === "GET" || this.method === "HEAD") && N)
              throw new TypeError("Body not allowed for GET or HEAD requests");
            if (this._initBody(N), (this.method === "GET" || this.method === "HEAD") && (m.cache === "no-store" || m.cache === "no-cache")) {
              var T = /([?&])_=[^&]*/;
              if (T.test(this.url))
                this.url = this.url.replace(T, "$1_=" + (/* @__PURE__ */ new Date()).getTime());
              else {
                var x = /\?/;
                this.url += (x.test(this.url) ? "&" : "?") + "_=" + (/* @__PURE__ */ new Date()).getTime();
              }
            }
          }
          G.prototype.clone = function() {
            return new G(this, { body: this._bodyInit });
          };
          function H(y) {
            var m = new FormData();
            return y.trim().split("&").forEach(function(N) {
              if (N) {
                var T = N.split("="), x = T.shift().replace(/\+/g, " "), L = T.join("=").replace(/\+/g, " ");
                m.append(decodeURIComponent(x), decodeURIComponent(L));
              }
            }), m;
          }
          function R(y) {
            var m = new _(), N = y.replace(/\r?\n[\t ]+/g, " ");
            return N.split("\r").map(function(T) {
              return T.indexOf(`
`) === 0 ? T.substr(1, T.length) : T;
            }).forEach(function(T) {
              var x = T.split(":"), L = x.shift().trim();
              if (L) {
                var V = x.join(":").trim();
                m.append(L, V);
              }
            }), m;
          }
          P.call(G.prototype);
          function z(y, m) {
            if (!(this instanceof z))
              throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
            m || (m = {}), this.type = "default", this.status = m.status === void 0 ? 200 : m.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = "statusText" in m ? m.statusText : "", this.headers = new _(m.headers), this.url = m.url || "", this._initBody(y);
          }
          P.call(z.prototype), z.prototype.clone = function() {
            return new z(this._bodyInit, {
              status: this.status,
              statusText: this.statusText,
              headers: new _(this.headers),
              url: this.url
            });
          }, z.error = function() {
            var y = new z(null, { status: 0, statusText: "" });
            return y.type = "error", y;
          };
          var j = [301, 302, 303, 307, 308];
          z.redirect = function(y, m) {
            if (j.indexOf(m) === -1)
              throw new RangeError("Invalid status code");
            return new z(null, { status: m, headers: { location: y } });
          }, u.DOMException = c.DOMException;
          try {
            new u.DOMException();
          } catch {
            u.DOMException = function(m, N) {
              this.message = m, this.name = N;
              var T = Error(m);
              this.stack = T.stack;
            }, u.DOMException.prototype = Object.create(Error.prototype), u.DOMException.prototype.constructor = u.DOMException;
          }
          function I(y, m) {
            return new i(function(N, T) {
              var x = new G(y, m);
              if (x.signal && x.signal.aborted)
                return T(new u.DOMException("Aborted", "AbortError"));
              var L = new o();
              function V() {
                L.abort();
              }
              L.onload = function() {
                var K = {
                  status: L.status,
                  statusText: L.statusText,
                  headers: R(L.getAllResponseHeaders() || "")
                };
                K.url = "responseURL" in L ? L.responseURL : K.headers.get("X-Request-URL");
                var Z = "response" in L ? L.response : L.responseText;
                setTimeout(function() {
                  N(new z(Z, K));
                }, 0);
              }, L.onerror = function() {
                setTimeout(function() {
                  T(new TypeError("Network request failed"));
                }, 0);
              }, L.ontimeout = function() {
                setTimeout(function() {
                  T(new TypeError("Network request failed"));
                }, 0);
              }, L.onabort = function() {
                setTimeout(function() {
                  T(new u.DOMException("Aborted", "AbortError"));
                }, 0);
              };
              function q(K) {
                try {
                  return K === "" && c.location.href ? c.location.href : K;
                } catch {
                  return K;
                }
              }
              L.open(x.method, q(x.url), true), x.credentials === "include" ? L.withCredentials = true : x.credentials === "omit" && (L.withCredentials = false), "responseType" in L && (l.blob ? L.responseType = "blob" : l.arrayBuffer && x.headers.get("Content-Type") && x.headers.get("Content-Type").indexOf("application/octet-stream") !== -1 && (L.responseType = "arraybuffer")), m && typeof m.headers == "object" && !(m.headers instanceof _) ? Object.getOwnPropertyNames(m.headers).forEach(function(K) {
                L.setRequestHeader(K, p(m.headers[K]));
              }) : x.headers.forEach(function(K, Z) {
                L.setRequestHeader(Z, K);
              }), x.signal && (x.signal.addEventListener("abort", V), L.onreadystatechange = function() {
                L.readyState === 4 && x.signal.removeEventListener("abort", V);
              }), L.send(typeof x._bodyInit > "u" ? null : x._bodyInit);
            });
          }
          I.polyfill = true, c.fetch || (c.fetch = I, c.Headers = _, c.Request = G, c.Response = z), u.Headers = _, u.Request = G, u.Response = z, u.fetch = I, Object.defineProperty(u, "__esModule", { value: true });
        }), {
          fetch: a.fetch,
          Headers: a.Headers,
          Request: a.Request,
          Response: a.Response,
          DOMException: a.DOMException
        };
      }();
    }
    r.exports = n;
  })(typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : B);
})(iu, iu.exports);
var e1 = iu.exports;
var yt = {};
yt.endianness = function() {
  return "LE";
};
yt.hostname = function() {
  return typeof location < "u" ? location.hostname : "";
};
yt.loadavg = function() {
  return [];
};
yt.uptime = function() {
  return 0;
};
yt.freemem = function() {
  return Number.MAX_VALUE;
};
yt.totalmem = function() {
  return Number.MAX_VALUE;
};
yt.cpus = function() {
  return [];
};
yt.type = function() {
  return "Browser";
};
yt.release = function() {
  return typeof navigator < "u" ? navigator.appVersion : "";
};
yt.networkInterfaces = yt.getNetworkInterfaces = function() {
  return {};
};
yt.arch = function() {
  return "javascript";
};
yt.platform = function() {
  return "browser";
};
yt.tmpdir = yt.tmpDir = function() {
  return "/tmp";
};
yt.EOL = `
`;
yt.homedir = function() {
  return "/";
};
var vr = {};
Object.defineProperty(vr, "__esModule", { value: true });
vr.DeferredPromise = vr.throwIfError = void 0;
function t1(r) {
  var e, t, n, s, i, o;
  if (r.message !== void 0)
    throw new Error(r.message);
  if (r.next === void 0 && ((t = (e = r) === null || e === void 0 ? void 0 : e.meta) === null || t === void 0 ? void 0 : t.uuid) === void 0 && ((s = (n = r) === null || n === void 0 ? void 0 : n.application) === null || s === void 0 ? void 0 : s.uuidv4) === void 0 && ((o = (i = r) === null || i === void 0 ? void 0 : i.error) === null || o === void 0 ? void 0 : o.code) !== void 0) {
    const c = r.error;
    throw new Error(`Error code ${c.code}, see XUMM Dev Console, reference: ${c.reference}`);
  }
}
vr.throwIfError = t1;
var r1 = class {
  constructor() {
    this.resolveFn = (e) => {
    }, this.rejectFn = (e) => {
    }, this.promise = new Promise((e, t) => {
      this.resolveFn = e, this.rejectFn = t;
    });
  }
  resolve(e) {
    return this.resolveFn(e), this.promise;
  }
  reject(e) {
    return this.rejectFn(e), this.promise;
  }
};
vr.DeferredPromise = r1;
var nd;
function n1() {
  if (nd) return Hi;
  nd = 1;
  var r = B && B.__awaiter || function(f, g, p, b) {
    function _(D) {
      return D instanceof p ? D : new p(function(v) {
        v(D);
      });
    }
    return new (p || (p = Promise))(function(D, v) {
      function E(U) {
        try {
          k(b.next(U));
        } catch (P) {
          v(P);
        }
      }
      function A(U) {
        try {
          k(b.throw(U));
        } catch (P) {
          v(P);
        }
      }
      function k(U) {
        U.done ? D(U.value) : _(U.value).then(E, A);
      }
      k((b = b.apply(f, g || [])).next());
    });
  }, e = B && B.__importDefault || function(f) {
    return f && f.__esModule ? f : { default: f };
  };
  Object.defineProperty(Hi, "__esModule", { value: true }), Hi.Meta = void 0;
  const t = oi, n = e(e1), { fetch: s, Request: i, Response: o, Headers: a } = n.default(), u = yt, c = vr, l = jo(), d = t.debug("xumm-sdk:meta");
  let h = class {
    constructor(g, p) {
      this.isBrowser = false, this.jwtFlow = false, this.injected = false, this.endpoint = "https://xumm.app", d("Constructed");
      const b = new RegExp("^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$"), _ = {
        split: p.split(":"),
        uuidv4: ""
      };
      if (_.split.length === 3 && _.split.slice(0, 2).join(":") === "xApp:OneTimeToken" ? (_.uuidv4 = _.split[2], this.jwtFlow = true) : _.split.length > 1 && _.split[0] === "RAWJWT" ? (this.jwtFlow = true, this.jwt = _.split.slice(1).join(":")) : _.uuidv4 = p, !b.test(g) || !b.test(_.uuidv4))
        if (this.jwtFlow) {
          if (!this.jwt)
            throw new Error("Invalid API Key and/or OTT (One Time Token). Provide OTT param (2nd param) or make sure `xAppToken` query param is present (Browser)");
        } else
          throw new Error("Invalid API Key and/or API Secret. Use dotenv or constructor params.");
      return typeof globalThis < "u" && Object.keys(globalThis).indexOf("window") < 0 ? d("Running in node") : (console.log("XUMM SDK: Running in browser"), this.isBrowser = true), this.apiKey = g, this.apiSecret = _.uuidv4, this.jwtFlow && !this.jwt && (this.authPromise = new Promise((D) => {
        this.authPromiseResolve = D;
      }), Promise.resolve().then(() => this.authorize()).catch((D) => {
        d("Authorize error:", D.message), !(this === null || this === void 0) && this.invoker && this.invoker.caught(D), this.authPromiseResolve && this.authPromiseResolve();
      })), this;
    }
    setEndpoint(g) {
      return g.match(/^http/) ? (this.endpoint = g.trim(), true) : false;
    }
    authorize() {
      var g, p, b, _;
      return r(this, void 0, void 0, function* () {
        d("JWT Authorize", this.apiSecret);
        let D;
        !(this === null || this === void 0) && this.invoker && this.invoker.constructor === l.XummSdkJwt && (D = this.invoker._jwtStore(this, (E) => this.jwt = E));
        const v = (D == null ? void 0 : D.get(this.apiSecret)) || (yield this.call("authorize"));
        if (!((p = (g = v) === null || g === void 0 ? void 0 : g.error) === null || p === void 0) && p.code)
          d("Could not resolve API Key & OTT to JWT (already fetched? Unauthorized?)"), !(this === null || this === void 0) && this.invoker && this.invoker.constructor === l.XummSdkJwt && (!((b = this === null || this === void 0 ? void 0 : this.invoker) === null || b === void 0) && b.fatalHandler) ? this.invoker.fatalHandler(new Error(v.error.reference)) : c.throwIfError(v);
        else if (!((_ = v) === null || _ === void 0) && _.jwt) {
          const E = v;
          D == null || D.set(this.apiSecret, E);
        } else
          throw new Error("Unexpected response for xApp JWT authorize request");
        this.authPromiseResolve && this.authPromiseResolve();
      });
    }
    call(g, p = "GET", b) {
      var _;
      return r(this, void 0, void 0, function* () {
        const D = p.toUpperCase(), v = g.split("/")[0];
        this.jwtFlow && !(!(this === null || this === void 0) && this.jwt) && this.authPromise && g !== "authorize" && (yield this.authPromise);
        try {
          let E;
          typeof b < "u" && (typeof b == "object" && b !== null && (E = JSON.stringify(b)), typeof b == "string" && (E = b));
          const A = {
            "Content-Type": "application/json"
          };
          this.isBrowser || Object.assign(A, {
            "User-Agent": `xumm-sdk/node (${u.hostname()}) node-fetch`
          }), this.jwtFlow ? g === "authorize" ? Object.assign(A, {
            "x-api-key": this.apiKey,
            "x-api-ott": this.apiSecret
          }) : Object.assign(A, {
            Authorization: "Bearer " + this.jwt
          }) : Object.assign(A, {
            "x-api-key": this.apiKey,
            "x-api-secret": this.apiSecret
          });
          const k = [
            "authorize",
            "ping",
            "curated-assets",
            "rates",
            "payload",
            "userdata",
            "xrpl-tx",
            "nftoken-detail",
            "rails",
            "hookhash"
          ], U = this.jwtFlow && k.indexOf(v) > -1 ? "jwt" : "platform";
          return yield (yield s(this.endpoint + "/api/v1/" + U + "/" + g, {
            method: D,
            body: E,
            headers: A
          })).json();
        } catch (E) {
          const A = new Error(`Unexpected response from XUMM API [${D}:${v}]`);
          throw A.stack = ((_ = E) === null || _ === void 0 ? void 0 : _.stack) || void 0, A;
        }
      });
    }
    ping() {
      var g, p;
      return r(this, void 0, void 0, function* () {
        const b = yield this.call("ping");
        if (c.throwIfError(b), typeof b.auth < "u")
          return b.auth;
        if (typeof ((g = b) === null || g === void 0 ? void 0 : g.ott_uuidv4) < "u")
          return {
            application: {
              uuidv4: b.app_uuidv4,
              name: b.app_name
            },
            jwtData: b
          };
        if (typeof ((p = b) === null || p === void 0 ? void 0 : p.usertoken_uuidv4) < "u")
          return {
            application: {
              uuidv4: b.client_id,
              name: b.app_name
            },
            jwtData: b
          };
        throw new Error("Unexpected response for ping request");
      });
    }
    getCuratedAssets() {
      return r(this, void 0, void 0, function* () {
        return yield this.call("curated-assets");
      });
    }
    getRates(g) {
      return r(this, void 0, void 0, function* () {
        return yield this.call("rates/" + g.trim().toUpperCase());
      });
    }
    getKycStatus(g) {
      return r(this, void 0, void 0, function* () {
        if (g.trim().match(/^r/)) {
          const p = yield this.call("kyc-status/" + g.trim());
          return p != null && p.kycApproved ? "SUCCESSFUL" : "NONE";
        } else {
          const p = yield this.call("kyc-status", "POST", {
            user_token: g
          });
          return (p == null ? void 0 : p.kycStatus) || "NONE";
        }
      });
    }
    getRails() {
      return r(this, void 0, void 0, function* () {
        return yield this.call("rails");
      });
    }
    getHookHash(g) {
      return r(this, void 0, void 0, function* () {
        if (typeof g == "string" && g.trim().match(/^[A-Fa-f0-9]{64}$/))
          return yield this.call("hookhash/" + g.trim());
        throw Error("Invalid Hook Hash (expecting 64 char hex)");
      });
    }
    getHookHashes() {
      return r(this, void 0, void 0, function* () {
        return yield this.call("hookhash");
      });
    }
    getTransaction(g) {
      return r(this, void 0, void 0, function* () {
        return yield this.call("xrpl-tx/" + g.trim());
      });
    }
    getNftokenDetail(g) {
      return r(this, void 0, void 0, function* () {
        if (!this.jwtFlow)
          throw new Error("getNftokenDetail: only available in JWT (XummSdkJwt) mode");
        return yield this.call("nftoken-detail/" + g.trim());
      });
    }
    verifyUserTokens(g) {
      return r(this, void 0, void 0, function* () {
        return (yield this.call("user-tokens", "POST", {
          tokens: Array.isArray(g) ? g : [g]
        })).tokens;
      });
    }
    // Internal
    _inject(g) {
      if (!this.injected)
        this.invoker = g;
      else
        throw new Error("Cannot `_inject` twice");
    }
  };
  return Hi.Meta = h, Hi;
}
var ia = {};
var tc = B && B.__awaiter || function(r, e, t, n) {
  function s(i) {
    return i instanceof t ? i : new t(function(o) {
      o(i);
    });
  }
  return new (t || (t = Promise))(function(i, o) {
    function a(l) {
      try {
        c(n.next(l));
      } catch (d) {
        o(d);
      }
    }
    function u(l) {
      try {
        c(n.throw(l));
      } catch (d) {
        o(d);
      }
    }
    function c(l) {
      l.done ? i(l.value) : s(l.value).then(a, u);
    }
    c((n = n.apply(r, e || [])).next());
  });
};
Object.defineProperty(ia, "__esModule", { value: true });
ia.Storage = void 0;
var i1 = oi;
var rc = vr;
var s1 = i1.debug("xumm-sdk:storage");
var o1 = class {
  constructor(e) {
    s1("Constructed"), this.Meta = e;
  }
  get() {
    return tc(this, void 0, void 0, function* () {
      const e = yield this.Meta.call("app-storage", "GET");
      return rc.throwIfError(e), e.data;
    });
  }
  set(e) {
    return tc(this, void 0, void 0, function* () {
      const t = yield this.Meta.call("app-storage", "POST", e);
      return rc.throwIfError(t), t.stored;
    });
  }
  delete() {
    return tc(this, void 0, void 0, function* () {
      const e = yield this.Meta.call("app-storage", "DELETE");
      return rc.throwIfError(e), e.stored;
    });
  }
};
ia.Storage = o1;
var sa = {};
var nc;
var id;
function a1() {
  if (id) return nc;
  id = 1;
  var r = function() {
    if (typeof self == "object" && self) return self;
    if (typeof window == "object" && window) return window;
    throw new Error("Unable to resolve global `this`");
  };
  return nc = function() {
    if (this) return this;
    if (typeof globalThis == "object" && globalThis) return globalThis;
    try {
      Object.defineProperty(Object.prototype, "__global__", {
        get: function() {
          return this;
        },
        configurable: true
      });
    } catch {
      return r();
    }
    try {
      return __global__ || r();
    } finally {
      delete Object.prototype.__global__;
    }
  }(), nc;
}
var qn;
if (typeof globalThis == "object")
  qn = globalThis;
else
  try {
    qn = a1();
  } catch {
  } finally {
    if (!qn && typeof window < "u" && (qn = window), !qn)
      throw new Error("Could not determine global this");
  }
var Ns = qn.WebSocket || qn.MozWebSocket;
function Ip(r, e) {
  var t;
  return e ? t = new Ns(r, e) : t = new Ns(r), t;
}
Ns && ["CONNECTING", "OPEN", "CLOSING", "CLOSED"].forEach(function(r) {
  Object.defineProperty(Ip, r, {
    get: function() {
      return Ns[r];
    }
  });
});
var c1 = {
  w3cwebsocket: Ns ? Ip : null
};
var tn = B && B.__awaiter || function(r, e, t, n) {
  function s(i) {
    return i instanceof t ? i : new t(function(o) {
      o(i);
    });
  }
  return new (t || (t = Promise))(function(i, o) {
    function a(l) {
      try {
        c(n.next(l));
      } catch (d) {
        o(d);
      }
    }
    function u(l) {
      try {
        c(n.throw(l));
      } catch (d) {
        o(d);
      }
    }
    function c(l) {
      l.done ? i(l.value) : s(l.value).then(a, u);
    }
    c((n = n.apply(r, e || [])).next());
  });
};
Object.defineProperty(sa, "__esModule", { value: true });
sa.Payload = void 0;
var _p = oi;
var u1 = c1;
var Gi = vr;
var l1 = _p.debug("xumm-sdk:payload");
var Er = _p.debug("xumm-sdk:payload:websocket");
var d1 = typeof jest < "u" ? 0 : 30;
var h1 = 2;
var f1 = 2;
var p1 = 10;
var g1 = class {
  constructor(e) {
    l1("Constructed"), this.Meta = e;
  }
  resolvePayload(e) {
    var t, n, s;
    return tn(this, void 0, void 0, function* () {
      if (typeof e == "string")
        return yield this.get(e, true);
      if (typeof ((t = e) === null || t === void 0 ? void 0 : t.uuid) < "u")
        return yield this.get(e.uuid, true);
      if (typeof ((s = (n = e) === null || n === void 0 ? void 0 : n.meta) === null || s === void 0 ? void 0 : s.uuid) < "u")
        return e;
      throw new Error("Could not resolve payload (not found)");
    });
  }
  create(e, t = false) {
    var n;
    return tn(this, void 0, void 0, function* () {
      const s = typeof e.TransactionType < "u" && typeof e.txjson > "u", i = yield this.Meta.call("payload", "POST", s ? { txjson: e } : e);
      return t && Gi.throwIfError(i), ((n = i) === null || n === void 0 ? void 0 : n.next) !== void 0 ? i : null;
    });
  }
  get(e, t = false) {
    var n, s;
    return tn(this, void 0, void 0, function* () {
      const i = typeof e == "string" ? e : e == null ? void 0 : e.uuid, o = yield this.Meta.call("payload/" + i, "GET");
      return t && Gi.throwIfError(o), ((s = (n = o) === null || n === void 0 ? void 0 : n.meta) === null || s === void 0 ? void 0 : s.uuid) !== void 0 ? o : null;
    });
  }
  subscribe(e, t) {
    return tn(this, void 0, void 0, function* () {
      const n = new Gi.DeferredPromise(), s = yield this.resolvePayload(e);
      if (s) {
        const i = "undefined";
        let o, a, u, c = 0;
        n.promise.then(() => {
          clearTimeout(a), clearTimeout(u), o.close(1e3);
        });
        const l = () => {
          var d, h;
          return o = typeof ((d = globalThis) === null || d === void 0 ? void 0 : d.MockedWebSocket) !== i && typeof jest !== i ? new ((h = globalThis) === null || h === void 0 ? void 0 : h.MockedWebSocket)("ws://xumm.local") : new u1.w3cwebsocket(this.Meta.endpoint.replace(/^http/, "ws") + "/sign/" + s.meta.uuid), o.onopen = () => {
            console.log(`Payload ${s.meta.uuid}: subscription active (WebSocket opened)`), a = setInterval(() => {
              Er("Send keepalive"), o.send('{"ping":true}');
            }, f1 * 1e3);
          }, o.onmessage = (f) => tn(this, void 0, void 0, function* () {
            c = 0;
            const g = f.data;
            let p;
            try {
              if (p = JSON.parse(g.toString()), p != null && p.message && p.message === "Right back at you!") {
                Er("Keepalive response"), clearTimeout(u), u = setTimeout(() => {
                  console.log(`WebSocket for ${s.meta.uuid} keepalive response timeout, assume dead... (Reconnect)`), o.close(1002, "Assume dead");
                }, p1 * 1e3);
                return;
              }
              if (p != null && p.signed || p != null && p.expired) {
                const b = yield this.resolvePayload(e);
                Object.assign(s, Object.assign({}, b));
              }
            } catch (b) {
              Er(`Payload ${s.meta.uuid}: Received message, unable to parse as JSON`, b);
            }
            if (p && t && typeof p.devapp_fetched > "u")
              try {
                const b = yield t({
                  uuid: s.meta.uuid,
                  data: p,
                  resolve(_) {
                    return tn(this, void 0, void 0, function* () {
                      yield n.resolve(_ || void 0);
                    });
                  },
                  payload: s
                });
                b !== void 0 && n.resolve(b);
              } catch (b) {
                Er(`Payload ${s.meta.uuid}: Callback exception`, b), console.log(`Payload ${s.meta.uuid}: Callback exception: ${b.message}`);
              }
          }), o.onclose = (f) => {
            Er("Closed [code]", f.code), Er("Closed [reason]", f.reason), Er("Closed [wasClean]", f.wasClean), clearInterval(a), clearTimeout(u), (f.code > 1e3 || f.wasClean === false) && (console.log(f), Er("Unhealthy disconnect, reconnecting...", f.code), c < d1 ? (c === 0 && console.log(`WebSocket for ${s.meta.uuid} lost, reconnecting...`), setTimeout(() => {
              c++, Er("# Reconnect"), typeof jest > "u" && (o = l());
            }, h1 * 1e3)) : typeof jest > "u" && console.log(`WebSocket for ${s.meta.uuid} exceeded reconnect timeouts, give up`)), Er(`Payload ${s.meta.uuid}: Subscription ended (WebSocket closed)`);
          }, o;
        };
        return o = l(), {
          payload: s,
          resolve(d) {
            n.resolve(d || void 0);
          },
          resolved: n.promise,
          websocket: o
        };
      }
      throw Gi.throwIfError(s), Error("Couldn't subscribe: couldn't fetch payload");
    });
  }
  cancel(e, t = false) {
    var n, s, i;
    return tn(this, void 0, void 0, function* () {
      const o = yield this.resolvePayload(e), a = yield this.Meta.call("payload/" + ((n = o == null ? void 0 : o.meta) === null || n === void 0 ? void 0 : n.uuid), "DELETE");
      return t && Gi.throwIfError(a), ((i = (s = a) === null || s === void 0 ? void 0 : s.meta) === null || i === void 0 ? void 0 : i.uuid) !== void 0 ? a : null;
    });
  }
  createAndSubscribe(e, t) {
    return tn(this, void 0, void 0, function* () {
      const n = yield this.create(e, true);
      if (n) {
        const s = yield this.subscribe(n, t);
        return Object.assign({ created: n }, s);
      }
      throw new Error("Error creating payload or subscribing to created payload");
    });
  }
};
sa.Payload = g1;
var oa = {};
var $i = {};
var Ws = B && B.__awaiter || function(r, e, t, n) {
  function s(i) {
    return i instanceof t ? i : new t(function(o) {
      o(i);
    });
  }
  return new (t || (t = Promise))(function(i, o) {
    function a(l) {
      try {
        c(n.next(l));
      } catch (d) {
        o(d);
      }
    }
    function u(l) {
      try {
        c(n.throw(l));
      } catch (d) {
        o(d);
      }
    }
    function c(l) {
      l.done ? i(l.value) : s(l.value).then(a, u);
    }
    c((n = n.apply(r, e || [])).next());
  });
};
Object.defineProperty($i, "__esModule", { value: true });
$i.JwtUserdata = void 0;
var y1 = oi;
var Ks = vr;
var w1 = y1.debug("xumm-sdk:xapp:userdata");
var ic = (r) => {
  if (!(typeof r == "string" && r.match(/^[a-z0-9]{3,}$/)))
    throw new Error("Invalid key, only a-z0-9 (min three chars) allowed: " + r);
};
var m1 = class {
  constructor(e) {
    w1("Constructed"), this.Meta = e;
  }
  list() {
    return Ws(this, void 0, void 0, function* () {
      const e = yield this.Meta.call("userdata", "GET");
      return Ks.throwIfError(e), e.keys;
    });
  }
  get(e) {
    var t;
    return Ws(this, void 0, void 0, function* () {
      const n = Array.isArray(e) ? e.join(",") : e;
      n.split(",").forEach((i) => ic(i));
      const s = yield this.Meta.call("userdata/" + n, "GET");
      return Ks.throwIfError(s), n.split(",").length > 1 ? s.data : ((t = s.data) === null || t === void 0 ? void 0 : t[n]) || {};
    });
  }
  delete(e) {
    return Ws(this, void 0, void 0, function* () {
      ic(e);
      const t = yield this.Meta.call("userdata/" + e, "DELETE");
      return Ks.throwIfError(t), t.persisted;
    });
  }
  set(e, t) {
    return Ws(this, void 0, void 0, function* () {
      ic(e);
      const n = yield this.Meta.call("userdata/" + e, "POST", t);
      return Ks.throwIfError(n), n.persisted;
    });
  }
};
$i.JwtUserdata = m1;
var b1 = B && B.__awaiter || function(r, e, t, n) {
  function s(i) {
    return i instanceof t ? i : new t(function(o) {
      o(i);
    });
  }
  return new (t || (t = Promise))(function(i, o) {
    function a(l) {
      try {
        c(n.next(l));
      } catch (d) {
        o(d);
      }
    }
    function u(l) {
      try {
        c(n.throw(l));
      } catch (d) {
        o(d);
      }
    }
    function c(l) {
      l.done ? i(l.value) : s(l.value).then(a, u);
    }
    c((n = n.apply(r, e || [])).next());
  });
};
Object.defineProperty(oa, "__esModule", { value: true });
oa.xApp = void 0;
var v1 = oi;
var M1 = $i;
var E1 = vr;
var N1 = v1.debug("xumm-sdk:xapp");
var x1 = class {
  constructor(e) {
    N1("Constructed"), this.Meta = e, this.userdata = new M1.JwtUserdata(e);
  }
  get(e) {
    return b1(this, void 0, void 0, function* () {
      const t = yield this.Meta.call("xapp/ott/" + e, "GET");
      return E1.throwIfError(t), t;
    });
  }
};
oa.xApp = x1;
var aa = {};
var sd = B && B.__awaiter || function(r, e, t, n) {
  function s(i) {
    return i instanceof t ? i : new t(function(o) {
      o(i);
    });
  }
  return new (t || (t = Promise))(function(i, o) {
    function a(l) {
      try {
        c(n.next(l));
      } catch (d) {
        o(d);
      }
    }
    function u(l) {
      try {
        c(n.throw(l));
      } catch (d) {
        o(d);
      }
    }
    function c(l) {
      l.done ? i(l.value) : s(l.value).then(a, u);
    }
    c((n = n.apply(r, e || [])).next());
  });
};
Object.defineProperty(aa, "__esModule", { value: true });
aa.Push = void 0;
var I1 = oi;
var _1 = $i;
var od = vr;
var D1 = I1.debug("xumm-sdk:xapp");
var T1 = class {
  constructor(e) {
    D1("Constructed"), this.Meta = e, this.userdata = new _1.JwtUserdata(e);
  }
  event(e) {
    return sd(this, void 0, void 0, function* () {
      const t = yield this.Meta.call("xapp/event", "POST", e);
      return od.throwIfError(t), t;
    });
  }
  notification(e) {
    return sd(this, void 0, void 0, function* () {
      const t = yield this.Meta.call("xapp/push", "POST", e);
      return od.throwIfError(t), t;
    });
  }
};
aa.Push = T1;
var tl = {};
var ca = {};
ca.byteLength = S1;
ca.toByteArray = C1;
ca.fromByteArray = k1;
var jr = [];
var ar = [];
var A1 = typeof Uint8Array < "u" ? Uint8Array : Array;
var sc = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (pi = 0, O1 = sc.length; pi < O1; ++pi)
  jr[pi] = sc[pi], ar[sc.charCodeAt(pi)] = pi;
var pi;
var O1;
ar[45] = 62;
ar[95] = 63;
function Dp(r) {
  var e = r.length;
  if (e % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var t = r.indexOf("=");
  t === -1 && (t = e);
  var n = t === e ? 0 : 4 - t % 4;
  return [t, n];
}
function S1(r) {
  var e = Dp(r), t = e[0], n = e[1];
  return (t + n) * 3 / 4 - n;
}
function j1(r, e, t) {
  return (e + t) * 3 / 4 - t;
}
function C1(r) {
  var e, t = Dp(r), n = t[0], s = t[1], i = new A1(j1(r, n, s)), o = 0, a = s > 0 ? n - 4 : n, u;
  for (u = 0; u < a; u += 4)
    e = ar[r.charCodeAt(u)] << 18 | ar[r.charCodeAt(u + 1)] << 12 | ar[r.charCodeAt(u + 2)] << 6 | ar[r.charCodeAt(u + 3)], i[o++] = e >> 16 & 255, i[o++] = e >> 8 & 255, i[o++] = e & 255;
  return s === 2 && (e = ar[r.charCodeAt(u)] << 2 | ar[r.charCodeAt(u + 1)] >> 4, i[o++] = e & 255), s === 1 && (e = ar[r.charCodeAt(u)] << 10 | ar[r.charCodeAt(u + 1)] << 4 | ar[r.charCodeAt(u + 2)] >> 2, i[o++] = e >> 8 & 255, i[o++] = e & 255), i;
}
function L1(r) {
  return jr[r >> 18 & 63] + jr[r >> 12 & 63] + jr[r >> 6 & 63] + jr[r & 63];
}
function z1(r, e, t) {
  for (var n, s = [], i = e; i < t; i += 3)
    n = (r[i] << 16 & 16711680) + (r[i + 1] << 8 & 65280) + (r[i + 2] & 255), s.push(L1(n));
  return s.join("");
}
function k1(r) {
  for (var e, t = r.length, n = t % 3, s = [], i = 16383, o = 0, a = t - n; o < a; o += i)
    s.push(z1(r, o, o + i > a ? a : o + i));
  return n === 1 ? (e = r[t - 1], s.push(
    jr[e >> 2] + jr[e << 4 & 63] + "=="
  )) : n === 2 && (e = (r[t - 2] << 8) + r[t - 1], s.push(
    jr[e >> 10] + jr[e >> 4 & 63] + jr[e << 2 & 63] + "="
  )), s.join("");
}
var rl = {};
rl.read = function(r, e, t, n, s) {
  var i, o, a = s * 8 - n - 1, u = (1 << a) - 1, c = u >> 1, l = -7, d = t ? s - 1 : 0, h = t ? -1 : 1, f = r[e + d];
  for (d += h, i = f & (1 << -l) - 1, f >>= -l, l += a; l > 0; i = i * 256 + r[e + d], d += h, l -= 8)
    ;
  for (o = i & (1 << -l) - 1, i >>= -l, l += n; l > 0; o = o * 256 + r[e + d], d += h, l -= 8)
    ;
  if (i === 0)
    i = 1 - c;
  else {
    if (i === u)
      return o ? NaN : (f ? -1 : 1) * (1 / 0);
    o = o + Math.pow(2, n), i = i - c;
  }
  return (f ? -1 : 1) * o * Math.pow(2, i - n);
};
rl.write = function(r, e, t, n, s, i) {
  var o, a, u, c = i * 8 - s - 1, l = (1 << c) - 1, d = l >> 1, h = s === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f = n ? 0 : i - 1, g = n ? 1 : -1, p = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
  for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (a = isNaN(e) ? 1 : 0, o = l) : (o = Math.floor(Math.log(e) / Math.LN2), e * (u = Math.pow(2, -o)) < 1 && (o--, u *= 2), o + d >= 1 ? e += h / u : e += h * Math.pow(2, 1 - d), e * u >= 2 && (o++, u /= 2), o + d >= l ? (a = 0, o = l) : o + d >= 1 ? (a = (e * u - 1) * Math.pow(2, s), o = o + d) : (a = e * Math.pow(2, d - 1) * Math.pow(2, s), o = 0)); s >= 8; r[t + f] = a & 255, f += g, a /= 256, s -= 8)
    ;
  for (o = o << s | a, c += s; c > 0; r[t + f] = o & 255, f += g, o /= 256, c -= 8)
    ;
  r[t + f - g] |= p * 128;
};
(function(r) {
  const e = ca, t = rl, n = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  r.Buffer = a, r.SlowBuffer = D, r.INSPECT_MAX_BYTES = 50;
  const s = 2147483647;
  r.kMaxLength = s, a.TYPED_ARRAY_SUPPORT = i(), !a.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function i() {
    try {
      const O = new Uint8Array(1), w = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(w, Uint8Array.prototype), Object.setPrototypeOf(O, w), O.foo() === 42;
    } catch {
      return false;
    }
  }
  Object.defineProperty(a.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (a.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(a.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (a.isBuffer(this))
        return this.byteOffset;
    }
  });
  function o(O) {
    if (O > s)
      throw new RangeError('The value "' + O + '" is invalid for option "size"');
    const w = new Uint8Array(O);
    return Object.setPrototypeOf(w, a.prototype), w;
  }
  function a(O, w, M) {
    if (typeof O == "number") {
      if (typeof w == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return d(O);
    }
    return u(O, w, M);
  }
  a.poolSize = 8192;
  function u(O, w, M) {
    if (typeof O == "string")
      return h(O, w);
    if (ArrayBuffer.isView(O))
      return g(O);
    if (O == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof O
      );
    if (Me(O, ArrayBuffer) || O && Me(O.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (Me(O, SharedArrayBuffer) || O && Me(O.buffer, SharedArrayBuffer)))
      return p(O, w, M);
    if (typeof O == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const C = O.valueOf && O.valueOf();
    if (C != null && C !== O)
      return a.from(C, w, M);
    const F = b(O);
    if (F) return F;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof O[Symbol.toPrimitive] == "function")
      return a.from(O[Symbol.toPrimitive]("string"), w, M);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof O
    );
  }
  a.from = function(O, w, M) {
    return u(O, w, M);
  }, Object.setPrototypeOf(a.prototype, Uint8Array.prototype), Object.setPrototypeOf(a, Uint8Array);
  function c(O) {
    if (typeof O != "number")
      throw new TypeError('"size" argument must be of type number');
    if (O < 0)
      throw new RangeError('The value "' + O + '" is invalid for option "size"');
  }
  function l(O, w, M) {
    return c(O), O <= 0 ? o(O) : w !== void 0 ? typeof M == "string" ? o(O).fill(w, M) : o(O).fill(w) : o(O);
  }
  a.alloc = function(O, w, M) {
    return l(O, w, M);
  };
  function d(O) {
    return c(O), o(O < 0 ? 0 : _(O) | 0);
  }
  a.allocUnsafe = function(O) {
    return d(O);
  }, a.allocUnsafeSlow = function(O) {
    return d(O);
  };
  function h(O, w) {
    if ((typeof w != "string" || w === "") && (w = "utf8"), !a.isEncoding(w))
      throw new TypeError("Unknown encoding: " + w);
    const M = v(O, w) | 0;
    let C = o(M);
    const F = C.write(O, w);
    return F !== M && (C = C.slice(0, F)), C;
  }
  function f(O) {
    const w = O.length < 0 ? 0 : _(O.length) | 0, M = o(w);
    for (let C = 0; C < w; C += 1)
      M[C] = O[C] & 255;
    return M;
  }
  function g(O) {
    if (Me(O, Uint8Array)) {
      const w = new Uint8Array(O);
      return p(w.buffer, w.byteOffset, w.byteLength);
    }
    return f(O);
  }
  function p(O, w, M) {
    if (w < 0 || O.byteLength < w)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (O.byteLength < w + (M || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let C;
    return w === void 0 && M === void 0 ? C = new Uint8Array(O) : M === void 0 ? C = new Uint8Array(O, w) : C = new Uint8Array(O, w, M), Object.setPrototypeOf(C, a.prototype), C;
  }
  function b(O) {
    if (a.isBuffer(O)) {
      const w = _(O.length) | 0, M = o(w);
      return M.length === 0 || O.copy(M, 0, 0, w), M;
    }
    if (O.length !== void 0)
      return typeof O.length != "number" || Ve(O.length) ? o(0) : f(O);
    if (O.type === "Buffer" && Array.isArray(O.data))
      return f(O.data);
  }
  function _(O) {
    if (O >= s)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + s.toString(16) + " bytes");
    return O | 0;
  }
  function D(O) {
    return +O != O && (O = 0), a.alloc(+O);
  }
  a.isBuffer = function(w) {
    return w != null && w._isBuffer === true && w !== a.prototype;
  }, a.compare = function(w, M) {
    if (Me(w, Uint8Array) && (w = a.from(w, w.offset, w.byteLength)), Me(M, Uint8Array) && (M = a.from(M, M.offset, M.byteLength)), !a.isBuffer(w) || !a.isBuffer(M))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (w === M) return 0;
    let C = w.length, F = M.length;
    for (let W = 0, te = Math.min(C, F); W < te; ++W)
      if (w[W] !== M[W]) {
        C = w[W], F = M[W];
        break;
      }
    return C < F ? -1 : F < C ? 1 : 0;
  }, a.isEncoding = function(w) {
    switch (String(w).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  }, a.concat = function(w, M) {
    if (!Array.isArray(w))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (w.length === 0)
      return a.alloc(0);
    let C;
    if (M === void 0)
      for (M = 0, C = 0; C < w.length; ++C)
        M += w[C].length;
    const F = a.allocUnsafe(M);
    let W = 0;
    for (C = 0; C < w.length; ++C) {
      let te = w[C];
      if (Me(te, Uint8Array))
        W + te.length > F.length ? (a.isBuffer(te) || (te = a.from(te)), te.copy(F, W)) : Uint8Array.prototype.set.call(
          F,
          te,
          W
        );
      else if (a.isBuffer(te))
        te.copy(F, W);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      W += te.length;
    }
    return F;
  };
  function v(O, w) {
    if (a.isBuffer(O))
      return O.length;
    if (ArrayBuffer.isView(O) || Me(O, ArrayBuffer))
      return O.byteLength;
    if (typeof O != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof O
      );
    const M = O.length, C = arguments.length > 2 && arguments[2] === true;
    if (!C && M === 0) return 0;
    let F = false;
    for (; ; )
      switch (w) {
        case "ascii":
        case "latin1":
        case "binary":
          return M;
        case "utf8":
        case "utf-8":
          return fe(O).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return M * 2;
        case "hex":
          return M >>> 1;
        case "base64":
          return Ie(O).length;
        default:
          if (F)
            return C ? -1 : fe(O).length;
          w = ("" + w).toLowerCase(), F = true;
      }
  }
  a.byteLength = v;
  function E(O, w, M) {
    let C = false;
    if ((w === void 0 || w < 0) && (w = 0), w > this.length || ((M === void 0 || M > this.length) && (M = this.length), M <= 0) || (M >>>= 0, w >>>= 0, M <= w))
      return "";
    for (O || (O = "utf8"); ; )
      switch (O) {
        case "hex":
          return N(this, w, M);
        case "utf8":
        case "utf-8":
          return z(this, w, M);
        case "ascii":
          return y(this, w, M);
        case "latin1":
        case "binary":
          return m(this, w, M);
        case "base64":
          return R(this, w, M);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return T(this, w, M);
        default:
          if (C) throw new TypeError("Unknown encoding: " + O);
          O = (O + "").toLowerCase(), C = true;
      }
  }
  a.prototype._isBuffer = true;
  function A(O, w, M) {
    const C = O[w];
    O[w] = O[M], O[M] = C;
  }
  a.prototype.swap16 = function() {
    const w = this.length;
    if (w % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let M = 0; M < w; M += 2)
      A(this, M, M + 1);
    return this;
  }, a.prototype.swap32 = function() {
    const w = this.length;
    if (w % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let M = 0; M < w; M += 4)
      A(this, M, M + 3), A(this, M + 1, M + 2);
    return this;
  }, a.prototype.swap64 = function() {
    const w = this.length;
    if (w % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let M = 0; M < w; M += 8)
      A(this, M, M + 7), A(this, M + 1, M + 6), A(this, M + 2, M + 5), A(this, M + 3, M + 4);
    return this;
  }, a.prototype.toString = function() {
    const w = this.length;
    return w === 0 ? "" : arguments.length === 0 ? z(this, 0, w) : E.apply(this, arguments);
  }, a.prototype.toLocaleString = a.prototype.toString, a.prototype.equals = function(w) {
    if (!a.isBuffer(w)) throw new TypeError("Argument must be a Buffer");
    return this === w ? true : a.compare(this, w) === 0;
  }, a.prototype.inspect = function() {
    let w = "";
    const M = r.INSPECT_MAX_BYTES;
    return w = this.toString("hex", 0, M).replace(/(.{2})/g, "$1 ").trim(), this.length > M && (w += " ... "), "<Buffer " + w + ">";
  }, n && (a.prototype[n] = a.prototype.inspect), a.prototype.compare = function(w, M, C, F, W) {
    if (Me(w, Uint8Array) && (w = a.from(w, w.offset, w.byteLength)), !a.isBuffer(w))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof w
      );
    if (M === void 0 && (M = 0), C === void 0 && (C = w ? w.length : 0), F === void 0 && (F = 0), W === void 0 && (W = this.length), M < 0 || C > w.length || F < 0 || W > this.length)
      throw new RangeError("out of range index");
    if (F >= W && M >= C)
      return 0;
    if (F >= W)
      return -1;
    if (M >= C)
      return 1;
    if (M >>>= 0, C >>>= 0, F >>>= 0, W >>>= 0, this === w) return 0;
    let te = W - F, be = C - M;
    const ke = Math.min(te, be), De = this.slice(F, W), Ze = w.slice(M, C);
    for (let Be = 0; Be < ke; ++Be)
      if (De[Be] !== Ze[Be]) {
        te = De[Be], be = Ze[Be];
        break;
      }
    return te < be ? -1 : be < te ? 1 : 0;
  };
  function k(O, w, M, C, F) {
    if (O.length === 0) return -1;
    if (typeof M == "string" ? (C = M, M = 0) : M > 2147483647 ? M = 2147483647 : M < -2147483648 && (M = -2147483648), M = +M, Ve(M) && (M = F ? 0 : O.length - 1), M < 0 && (M = O.length + M), M >= O.length) {
      if (F) return -1;
      M = O.length - 1;
    } else if (M < 0)
      if (F) M = 0;
      else return -1;
    if (typeof w == "string" && (w = a.from(w, C)), a.isBuffer(w))
      return w.length === 0 ? -1 : U(O, w, M, C, F);
    if (typeof w == "number")
      return w = w & 255, typeof Uint8Array.prototype.indexOf == "function" ? F ? Uint8Array.prototype.indexOf.call(O, w, M) : Uint8Array.prototype.lastIndexOf.call(O, w, M) : U(O, [w], M, C, F);
    throw new TypeError("val must be string, number or Buffer");
  }
  function U(O, w, M, C, F) {
    let W = 1, te = O.length, be = w.length;
    if (C !== void 0 && (C = String(C).toLowerCase(), C === "ucs2" || C === "ucs-2" || C === "utf16le" || C === "utf-16le")) {
      if (O.length < 2 || w.length < 2)
        return -1;
      W = 2, te /= 2, be /= 2, M /= 2;
    }
    function ke(Ze, Be) {
      return W === 1 ? Ze[Be] : Ze.readUInt16BE(Be * W);
    }
    let De;
    if (F) {
      let Ze = -1;
      for (De = M; De < te; De++)
        if (ke(O, De) === ke(w, Ze === -1 ? 0 : De - Ze)) {
          if (Ze === -1 && (Ze = De), De - Ze + 1 === be) return Ze * W;
        } else
          Ze !== -1 && (De -= De - Ze), Ze = -1;
    } else
      for (M + be > te && (M = te - be), De = M; De >= 0; De--) {
        let Ze = true;
        for (let Be = 0; Be < be; Be++)
          if (ke(O, De + Be) !== ke(w, Be)) {
            Ze = false;
            break;
          }
        if (Ze) return De;
      }
    return -1;
  }
  a.prototype.includes = function(w, M, C) {
    return this.indexOf(w, M, C) !== -1;
  }, a.prototype.indexOf = function(w, M, C) {
    return k(this, w, M, C, true);
  }, a.prototype.lastIndexOf = function(w, M, C) {
    return k(this, w, M, C, false);
  };
  function P(O, w, M, C) {
    M = Number(M) || 0;
    const F = O.length - M;
    C ? (C = Number(C), C > F && (C = F)) : C = F;
    const W = w.length;
    C > W / 2 && (C = W / 2);
    let te;
    for (te = 0; te < C; ++te) {
      const be = parseInt(w.substr(te * 2, 2), 16);
      if (Ve(be)) return te;
      O[M + te] = be;
    }
    return te;
  }
  function $(O, w, M, C) {
    return Ee(fe(w, O.length - M), O, M, C);
  }
  function ee(O, w, M, C) {
    return Ee(ye(w), O, M, C);
  }
  function G(O, w, M, C) {
    return Ee(Ie(w), O, M, C);
  }
  function H(O, w, M, C) {
    return Ee(we(w, O.length - M), O, M, C);
  }
  a.prototype.write = function(w, M, C, F) {
    if (M === void 0)
      F = "utf8", C = this.length, M = 0;
    else if (C === void 0 && typeof M == "string")
      F = M, C = this.length, M = 0;
    else if (isFinite(M))
      M = M >>> 0, isFinite(C) ? (C = C >>> 0, F === void 0 && (F = "utf8")) : (F = C, C = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const W = this.length - M;
    if ((C === void 0 || C > W) && (C = W), w.length > 0 && (C < 0 || M < 0) || M > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    F || (F = "utf8");
    let te = false;
    for (; ; )
      switch (F) {
        case "hex":
          return P(this, w, M, C);
        case "utf8":
        case "utf-8":
          return $(this, w, M, C);
        case "ascii":
        case "latin1":
        case "binary":
          return ee(this, w, M, C);
        case "base64":
          return G(this, w, M, C);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return H(this, w, M, C);
        default:
          if (te) throw new TypeError("Unknown encoding: " + F);
          F = ("" + F).toLowerCase(), te = true;
      }
  }, a.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function R(O, w, M) {
    return w === 0 && M === O.length ? e.fromByteArray(O) : e.fromByteArray(O.slice(w, M));
  }
  function z(O, w, M) {
    M = Math.min(O.length, M);
    const C = [];
    let F = w;
    for (; F < M; ) {
      const W = O[F];
      let te = null, be = W > 239 ? 4 : W > 223 ? 3 : W > 191 ? 2 : 1;
      if (F + be <= M) {
        let ke, De, Ze, Be;
        switch (be) {
          case 1:
            W < 128 && (te = W);
            break;
          case 2:
            ke = O[F + 1], (ke & 192) === 128 && (Be = (W & 31) << 6 | ke & 63, Be > 127 && (te = Be));
            break;
          case 3:
            ke = O[F + 1], De = O[F + 2], (ke & 192) === 128 && (De & 192) === 128 && (Be = (W & 15) << 12 | (ke & 63) << 6 | De & 63, Be > 2047 && (Be < 55296 || Be > 57343) && (te = Be));
            break;
          case 4:
            ke = O[F + 1], De = O[F + 2], Ze = O[F + 3], (ke & 192) === 128 && (De & 192) === 128 && (Ze & 192) === 128 && (Be = (W & 15) << 18 | (ke & 63) << 12 | (De & 63) << 6 | Ze & 63, Be > 65535 && Be < 1114112 && (te = Be));
        }
      }
      te === null ? (te = 65533, be = 1) : te > 65535 && (te -= 65536, C.push(te >>> 10 & 1023 | 55296), te = 56320 | te & 1023), C.push(te), F += be;
    }
    return I(C);
  }
  const j = 4096;
  function I(O) {
    const w = O.length;
    if (w <= j)
      return String.fromCharCode.apply(String, O);
    let M = "", C = 0;
    for (; C < w; )
      M += String.fromCharCode.apply(
        String,
        O.slice(C, C += j)
      );
    return M;
  }
  function y(O, w, M) {
    let C = "";
    M = Math.min(O.length, M);
    for (let F = w; F < M; ++F)
      C += String.fromCharCode(O[F] & 127);
    return C;
  }
  function m(O, w, M) {
    let C = "";
    M = Math.min(O.length, M);
    for (let F = w; F < M; ++F)
      C += String.fromCharCode(O[F]);
    return C;
  }
  function N(O, w, M) {
    const C = O.length;
    (!w || w < 0) && (w = 0), (!M || M < 0 || M > C) && (M = C);
    let F = "";
    for (let W = w; W < M; ++W)
      F += Fe[O[W]];
    return F;
  }
  function T(O, w, M) {
    const C = O.slice(w, M);
    let F = "";
    for (let W = 0; W < C.length - 1; W += 2)
      F += String.fromCharCode(C[W] + C[W + 1] * 256);
    return F;
  }
  a.prototype.slice = function(w, M) {
    const C = this.length;
    w = ~~w, M = M === void 0 ? C : ~~M, w < 0 ? (w += C, w < 0 && (w = 0)) : w > C && (w = C), M < 0 ? (M += C, M < 0 && (M = 0)) : M > C && (M = C), M < w && (M = w);
    const F = this.subarray(w, M);
    return Object.setPrototypeOf(F, a.prototype), F;
  };
  function x(O, w, M) {
    if (O % 1 !== 0 || O < 0) throw new RangeError("offset is not uint");
    if (O + w > M) throw new RangeError("Trying to access beyond buffer length");
  }
  a.prototype.readUintLE = a.prototype.readUIntLE = function(w, M, C) {
    w = w >>> 0, M = M >>> 0, C || x(w, M, this.length);
    let F = this[w], W = 1, te = 0;
    for (; ++te < M && (W *= 256); )
      F += this[w + te] * W;
    return F;
  }, a.prototype.readUintBE = a.prototype.readUIntBE = function(w, M, C) {
    w = w >>> 0, M = M >>> 0, C || x(w, M, this.length);
    let F = this[w + --M], W = 1;
    for (; M > 0 && (W *= 256); )
      F += this[w + --M] * W;
    return F;
  }, a.prototype.readUint8 = a.prototype.readUInt8 = function(w, M) {
    return w = w >>> 0, M || x(w, 1, this.length), this[w];
  }, a.prototype.readUint16LE = a.prototype.readUInt16LE = function(w, M) {
    return w = w >>> 0, M || x(w, 2, this.length), this[w] | this[w + 1] << 8;
  }, a.prototype.readUint16BE = a.prototype.readUInt16BE = function(w, M) {
    return w = w >>> 0, M || x(w, 2, this.length), this[w] << 8 | this[w + 1];
  }, a.prototype.readUint32LE = a.prototype.readUInt32LE = function(w, M) {
    return w = w >>> 0, M || x(w, 4, this.length), (this[w] | this[w + 1] << 8 | this[w + 2] << 16) + this[w + 3] * 16777216;
  }, a.prototype.readUint32BE = a.prototype.readUInt32BE = function(w, M) {
    return w = w >>> 0, M || x(w, 4, this.length), this[w] * 16777216 + (this[w + 1] << 16 | this[w + 2] << 8 | this[w + 3]);
  }, a.prototype.readBigUInt64LE = xe(function(w) {
    w = w >>> 0, X(w, "offset");
    const M = this[w], C = this[w + 7];
    (M === void 0 || C === void 0) && Y(w, this.length - 8);
    const F = M + this[++w] * 2 ** 8 + this[++w] * 2 ** 16 + this[++w] * 2 ** 24, W = this[++w] + this[++w] * 2 ** 8 + this[++w] * 2 ** 16 + C * 2 ** 24;
    return BigInt(F) + (BigInt(W) << BigInt(32));
  }), a.prototype.readBigUInt64BE = xe(function(w) {
    w = w >>> 0, X(w, "offset");
    const M = this[w], C = this[w + 7];
    (M === void 0 || C === void 0) && Y(w, this.length - 8);
    const F = M * 2 ** 24 + this[++w] * 2 ** 16 + this[++w] * 2 ** 8 + this[++w], W = this[++w] * 2 ** 24 + this[++w] * 2 ** 16 + this[++w] * 2 ** 8 + C;
    return (BigInt(F) << BigInt(32)) + BigInt(W);
  }), a.prototype.readIntLE = function(w, M, C) {
    w = w >>> 0, M = M >>> 0, C || x(w, M, this.length);
    let F = this[w], W = 1, te = 0;
    for (; ++te < M && (W *= 256); )
      F += this[w + te] * W;
    return W *= 128, F >= W && (F -= Math.pow(2, 8 * M)), F;
  }, a.prototype.readIntBE = function(w, M, C) {
    w = w >>> 0, M = M >>> 0, C || x(w, M, this.length);
    let F = M, W = 1, te = this[w + --F];
    for (; F > 0 && (W *= 256); )
      te += this[w + --F] * W;
    return W *= 128, te >= W && (te -= Math.pow(2, 8 * M)), te;
  }, a.prototype.readInt8 = function(w, M) {
    return w = w >>> 0, M || x(w, 1, this.length), this[w] & 128 ? (255 - this[w] + 1) * -1 : this[w];
  }, a.prototype.readInt16LE = function(w, M) {
    w = w >>> 0, M || x(w, 2, this.length);
    const C = this[w] | this[w + 1] << 8;
    return C & 32768 ? C | 4294901760 : C;
  }, a.prototype.readInt16BE = function(w, M) {
    w = w >>> 0, M || x(w, 2, this.length);
    const C = this[w + 1] | this[w] << 8;
    return C & 32768 ? C | 4294901760 : C;
  }, a.prototype.readInt32LE = function(w, M) {
    return w = w >>> 0, M || x(w, 4, this.length), this[w] | this[w + 1] << 8 | this[w + 2] << 16 | this[w + 3] << 24;
  }, a.prototype.readInt32BE = function(w, M) {
    return w = w >>> 0, M || x(w, 4, this.length), this[w] << 24 | this[w + 1] << 16 | this[w + 2] << 8 | this[w + 3];
  }, a.prototype.readBigInt64LE = xe(function(w) {
    w = w >>> 0, X(w, "offset");
    const M = this[w], C = this[w + 7];
    (M === void 0 || C === void 0) && Y(w, this.length - 8);
    const F = this[w + 4] + this[w + 5] * 2 ** 8 + this[w + 6] * 2 ** 16 + (C << 24);
    return (BigInt(F) << BigInt(32)) + BigInt(M + this[++w] * 2 ** 8 + this[++w] * 2 ** 16 + this[++w] * 2 ** 24);
  }), a.prototype.readBigInt64BE = xe(function(w) {
    w = w >>> 0, X(w, "offset");
    const M = this[w], C = this[w + 7];
    (M === void 0 || C === void 0) && Y(w, this.length - 8);
    const F = (M << 24) + // Overflow
    this[++w] * 2 ** 16 + this[++w] * 2 ** 8 + this[++w];
    return (BigInt(F) << BigInt(32)) + BigInt(this[++w] * 2 ** 24 + this[++w] * 2 ** 16 + this[++w] * 2 ** 8 + C);
  }), a.prototype.readFloatLE = function(w, M) {
    return w = w >>> 0, M || x(w, 4, this.length), t.read(this, w, true, 23, 4);
  }, a.prototype.readFloatBE = function(w, M) {
    return w = w >>> 0, M || x(w, 4, this.length), t.read(this, w, false, 23, 4);
  }, a.prototype.readDoubleLE = function(w, M) {
    return w = w >>> 0, M || x(w, 8, this.length), t.read(this, w, true, 52, 8);
  }, a.prototype.readDoubleBE = function(w, M) {
    return w = w >>> 0, M || x(w, 8, this.length), t.read(this, w, false, 52, 8);
  };
  function L(O, w, M, C, F, W) {
    if (!a.isBuffer(O)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (w > F || w < W) throw new RangeError('"value" argument is out of bounds');
    if (M + C > O.length) throw new RangeError("Index out of range");
  }
  a.prototype.writeUintLE = a.prototype.writeUIntLE = function(w, M, C, F) {
    if (w = +w, M = M >>> 0, C = C >>> 0, !F) {
      const be = Math.pow(2, 8 * C) - 1;
      L(this, w, M, C, be, 0);
    }
    let W = 1, te = 0;
    for (this[M] = w & 255; ++te < C && (W *= 256); )
      this[M + te] = w / W & 255;
    return M + C;
  }, a.prototype.writeUintBE = a.prototype.writeUIntBE = function(w, M, C, F) {
    if (w = +w, M = M >>> 0, C = C >>> 0, !F) {
      const be = Math.pow(2, 8 * C) - 1;
      L(this, w, M, C, be, 0);
    }
    let W = C - 1, te = 1;
    for (this[M + W] = w & 255; --W >= 0 && (te *= 256); )
      this[M + W] = w / te & 255;
    return M + C;
  }, a.prototype.writeUint8 = a.prototype.writeUInt8 = function(w, M, C) {
    return w = +w, M = M >>> 0, C || L(this, w, M, 1, 255, 0), this[M] = w & 255, M + 1;
  }, a.prototype.writeUint16LE = a.prototype.writeUInt16LE = function(w, M, C) {
    return w = +w, M = M >>> 0, C || L(this, w, M, 2, 65535, 0), this[M] = w & 255, this[M + 1] = w >>> 8, M + 2;
  }, a.prototype.writeUint16BE = a.prototype.writeUInt16BE = function(w, M, C) {
    return w = +w, M = M >>> 0, C || L(this, w, M, 2, 65535, 0), this[M] = w >>> 8, this[M + 1] = w & 255, M + 2;
  }, a.prototype.writeUint32LE = a.prototype.writeUInt32LE = function(w, M, C) {
    return w = +w, M = M >>> 0, C || L(this, w, M, 4, 4294967295, 0), this[M + 3] = w >>> 24, this[M + 2] = w >>> 16, this[M + 1] = w >>> 8, this[M] = w & 255, M + 4;
  }, a.prototype.writeUint32BE = a.prototype.writeUInt32BE = function(w, M, C) {
    return w = +w, M = M >>> 0, C || L(this, w, M, 4, 4294967295, 0), this[M] = w >>> 24, this[M + 1] = w >>> 16, this[M + 2] = w >>> 8, this[M + 3] = w & 255, M + 4;
  };
  function V(O, w, M, C, F) {
    Q(w, C, F, O, M, 7);
    let W = Number(w & BigInt(4294967295));
    O[M++] = W, W = W >> 8, O[M++] = W, W = W >> 8, O[M++] = W, W = W >> 8, O[M++] = W;
    let te = Number(w >> BigInt(32) & BigInt(4294967295));
    return O[M++] = te, te = te >> 8, O[M++] = te, te = te >> 8, O[M++] = te, te = te >> 8, O[M++] = te, M;
  }
  function q(O, w, M, C, F) {
    Q(w, C, F, O, M, 7);
    let W = Number(w & BigInt(4294967295));
    O[M + 7] = W, W = W >> 8, O[M + 6] = W, W = W >> 8, O[M + 5] = W, W = W >> 8, O[M + 4] = W;
    let te = Number(w >> BigInt(32) & BigInt(4294967295));
    return O[M + 3] = te, te = te >> 8, O[M + 2] = te, te = te >> 8, O[M + 1] = te, te = te >> 8, O[M] = te, M + 8;
  }
  a.prototype.writeBigUInt64LE = xe(function(w, M = 0) {
    return V(this, w, M, BigInt(0), BigInt("0xffffffffffffffff"));
  }), a.prototype.writeBigUInt64BE = xe(function(w, M = 0) {
    return q(this, w, M, BigInt(0), BigInt("0xffffffffffffffff"));
  }), a.prototype.writeIntLE = function(w, M, C, F) {
    if (w = +w, M = M >>> 0, !F) {
      const ke = Math.pow(2, 8 * C - 1);
      L(this, w, M, C, ke - 1, -ke);
    }
    let W = 0, te = 1, be = 0;
    for (this[M] = w & 255; ++W < C && (te *= 256); )
      w < 0 && be === 0 && this[M + W - 1] !== 0 && (be = 1), this[M + W] = (w / te >> 0) - be & 255;
    return M + C;
  }, a.prototype.writeIntBE = function(w, M, C, F) {
    if (w = +w, M = M >>> 0, !F) {
      const ke = Math.pow(2, 8 * C - 1);
      L(this, w, M, C, ke - 1, -ke);
    }
    let W = C - 1, te = 1, be = 0;
    for (this[M + W] = w & 255; --W >= 0 && (te *= 256); )
      w < 0 && be === 0 && this[M + W + 1] !== 0 && (be = 1), this[M + W] = (w / te >> 0) - be & 255;
    return M + C;
  }, a.prototype.writeInt8 = function(w, M, C) {
    return w = +w, M = M >>> 0, C || L(this, w, M, 1, 127, -128), w < 0 && (w = 255 + w + 1), this[M] = w & 255, M + 1;
  }, a.prototype.writeInt16LE = function(w, M, C) {
    return w = +w, M = M >>> 0, C || L(this, w, M, 2, 32767, -32768), this[M] = w & 255, this[M + 1] = w >>> 8, M + 2;
  }, a.prototype.writeInt16BE = function(w, M, C) {
    return w = +w, M = M >>> 0, C || L(this, w, M, 2, 32767, -32768), this[M] = w >>> 8, this[M + 1] = w & 255, M + 2;
  }, a.prototype.writeInt32LE = function(w, M, C) {
    return w = +w, M = M >>> 0, C || L(this, w, M, 4, 2147483647, -2147483648), this[M] = w & 255, this[M + 1] = w >>> 8, this[M + 2] = w >>> 16, this[M + 3] = w >>> 24, M + 4;
  }, a.prototype.writeInt32BE = function(w, M, C) {
    return w = +w, M = M >>> 0, C || L(this, w, M, 4, 2147483647, -2147483648), w < 0 && (w = 4294967295 + w + 1), this[M] = w >>> 24, this[M + 1] = w >>> 16, this[M + 2] = w >>> 8, this[M + 3] = w & 255, M + 4;
  }, a.prototype.writeBigInt64LE = xe(function(w, M = 0) {
    return V(this, w, M, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), a.prototype.writeBigInt64BE = xe(function(w, M = 0) {
    return q(this, w, M, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function K(O, w, M, C, F, W) {
    if (M + C > O.length) throw new RangeError("Index out of range");
    if (M < 0) throw new RangeError("Index out of range");
  }
  function Z(O, w, M, C, F) {
    return w = +w, M = M >>> 0, F || K(O, w, M, 4), t.write(O, w, M, C, 23, 4), M + 4;
  }
  a.prototype.writeFloatLE = function(w, M, C) {
    return Z(this, w, M, true, C);
  }, a.prototype.writeFloatBE = function(w, M, C) {
    return Z(this, w, M, false, C);
  };
  function re(O, w, M, C, F) {
    return w = +w, M = M >>> 0, F || K(O, w, M, 8), t.write(O, w, M, C, 52, 8), M + 8;
  }
  a.prototype.writeDoubleLE = function(w, M, C) {
    return re(this, w, M, true, C);
  }, a.prototype.writeDoubleBE = function(w, M, C) {
    return re(this, w, M, false, C);
  }, a.prototype.copy = function(w, M, C, F) {
    if (!a.isBuffer(w)) throw new TypeError("argument should be a Buffer");
    if (C || (C = 0), !F && F !== 0 && (F = this.length), M >= w.length && (M = w.length), M || (M = 0), F > 0 && F < C && (F = C), F === C || w.length === 0 || this.length === 0) return 0;
    if (M < 0)
      throw new RangeError("targetStart out of bounds");
    if (C < 0 || C >= this.length) throw new RangeError("Index out of range");
    if (F < 0) throw new RangeError("sourceEnd out of bounds");
    F > this.length && (F = this.length), w.length - M < F - C && (F = w.length - M + C);
    const W = F - C;
    return this === w && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(M, C, F) : Uint8Array.prototype.set.call(
      w,
      this.subarray(C, F),
      M
    ), W;
  }, a.prototype.fill = function(w, M, C, F) {
    if (typeof w == "string") {
      if (typeof M == "string" ? (F = M, M = 0, C = this.length) : typeof C == "string" && (F = C, C = this.length), F !== void 0 && typeof F != "string")
        throw new TypeError("encoding must be a string");
      if (typeof F == "string" && !a.isEncoding(F))
        throw new TypeError("Unknown encoding: " + F);
      if (w.length === 1) {
        const te = w.charCodeAt(0);
        (F === "utf8" && te < 128 || F === "latin1") && (w = te);
      }
    } else typeof w == "number" ? w = w & 255 : typeof w == "boolean" && (w = Number(w));
    if (M < 0 || this.length < M || this.length < C)
      throw new RangeError("Out of range index");
    if (C <= M)
      return this;
    M = M >>> 0, C = C === void 0 ? this.length : C >>> 0, w || (w = 0);
    let W;
    if (typeof w == "number")
      for (W = M; W < C; ++W)
        this[W] = w;
    else {
      const te = a.isBuffer(w) ? w : a.from(w, F), be = te.length;
      if (be === 0)
        throw new TypeError('The value "' + w + '" is invalid for argument "value"');
      for (W = 0; W < C - M; ++W)
        this[W + M] = te[W % be];
    }
    return this;
  };
  const ne = {};
  function se(O, w, M) {
    ne[O] = class extends M {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: w.apply(this, arguments),
          writable: true,
          configurable: true
        }), this.name = `${this.name} [${O}]`, this.stack, delete this.name;
      }
      get code() {
        return O;
      }
      set code(F) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value: F,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${O}]: ${this.message}`;
      }
    };
  }
  se(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(O) {
      return O ? `${O} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), se(
    "ERR_INVALID_ARG_TYPE",
    function(O, w) {
      return `The "${O}" argument must be of type number. Received type ${typeof w}`;
    },
    TypeError
  ), se(
    "ERR_OUT_OF_RANGE",
    function(O, w, M) {
      let C = `The value of "${O}" is out of range.`, F = M;
      return Number.isInteger(M) && Math.abs(M) > 2 ** 32 ? F = ue(String(M)) : typeof M == "bigint" && (F = String(M), (M > BigInt(2) ** BigInt(32) || M < -(BigInt(2) ** BigInt(32))) && (F = ue(F)), F += "n"), C += ` It must be ${w}. Received ${F}`, C;
    },
    RangeError
  );
  function ue(O) {
    let w = "", M = O.length;
    const C = O[0] === "-" ? 1 : 0;
    for (; M >= C + 4; M -= 3)
      w = `_${O.slice(M - 3, M)}${w}`;
    return `${O.slice(0, M)}${w}`;
  }
  function he(O, w, M) {
    X(w, "offset"), (O[w] === void 0 || O[w + M] === void 0) && Y(w, O.length - (M + 1));
  }
  function Q(O, w, M, C, F, W) {
    if (O > M || O < w) {
      const te = typeof w == "bigint" ? "n" : "";
      let be;
      throw w === 0 || w === BigInt(0) ? be = `>= 0${te} and < 2${te} ** ${(W + 1) * 8}${te}` : be = `>= -(2${te} ** ${(W + 1) * 8 - 1}${te}) and < 2 ** ${(W + 1) * 8 - 1}${te}`, new ne.ERR_OUT_OF_RANGE("value", be, O);
    }
    he(C, F, W);
  }
  function X(O, w) {
    if (typeof O != "number")
      throw new ne.ERR_INVALID_ARG_TYPE(w, "number", O);
  }
  function Y(O, w, M) {
    throw Math.floor(O) !== O ? (X(O, M), new ne.ERR_OUT_OF_RANGE("offset", "an integer", O)) : w < 0 ? new ne.ERR_BUFFER_OUT_OF_BOUNDS() : new ne.ERR_OUT_OF_RANGE(
      "offset",
      `>= 0 and <= ${w}`,
      O
    );
  }
  const J = /[^+/0-9A-Za-z-_]/g;
  function ie(O) {
    if (O = O.split("=")[0], O = O.trim().replace(J, ""), O.length < 2) return "";
    for (; O.length % 4 !== 0; )
      O = O + "=";
    return O;
  }
  function fe(O, w) {
    w = w || 1 / 0;
    let M;
    const C = O.length;
    let F = null;
    const W = [];
    for (let te = 0; te < C; ++te) {
      if (M = O.charCodeAt(te), M > 55295 && M < 57344) {
        if (!F) {
          if (M > 56319) {
            (w -= 3) > -1 && W.push(239, 191, 189);
            continue;
          } else if (te + 1 === C) {
            (w -= 3) > -1 && W.push(239, 191, 189);
            continue;
          }
          F = M;
          continue;
        }
        if (M < 56320) {
          (w -= 3) > -1 && W.push(239, 191, 189), F = M;
          continue;
        }
        M = (F - 55296 << 10 | M - 56320) + 65536;
      } else F && (w -= 3) > -1 && W.push(239, 191, 189);
      if (F = null, M < 128) {
        if ((w -= 1) < 0) break;
        W.push(M);
      } else if (M < 2048) {
        if ((w -= 2) < 0) break;
        W.push(
          M >> 6 | 192,
          M & 63 | 128
        );
      } else if (M < 65536) {
        if ((w -= 3) < 0) break;
        W.push(
          M >> 12 | 224,
          M >> 6 & 63 | 128,
          M & 63 | 128
        );
      } else if (M < 1114112) {
        if ((w -= 4) < 0) break;
        W.push(
          M >> 18 | 240,
          M >> 12 & 63 | 128,
          M >> 6 & 63 | 128,
          M & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return W;
  }
  function ye(O) {
    const w = [];
    for (let M = 0; M < O.length; ++M)
      w.push(O.charCodeAt(M) & 255);
    return w;
  }
  function we(O, w) {
    let M, C, F;
    const W = [];
    for (let te = 0; te < O.length && !((w -= 2) < 0); ++te)
      M = O.charCodeAt(te), C = M >> 8, F = M % 256, W.push(F), W.push(C);
    return W;
  }
  function Ie(O) {
    return e.toByteArray(ie(O));
  }
  function Ee(O, w, M, C) {
    let F;
    for (F = 0; F < C && !(F + M >= w.length || F >= O.length); ++F)
      w[F + M] = O[F];
    return F;
  }
  function Me(O, w) {
    return O instanceof w || O != null && O.constructor != null && O.constructor.name != null && O.constructor.name === w.name;
  }
  function Ve(O) {
    return O !== O;
  }
  const Fe = function() {
    const O = "0123456789abcdef", w = new Array(256);
    for (let M = 0; M < 16; ++M) {
      const C = M * 16;
      for (let F = 0; F < 16; ++F)
        w[C + F] = O[M] + O[F];
    }
    return w;
  }();
  function xe(O) {
    return typeof BigInt > "u" ? _e : O;
  }
  function _e() {
    throw new Error("BigInt not supported");
  }
})(tl);
var ad;
function jo() {
  if (ad) return Ln;
  ad = 1;
  var r = B && B.__awaiter || function(h, f, g, p) {
    function b(_) {
      return _ instanceof g ? _ : new g(function(D) {
        D(_);
      });
    }
    return new (g || (g = Promise))(function(_, D) {
      function v(k) {
        try {
          A(p.next(k));
        } catch (U) {
          D(U);
        }
      }
      function E(k) {
        try {
          A(p.throw(k));
        } catch (U) {
          D(U);
        }
      }
      function A(k) {
        k.done ? _(k.value) : b(k.value).then(v, E);
      }
      A((p = p.apply(h, f || [])).next());
    });
  };
  Object.defineProperty(Ln, "__esModule", { value: true }), Ln.XummSdkJwt = Ln.XummSdk = void 0;
  const e = oi, t = n1(), n = ia, s = sa, i = oa, o = aa, a = $i, u = tl, c = e.debug("xumm-sdk");
  class l {
    constructor(f, g) {
      return c("Constructed"), this.Meta = new t.Meta(f || this.getEnv("XUMM_APIKEY"), g || this.getEnv("XUMM_APISECRET")), this.storage = new n.Storage(this.Meta), this.payload = new s.Payload(this.Meta), this.jwtUserdata = new a.JwtUserdata(this.Meta), this.Push = new o.Push(this.Meta), this.xApp = new i.xApp(this.Meta), this.Meta._inject(this), this;
    }
    getEnv(f) {
      let g = "";
      try {
        g = (process == null ? void 0 : process.env[f]) || "";
      } catch {
      }
      return g;
    }
    /**
     * Proxy methods to Meta class below
     */
    ping() {
      return this.Meta.ping();
    }
    getCuratedAssets() {
      return this.Meta.getCuratedAssets();
    }
    getRails() {
      return this.Meta.getRails();
    }
    getHookHashes() {
      return this.Meta.getHookHashes();
    }
    getHookHash(f) {
      return this.Meta.getHookHash(f);
    }
    getRates(f) {
      return this.Meta.getRates(f);
    }
    getKycStatus(f) {
      return this.Meta.getKycStatus(f);
    }
    getTransaction(f) {
      return this.Meta.getTransaction(f);
    }
    getNftokenDetail(f) {
      return this.Meta.getNftokenDetail(f);
    }
    verifyUserTokens(f) {
      return this.Meta.verifyUserTokens(f);
    }
    verifyUserToken(f) {
      return r(this, void 0, void 0, function* () {
        const g = yield this.Meta.verifyUserTokens([f]);
        return Array.isArray(g) && g.length === 1 ? g[0] : null;
      });
    }
    setEndpoint(f) {
      return this.Meta.setEndpoint(f);
    }
    caught(f) {
      throw f;
    }
  }
  Ln.XummSdk = l;
  class d extends l {
    constructor(f, g, p) {
      var b, _, D, v, E, A, k, U;
      let P = String(g || "").trim().toLowerCase();
      const $ = f.length !== 36;
      if (!$ && typeof g > "u" && typeof window < "u" && typeof window.URLSearchParams < "u") {
        const ee = new window.URLSearchParams(((b = window == null ? void 0 : window.location) === null || b === void 0 ? void 0 : b.search) || "");
        for (const G of ee.entries())
          G[0] === "xAppToken" && (P = G[1].toLowerCase().trim());
        if (P === "" && !(p != null && p.store) && !(p != null && p.noAutoRetrieve) && typeof ((_ = window == null ? void 0 : window.localStorage) === null || _ === void 0 ? void 0 : _.XummSdkJwt) == "string")
          try {
            const G = (v = (D = window == null ? void 0 : window.localStorage) === null || D === void 0 ? void 0 : D.XummSdkJwt) === null || v === void 0 ? void 0 : v.split(":"), H = JSON.parse((E = G == null ? void 0 : G.slice(1)) === null || E === void 0 ? void 0 : E.join(":"));
            if (H != null && H.jwt) {
              const R = u.Buffer.from((A = H.jwt.split(".")) === null || A === void 0 ? void 0 : A[1], "base64").toString("utf8"), z = JSON.parse(R);
              if (z != null && z.exp) {
                const j = (z == null ? void 0 : z.exp) - Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3);
                console.log("Restoring OTT " + (G == null ? void 0 : G[0])), j > 60 * 60 ? P = G == null ? void 0 : G[0] : console.log("Skip restore: not valid for one more hour");
              }
            }
          } catch (G) {
            console.log("JWT Restore Error", G);
          }
      }
      super(f, !$ && P !== "" ? "xApp:OneTimeToken:" + P : "RAWJWT:" + f), this.resolve = (ee) => {
        c("OTT data resolved", ee);
      }, this.reject = (ee) => {
        c("OTT data rejected", ee.message);
      }, this.ottResolved = $ ? Promise.resolve() : new Promise((ee, G) => {
        this.resolve = ee, this.reject = G;
      }), p != null && p.fatalHandler && (this.fatalHandler = p.fatalHandler), this.store = {
        get(ee) {
          var G;
          if (c("[JwtStore] » Builtin JWT store GET"), typeof window < "u" && typeof window.localStorage < "u" && typeof window.localStorage.XummSdkJwt == "string") {
            const H = window.localStorage.XummSdkJwt.split(":");
            if (H[0] === ee) {
              c("Restoring OTT from localStorage:", ee);
              try {
                return JSON.parse(H.slice(1).join(":"));
              } catch (R) {
                c("Error restoring OTT Data (JWT) from localStorage", (G = R) === null || G === void 0 ? void 0 : G.message);
              }
            }
          }
        },
        set(ee, G) {
          c("[JwtStore] » Builtin JWT store SET", ee), typeof window < "u" && typeof localStorage < "u" && (window.localStorage.XummSdkJwt = ee + ":" + JSON.stringify(G));
        }
      }, !((k = p == null ? void 0 : p.store) === null || k === void 0) && k.get && (this.store.get = p.store.get), !((U = p == null ? void 0 : p.store) === null || U === void 0) && U.set && (this.store.set = p.store.set), $ ? (this.reject(new Error("Not in OTT flow: in raw JWT (OAuth2-like) flow")), c("Using JWT (Raw, OAuth2) flow")) : c("Using JWT (xApp) flow");
    }
    _jwtStore(f, g) {
      if (f && (f == null ? void 0 : f.constructor) === t.Meta)
        return {
          get: (p) => {
            var b;
            return c("[JwtStore] Proxy GET"), (b = this.store) === null || b === void 0 ? void 0 : b.get(p);
          },
          set: (p, b) => {
            var _;
            return c("[JwtStore] Proxy SET"), this.resolve(b.ott), g(b.jwt), this.jwt = b.jwt, (_ = this.store) === null || _ === void 0 ? void 0 : _.set(p, b);
          }
        };
      throw new Error("Invalid _jwtStore invoker");
    }
    getOttData() {
      return r(this, void 0, void 0, function* () {
        const f = yield this.ottResolved;
        if (f)
          return f;
        throw new Error("Called getOttData on a non OTT-JWT flow");
      });
    }
    getJwt() {
      return r(this, void 0, void 0, function* () {
        return yield this.ottResolved, this.jwt;
      });
    }
    caught(f) {
      this.reject(f);
    }
  }
  return Ln.XummSdkJwt = d, Ln;
}
var nl = {};
var Tp = { exports: {} };
function U1(r) {
  throw new Error('Could not dynamically require "' + r + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var oc = { exports: {} };
var P1 = {};
var B1 = Object.freeze(Object.defineProperty({
  __proto__: null,
  default: P1
}, Symbol.toStringTag, { value: "Module" }));
var R1 = dp(B1);
var cd;
function il() {
  return cd || (cd = 1, function(r, e) {
    (function(t, n) {
      r.exports = n();
    })(B, function() {
      var t = t || function(n, s) {
        var i;
        if (typeof window < "u" && window.crypto && (i = window.crypto), typeof self < "u" && self.crypto && (i = self.crypto), typeof globalThis < "u" && globalThis.crypto && (i = globalThis.crypto), !i && typeof window < "u" && window.msCrypto && (i = window.msCrypto), !i && typeof B < "u" && B.crypto && (i = B.crypto), !i && typeof U1 == "function")
          try {
            i = R1;
          } catch {
          }
        var o = function() {
          if (i) {
            if (typeof i.getRandomValues == "function")
              try {
                return i.getRandomValues(new Uint32Array(1))[0];
              } catch {
              }
            if (typeof i.randomBytes == "function")
              try {
                return i.randomBytes(4).readInt32LE();
              } catch {
              }
          }
          throw new Error("Native crypto module could not be used to get secure random number.");
        }, a = Object.create || /* @__PURE__ */ function() {
          function D() {
          }
          return function(v) {
            var E;
            return D.prototype = v, E = new D(), D.prototype = null, E;
          };
        }(), u = {}, c = u.lib = {}, l = c.Base = /* @__PURE__ */ function() {
          return {
            /**
             * Creates a new object that inherits from this object.
             *
             * @param {Object} overrides Properties to copy into the new object.
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         field: 'value',
             *
             *         method: function () {
             *         }
             *     });
             */
            extend: function(D) {
              var v = a(this);
              return D && v.mixIn(D), (!v.hasOwnProperty("init") || this.init === v.init) && (v.init = function() {
                v.$super.init.apply(this, arguments);
              }), v.init.prototype = v, v.$super = this, v;
            },
            /**
             * Extends this object and runs the init method.
             * Arguments to create() will be passed to init().
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var instance = MyType.create();
             */
            create: function() {
              var D = this.extend();
              return D.init.apply(D, arguments), D;
            },
            /**
             * Initializes a newly created object.
             * Override this method to add some logic when your objects are created.
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         init: function () {
             *             // ...
             *         }
             *     });
             */
            init: function() {
            },
            /**
             * Copies properties into this object.
             *
             * @param {Object} properties The properties to mix in.
             *
             * @example
             *
             *     MyType.mixIn({
             *         field: 'value'
             *     });
             */
            mixIn: function(D) {
              for (var v in D)
                D.hasOwnProperty(v) && (this[v] = D[v]);
              D.hasOwnProperty("toString") && (this.toString = D.toString);
            },
            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = instance.clone();
             */
            clone: function() {
              return this.init.prototype.extend(this);
            }
          };
        }(), d = c.WordArray = l.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of 32-bit words.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.create();
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
           */
          init: function(D, v) {
            D = this.words = D || [], v != s ? this.sigBytes = v : this.sigBytes = D.length * 4;
          },
          /**
           * Converts this word array to a string.
           *
           * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
           *
           * @return {string} The stringified word array.
           *
           * @example
           *
           *     var string = wordArray + '';
           *     var string = wordArray.toString();
           *     var string = wordArray.toString(CryptoJS.enc.Utf8);
           */
          toString: function(D) {
            return (D || f).stringify(this);
          },
          /**
           * Concatenates a word array to this word array.
           *
           * @param {WordArray} wordArray The word array to append.
           *
           * @return {WordArray} This word array.
           *
           * @example
           *
           *     wordArray1.concat(wordArray2);
           */
          concat: function(D) {
            var v = this.words, E = D.words, A = this.sigBytes, k = D.sigBytes;
            if (this.clamp(), A % 4)
              for (var U = 0; U < k; U++) {
                var P = E[U >>> 2] >>> 24 - U % 4 * 8 & 255;
                v[A + U >>> 2] |= P << 24 - (A + U) % 4 * 8;
              }
            else
              for (var $ = 0; $ < k; $ += 4)
                v[A + $ >>> 2] = E[$ >>> 2];
            return this.sigBytes += k, this;
          },
          /**
           * Removes insignificant bits.
           *
           * @example
           *
           *     wordArray.clamp();
           */
          clamp: function() {
            var D = this.words, v = this.sigBytes;
            D[v >>> 2] &= 4294967295 << 32 - v % 4 * 8, D.length = n.ceil(v / 4);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {WordArray} The clone.
           *
           * @example
           *
           *     var clone = wordArray.clone();
           */
          clone: function() {
            var D = l.clone.call(this);
            return D.words = this.words.slice(0), D;
          },
          /**
           * Creates a word array filled with random bytes.
           *
           * @param {number} nBytes The number of random bytes to generate.
           *
           * @return {WordArray} The random word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.random(16);
           */
          random: function(D) {
            for (var v = [], E = 0; E < D; E += 4)
              v.push(o());
            return new d.init(v, D);
          }
        }), h = u.enc = {}, f = h.Hex = {
          /**
           * Converts a word array to a hex string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The hex string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
           */
          stringify: function(D) {
            for (var v = D.words, E = D.sigBytes, A = [], k = 0; k < E; k++) {
              var U = v[k >>> 2] >>> 24 - k % 4 * 8 & 255;
              A.push((U >>> 4).toString(16)), A.push((U & 15).toString(16));
            }
            return A.join("");
          },
          /**
           * Converts a hex string to a word array.
           *
           * @param {string} hexStr The hex string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
           */
          parse: function(D) {
            for (var v = D.length, E = [], A = 0; A < v; A += 2)
              E[A >>> 3] |= parseInt(D.substr(A, 2), 16) << 24 - A % 8 * 4;
            return new d.init(E, v / 2);
          }
        }, g = h.Latin1 = {
          /**
           * Converts a word array to a Latin1 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Latin1 string.
           *
           * @static
           *
           * @example
           *
           *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
           */
          stringify: function(D) {
            for (var v = D.words, E = D.sigBytes, A = [], k = 0; k < E; k++) {
              var U = v[k >>> 2] >>> 24 - k % 4 * 8 & 255;
              A.push(String.fromCharCode(U));
            }
            return A.join("");
          },
          /**
           * Converts a Latin1 string to a word array.
           *
           * @param {string} latin1Str The Latin1 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
           */
          parse: function(D) {
            for (var v = D.length, E = [], A = 0; A < v; A++)
              E[A >>> 2] |= (D.charCodeAt(A) & 255) << 24 - A % 4 * 8;
            return new d.init(E, v);
          }
        }, p = h.Utf8 = {
          /**
           * Converts a word array to a UTF-8 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-8 string.
           *
           * @static
           *
           * @example
           *
           *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
           */
          stringify: function(D) {
            try {
              return decodeURIComponent(escape(g.stringify(D)));
            } catch {
              throw new Error("Malformed UTF-8 data");
            }
          },
          /**
           * Converts a UTF-8 string to a word array.
           *
           * @param {string} utf8Str The UTF-8 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
           */
          parse: function(D) {
            return g.parse(unescape(encodeURIComponent(D)));
          }
        }, b = c.BufferedBlockAlgorithm = l.extend({
          /**
           * Resets this block algorithm's data buffer to its initial state.
           *
           * @example
           *
           *     bufferedBlockAlgorithm.reset();
           */
          reset: function() {
            this._data = new d.init(), this._nDataBytes = 0;
          },
          /**
           * Adds new data to this block algorithm's buffer.
           *
           * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
           *
           * @example
           *
           *     bufferedBlockAlgorithm._append('data');
           *     bufferedBlockAlgorithm._append(wordArray);
           */
          _append: function(D) {
            typeof D == "string" && (D = p.parse(D)), this._data.concat(D), this._nDataBytes += D.sigBytes;
          },
          /**
           * Processes available data blocks.
           *
           * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
           *
           * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
           *
           * @return {WordArray} The processed data.
           *
           * @example
           *
           *     var processedData = bufferedBlockAlgorithm._process();
           *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
           */
          _process: function(D) {
            var v, E = this._data, A = E.words, k = E.sigBytes, U = this.blockSize, P = U * 4, $ = k / P;
            D ? $ = n.ceil($) : $ = n.max(($ | 0) - this._minBufferSize, 0);
            var ee = $ * U, G = n.min(ee * 4, k);
            if (ee) {
              for (var H = 0; H < ee; H += U)
                this._doProcessBlock(A, H);
              v = A.splice(0, ee), E.sigBytes -= G;
            }
            return new d.init(v, G);
          },
          /**
           * Creates a copy of this object.
           *
           * @return {Object} The clone.
           *
           * @example
           *
           *     var clone = bufferedBlockAlgorithm.clone();
           */
          clone: function() {
            var D = l.clone.call(this);
            return D._data = this._data.clone(), D;
          },
          _minBufferSize: 0
        });
        c.Hasher = b.extend({
          /**
           * Configuration options.
           */
          cfg: l.extend(),
          /**
           * Initializes a newly created hasher.
           *
           * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
           *
           * @example
           *
           *     var hasher = CryptoJS.algo.SHA256.create();
           */
          init: function(D) {
            this.cfg = this.cfg.extend(D), this.reset();
          },
          /**
           * Resets this hasher to its initial state.
           *
           * @example
           *
           *     hasher.reset();
           */
          reset: function() {
            b.reset.call(this), this._doReset();
          },
          /**
           * Updates this hasher with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {Hasher} This hasher.
           *
           * @example
           *
           *     hasher.update('message');
           *     hasher.update(wordArray);
           */
          update: function(D) {
            return this._append(D), this._process(), this;
          },
          /**
           * Finalizes the hash computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The hash.
           *
           * @example
           *
           *     var hash = hasher.finalize();
           *     var hash = hasher.finalize('message');
           *     var hash = hasher.finalize(wordArray);
           */
          finalize: function(D) {
            D && this._append(D);
            var v = this._doFinalize();
            return v;
          },
          blockSize: 16,
          /**
           * Creates a shortcut function to a hasher's object interface.
           *
           * @param {Hasher} hasher The hasher to create a helper for.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
           */
          _createHelper: function(D) {
            return function(v, E) {
              return new D.init(E).finalize(v);
            };
          },
          /**
           * Creates a shortcut function to the HMAC's object interface.
           *
           * @param {Hasher} hasher The hasher to use in this HMAC helper.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
           */
          _createHmacHelper: function(D) {
            return function(v, E) {
              return new _.HMAC.init(D, E).finalize(v);
            };
          }
        });
        var _ = u.algo = {};
        return u;
      }(Math);
      return t;
    });
  }(oc)), oc.exports;
}
(function(r, e) {
  (function(t, n) {
    r.exports = n(il());
  })(B, function(t) {
    return function(n) {
      var s = t, i = s.lib, o = i.WordArray, a = i.Hasher, u = s.algo, c = [], l = [];
      (function() {
        function f(_) {
          for (var D = n.sqrt(_), v = 2; v <= D; v++)
            if (!(_ % v))
              return false;
          return true;
        }
        function g(_) {
          return (_ - (_ | 0)) * 4294967296 | 0;
        }
        for (var p = 2, b = 0; b < 64; )
          f(p) && (b < 8 && (c[b] = g(n.pow(p, 1 / 2))), l[b] = g(n.pow(p, 1 / 3)), b++), p++;
      })();
      var d = [], h = u.SHA256 = a.extend({
        _doReset: function() {
          this._hash = new o.init(c.slice(0));
        },
        _doProcessBlock: function(f, g) {
          for (var p = this._hash.words, b = p[0], _ = p[1], D = p[2], v = p[3], E = p[4], A = p[5], k = p[6], U = p[7], P = 0; P < 64; P++) {
            if (P < 16)
              d[P] = f[g + P] | 0;
            else {
              var $ = d[P - 15], ee = ($ << 25 | $ >>> 7) ^ ($ << 14 | $ >>> 18) ^ $ >>> 3, G = d[P - 2], H = (G << 15 | G >>> 17) ^ (G << 13 | G >>> 19) ^ G >>> 10;
              d[P] = ee + d[P - 7] + H + d[P - 16];
            }
            var R = E & A ^ ~E & k, z = b & _ ^ b & D ^ _ & D, j = (b << 30 | b >>> 2) ^ (b << 19 | b >>> 13) ^ (b << 10 | b >>> 22), I = (E << 26 | E >>> 6) ^ (E << 21 | E >>> 11) ^ (E << 7 | E >>> 25), y = U + I + R + l[P] + d[P], m = j + z;
            U = k, k = A, A = E, E = v + y | 0, v = D, D = _, _ = b, b = y + m | 0;
          }
          p[0] = p[0] + b | 0, p[1] = p[1] + _ | 0, p[2] = p[2] + D | 0, p[3] = p[3] + v | 0, p[4] = p[4] + E | 0, p[5] = p[5] + A | 0, p[6] = p[6] + k | 0, p[7] = p[7] + U | 0;
        },
        _doFinalize: function() {
          var f = this._data, g = f.words, p = this._nDataBytes * 8, b = f.sigBytes * 8;
          return g[b >>> 5] |= 128 << 24 - b % 32, g[(b + 64 >>> 9 << 4) + 14] = n.floor(p / 4294967296), g[(b + 64 >>> 9 << 4) + 15] = p, f.sigBytes = g.length * 4, this._process(), this._hash;
        },
        clone: function() {
          var f = a.clone.call(this);
          return f._hash = this._hash.clone(), f;
        }
      });
      s.SHA256 = a._createHelper(h), s.HmacSHA256 = a._createHmacHelper(h);
    }(Math), t.SHA256;
  });
})(Tp);
var $1 = Tp.exports;
var Ap = { exports: {} };
(function(r, e) {
  (function(t, n) {
    r.exports = n(il());
  })(B, function(t) {
    return function() {
      var n = t, s = n.lib, i = s.WordArray, o = n.enc;
      o.Base64 = {
        /**
         * Converts a word array to a Base64 string.
         *
         * @param {WordArray} wordArray The word array.
         *
         * @return {string} The Base64 string.
         *
         * @static
         *
         * @example
         *
         *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
         */
        stringify: function(u) {
          var c = u.words, l = u.sigBytes, d = this._map;
          u.clamp();
          for (var h = [], f = 0; f < l; f += 3)
            for (var g = c[f >>> 2] >>> 24 - f % 4 * 8 & 255, p = c[f + 1 >>> 2] >>> 24 - (f + 1) % 4 * 8 & 255, b = c[f + 2 >>> 2] >>> 24 - (f + 2) % 4 * 8 & 255, _ = g << 16 | p << 8 | b, D = 0; D < 4 && f + D * 0.75 < l; D++)
              h.push(d.charAt(_ >>> 6 * (3 - D) & 63));
          var v = d.charAt(64);
          if (v)
            for (; h.length % 4; )
              h.push(v);
          return h.join("");
        },
        /**
         * Converts a Base64 string to a word array.
         *
         * @param {string} base64Str The Base64 string.
         *
         * @return {WordArray} The word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
         */
        parse: function(u) {
          var c = u.length, l = this._map, d = this._reverseMap;
          if (!d) {
            d = this._reverseMap = [];
            for (var h = 0; h < l.length; h++)
              d[l.charCodeAt(h)] = h;
          }
          var f = l.charAt(64);
          if (f) {
            var g = u.indexOf(f);
            g !== -1 && (c = g);
          }
          return a(u, c, d);
        },
        _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
      };
      function a(u, c, l) {
        for (var d = [], h = 0, f = 0; f < c; f++)
          if (f % 4) {
            var g = l[u.charCodeAt(f - 1)] << f % 4 * 2, p = l[u.charCodeAt(f)] >>> 6 - f % 4 * 2, b = g | p;
            d[h >>> 2] |= b << 24 - h % 4 * 8, h++;
          }
        return i.create(d, h);
      }
    }(), t.enc.Base64;
  });
})(Ap);
var F1 = Ap.exports;
var Op = { exports: {} };
(function(r, e) {
  (function(t, n) {
    r.exports = n(il());
  })(B, function(t) {
    return function() {
      if (typeof ArrayBuffer == "function") {
        var n = t, s = n.lib, i = s.WordArray, o = i.init, a = i.init = function(u) {
          if (u instanceof ArrayBuffer && (u = new Uint8Array(u)), (u instanceof Int8Array || typeof Uint8ClampedArray < "u" && u instanceof Uint8ClampedArray || u instanceof Int16Array || u instanceof Uint16Array || u instanceof Int32Array || u instanceof Uint32Array || u instanceof Float32Array || u instanceof Float64Array) && (u = new Uint8Array(u.buffer, u.byteOffset, u.byteLength)), u instanceof Uint8Array) {
            for (var c = u.byteLength, l = [], d = 0; d < c; d++)
              l[d >>> 2] |= u[d] << 24 - d % 4 * 8;
            o.call(this, l, c);
          } else
            o.apply(this, arguments);
        };
        a.prototype = i;
      }
    }(), t.lib.WordArray;
  });
})(Op);
var Q1 = Op.exports;
var Co = B && B.__assign || function() {
  return Co = Object.assign || function(r) {
    for (var e, t = 1, n = arguments.length; t < n; t++) {
      e = arguments[t];
      for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && (r[s] = e[s]);
    }
    return r;
  }, Co.apply(this, arguments);
};
var sl = B && B.__importDefault || function(r) {
  return r && r.__esModule ? r : { default: r };
};
Object.defineProperty(nl, "__esModule", { value: true });
var q1 = sl($1);
var Y1 = sl(F1);
var V1 = sl(Q1);
var H1 = (
  /** @class */
  function() {
    function r(e) {
      this.state = "", this.codeVerifier = "", this.config = e;
    }
    return r.prototype.authorizeUrl = function(e) {
      var t, n;
      e === void 0 && (e = {});
      var s = new URLSearchParams(Object.assign(Co({ response_type: !((t = this.config) === null || t === void 0) && t.implicit ? "token" : "code", client_id: this.config.client_id, state: this.getState(e.state || null), scope: this.config.requested_scopes, redirect_uri: this.config.redirect_uri }, !((n = this.config) === null || n === void 0) && n.implicit ? {} : {
        code_challenge: this.pkceChallengeFromVerifier(),
        code_challenge_method: "S256"
      }), e)).toString();
      return "".concat(this.config.authorization_endpoint, "?").concat(s);
    }, r.prototype.exchangeForAccessToken = function(e, t) {
      var n = this;
      return t === void 0 && (t = {}), this.parseAuthResponseUrl(e).then(function(s) {
        var i, o;
        if (!((i = n.config) === null || i === void 0) && i.implicit) {
          var a = {
            access_token: "",
            expires_in: 0,
            refresh_expires_in: 0,
            refresh_token: "",
            scope: "",
            token_type: ""
          }, u = new URL(e).searchParams;
          return u.forEach(function(c, l) {
            Object.keys(a).indexOf(l) > -1 && (a[l] = typeof a[l] == "number" ? Number(c) : String(c));
          }), Promise.resolve(Object.assign(a, t));
        }
        return fetch(n.config.token_endpoint, {
          method: "POST",
          body: new URLSearchParams(Object.assign(Co({ grant_type: "authorization_code", code: s.code, client_id: n.config.client_id, redirect_uri: n.config.redirect_uri }, !((o = n.config) === null || o === void 0) && o.implicit ? {} : {
            code_verifier: n.getCodeVerifier()
          }), t)),
          headers: {
            Accept: "application/json",
            "Content-Type": "application/x-www-form-urlencoded;charset=UTF-8"
          }
        }).then(function(c) {
          return c.json();
        });
      });
    }, r.prototype.getCodeVerifier = function() {
      return this.codeVerifier === "" && (this.codeVerifier = this.randomStringFromStorage("pkce_code_verifier")), this.codeVerifier;
    }, r.prototype.getState = function(e) {
      e === void 0 && (e = null);
      var t = "pkce_state";
      return e !== null && this.getStore().setItem(t, e), this.state === "" && (this.state = this.randomStringFromStorage(t)), this.state;
    }, r.prototype.parseAuthResponseUrl = function(e) {
      var t = new URL(e).searchParams;
      return this.validateAuthResponse({
        error: t.get("error"),
        query: t.get("query"),
        state: t.get("state"),
        code: t.get("code")
      });
    }, r.prototype.pkceChallengeFromVerifier = function() {
      var e = (0, q1.default)(this.getCodeVerifier());
      return Y1.default.stringify(e).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
    }, r.prototype.randomStringFromStorage = function(e) {
      var t = this.getStore().getItem(e);
      return t === null && this.getStore().setItem(e, V1.default.random(64)), this.getStore().getItem(e) || "";
    }, r.prototype.validateAuthResponse = function(e) {
      var t = this;
      return new Promise(function(n, s) {
        var i;
        return e.error ? s({ error: e.error }) : e.state !== t.getState() && !(!((i = t.config) === null || i === void 0) && i.implicit) ? s({ error: "Invalid State" }) : n(e);
      });
    }, r.prototype.getStore = function() {
      var e;
      return ((e = this.config) === null || e === void 0 ? void 0 : e.storage) || sessionStorage;
    }, r;
  }()
);
nl.default = H1;
var Xs = B && B.__awaiter || function(r, e, t, n) {
  function s(i) {
    return i instanceof t ? i : new t(function(o) {
      o(i);
    });
  }
  return new (t || (t = Promise))(function(i, o) {
    function a(l) {
      try {
        c(n.next(l));
      } catch (d) {
        o(d);
      }
    }
    function u(l) {
      try {
        c(n.throw(l));
      } catch (d) {
        o(d);
      }
    }
    function c(l) {
      l.done ? i(l.value) : s(l.value).then(a, u);
    }
    c((n = n.apply(r, e || [])).next());
  });
};
var G1 = B && B.__importDefault || function(r) {
  return r && r.__esModule ? r : { default: r };
};
Object.defineProperty(Li, "__esModule", { value: true });
Li.XummPkce = Li.XummPkceThread = void 0;
var W1 = Gt;
var ud = jo();
var K1 = G1(nl);
var et = function(...r) {
  typeof localStorage < "u" && localStorage != null && localStorage.debug && console.log(...r);
};
typeof window < "u" && et("Xumm OAuth2 PKCE Authorization Code Flow lib.");
var Wi = (r) => {
  let e = (n) => {
  };
  return {
    promise: new Promise((n) => {
      e = n;
    }),
    resolve: (n) => e(n)
  };
};
var Sp = class extends W1.EventEmitter {
  constructor(e, t) {
    var n, s;
    super(), this.popup = null, this.resolved = false, this.mobileRedirectFlow = false, this.eventPromises = {
      retrieved: Wi(),
      error: Wi(),
      success: Wi(),
      loggedout: Wi()
    }, this.options = {
      redirectUrl: document.location.href,
      rememberJwt: true,
      storage: localStorage,
      implicit: false
    }, typeof t == "string" ? this.options.redirectUrl = t : typeof t == "object" && t && (typeof t.redirectUrl == "string" && (this.options.redirectUrl = t.redirectUrl), typeof t.rememberJwt == "boolean" && (this.options.rememberJwt = t.rememberJwt), typeof t.storage == "object" && (this.options.storage = t.storage), typeof t.implicit == "boolean" && (this.options.implicit = t.implicit));
    const i = {
      client_id: e,
      redirect_uri: this.options.redirectUrl,
      authorization_endpoint: "https://oauth2.xumm.app/auth",
      token_endpoint: "https://oauth2.xumm.app/token",
      requested_scopes: "XummPkce",
      storage: this.options.storage,
      implicit: this.options.implicit
    };
    if (this.pkce = new K1.default(i), this.options.rememberJwt) {
      et("Remember JWT");
      try {
        const a = JSON.parse(((n = this.options.storage) === null || n === void 0 ? void 0 : n.getItem("XummPkceJwt")) || "{}");
        if (a != null && a.jwt && typeof a.jwt == "string") {
          const u = new ud.XummSdkJwt(a.jwt);
          this.ping = u.ping(), this.ping.then((c) => Xs(this, void 0, void 0, function* () {
            var l;
            !((l = c == null ? void 0 : c.jwtData) === null || l === void 0) && l.sub ? (this.autoResolvedFlow = Object.assign(a, { sdk: u }), yield this.authorize(), this.emit("retrieved")) : this.logout();
          })).catch((c) => {
            this.logout();
          });
        } else
          this.logout();
      } catch {
      }
    }
    window.addEventListener("message", (a) => {
      var u;
      if (et("Received Event from ", a.origin), String((a == null ? void 0 : a.data) || "").slice(0, 1) === "{" && String((a == null ? void 0 : a.data) || "").slice(-1) === "}" && (et("Got PostMessage with JSON"), a.origin === "https://xumm.app" || a.origin === "https://oauth2.xumm.app")) {
        et("Got PostMessage from https://xumm.app / https://oauth2.xumm.app");
        try {
          const c = JSON.parse(a.data);
          (c == null ? void 0 : c.source) === "xumm_sign_request" && (c != null && c.payload) ? et("Payload opened:", c.payload) : (c == null ? void 0 : c.source) === "xumm_sign_request_resolved" && (c != null && c.options) ? (et("Payload resolved, mostmessage containing options containing redirect URL: ", c), this.resolved = true, this.pkce.exchangeForAccessToken(c.options.full_redirect_uri).then((l) => {
            if (this.jwt = l.access_token, l != null && l.error_description)
              throw new Error(l == null ? void 0 : l.error_description);
            fetch("https://oauth2.xumm.app/userinfo", {
              headers: {
                Authorization: "Bearer " + l.access_token
              }
            }).then((d) => d.json()).then((d) => {
              var h;
              if (this.resolvePromise) {
                if (this.options.rememberJwt) {
                  et("Remembering JWT");
                  try {
                    (h = this.options.storage) === null || h === void 0 || h.setItem("XummPkceJwt", JSON.stringify({ jwt: l.access_token, me: d }));
                  } catch (f) {
                    et("Could not persist JWT to local storage", f);
                  }
                }
                this.resolvePromise({
                  jwt: l.access_token,
                  sdk: new ud.XummSdkJwt(l.access_token),
                  me: d
                });
              }
            });
          }).catch((l) => {
            this.rejectPromise && this.rejectPromise(l != null && l.error ? new Error(l.error) : l), et((l == null ? void 0 : l.error) || l);
          })) : (c == null ? void 0 : c.source) === "xumm_sign_request_rejected" ? (et("Payload rejected", c == null ? void 0 : c.options), this.rejectPromise && this.rejectPromise(new Error(((u = c == null ? void 0 : c.options) === null || u === void 0 ? void 0 : u.error_description) || "Payload rejected"))) : (c == null ? void 0 : c.source) === "xumm_sign_request_popup_closed" ? (et("Popup closed, wait 750ms"), setTimeout(() => {
            !this.resolved && this.rejectPromise && this.rejectPromise(new Error("Sign In window closed"));
          }, 750)) : et("Unexpected message, skipping", c == null ? void 0 : c.source);
        } catch (c) {
          et("Error parsing message", (c == null ? void 0 : c.message) || c);
        }
      }
    }, false);
    const o = new URLSearchParams(((s = document == null ? void 0 : document.location) === null || s === void 0 ? void 0 : s.search) || "");
    if (o.get("authorization_code") || o.get("access_token") || o.get("error_description")) {
      this.mobileRedirectFlow = true, this.urlParams = o;
      let a = false;
      const u = (c) => Xs(this, void 0, void 0, function* () {
        et("onDocumentReady", document.readyState), !a && document.readyState === "complete" && (a = true, et("(readystatechange: [ " + document.readyState + " ])"), this.handleMobileGrant(), yield this.authorize(), this.emit("retrieved"));
      });
      u(), document.addEventListener("readystatechange", u);
    }
  }
  emit(e, ...t) {
    return this.eventPromises[e].promise.then(() => super.emit(e, ...t)), true;
  }
  on(e, t) {
    return this.eventPromises[e].resolve(), super.on(e, t);
  }
  off(e, t) {
    return this.eventPromises[e] = Wi(), super.off(e, t);
  }
  // Todo: document, e.g. custom flow, plugin
  authorizeUrl() {
    return this.pkce.authorizeUrl();
  }
  handleMobileGrant() {
    if (this.urlParams && this.mobileRedirectFlow) {
      const e = {
        data: JSON.stringify(this.urlParams.get("authorization_code") || this.urlParams.get("access_token") ? {
          source: "xumm_sign_request_resolved",
          options: {
            full_redirect_uri: document.location.href
          }
        } : {
          source: "xumm_sign_request_rejected",
          options: {
            error: this.urlParams.get("error"),
            error_code: this.urlParams.get("error_code"),
            error_description: this.urlParams.get("error_description")
          }
        }),
        origin: "https://oauth2.xumm.app"
      }, t = new MessageEvent("message", e);
      return window.dispatchEvent(t), true;
    }
    return false;
  }
  authorize() {
    return Xs(this, void 0, void 0, function* () {
      if (this.resolvedSuccessfully)
        return this.promise;
      this.resolved = false;
      try {
        yield this.ping;
      } catch {
      }
      if (!this.mobileRedirectFlow && !this.autoResolvedFlow) {
        const t = this.authorizeUrl(), n = window.open(t, "XummPkceLogin", "directories=no,titlebar=no,toolbar=no,location=no,status=no,menubar=no,scrollbars=no,resizable=no,width=600,height=790");
        this.popup = n, et("Popup opened...", t);
      }
      return this.resolved = false, (() => {
        var t;
        const n = new URLSearchParams(((t = document == null ? void 0 : document.location) === null || t === void 0 ? void 0 : t.search) || "");
        n.delete("authorization_code"), n.delete("code"), n.delete("scope"), n.delete("state"), n.delete("access_token"), n.delete("refresh_token"), n.delete("token_type"), n.delete("expires_in");
        const s = n.toString(), i = document.location.href.split("?")[0] + (s !== "" ? "?" : "") + s;
        window.history.replaceState({ path: i }, "", i);
      })(), this.autoResolvedFlow ? this.resolved || (this.resolved = true, this.promise = Promise.resolve(this.autoResolvedFlow), this.rejectPromise = this.resolvePromise = () => {
      }, et("Auto resolved"), this.emit("success")) : this.promise = new Promise((t, n) => {
        this.resolvePromise = (s) => {
          const i = t(s);
          return this.resolved = true, this.resolvedSuccessfully = true, et("Xumm Sign in RESOLVED"), this.emit("success"), i;
        }, this.rejectPromise = (s) => {
          const i = n(s);
          return this.resolved = true, this.emit("error", typeof s == "string" ? new Error(s) : s), et("Xumm Sign in REJECTED"), i;
        };
      }), this.promise;
    });
  }
  state() {
    return Xs(this, void 0, void 0, function* () {
      return this.promise;
    });
  }
  logout() {
    var e;
    setTimeout(() => this.emit("loggedout"), 0);
    try {
      this.resolved = false, this.resolvedSuccessfully = void 0, this.autoResolvedFlow = void 0, (e = this.options.storage) === null || e === void 0 || e.removeItem("XummPkceJwt"), this.mobileRedirectFlow = false;
    } catch {
    }
  }
  getPopup() {
    return this === null || this === void 0 ? void 0 : this.popup;
  }
};
Li.XummPkceThread = Sp;
var zn = (r) => {
  let e = false;
  r && typeof window == "object" && typeof window._XummPkce > "u" && (window._XummPkce = r, e = true);
  const t = window == null ? void 0 : window._XummPkce;
  return t && e && et("XummPkce attached to window"), t;
};
var X1 = class {
  constructor(e, t) {
    typeof window > "u" || typeof document > "u" || zn() || zn(new Sp(e, t));
  }
  on(e, t) {
    const n = zn();
    if (n)
      return n.on(e, t), this;
  }
  off(e, t) {
    const n = zn();
    if (n)
      return n.off(e, t), this;
  }
  authorize() {
    const e = zn();
    if (e)
      return e.authorize();
  }
  state() {
    const e = zn();
    if (e)
      return e.state();
  }
  logout() {
    const e = zn();
    if (e)
      return e.logout();
  }
};
Li.XummPkce = X1;
var ac = {};
var cc = {};
var ld;
function dd() {
  return ld || (ld = 1, function(r) {
    Object.defineProperty(r, "__esModule", { value: true }), r.xAppEvents = void 0, function(e) {
      e.ready = "ready", e.scanQr = "scanQr", e.payloadResolved = "payloadResolved", e.selectDestination = "selectDestination", e.networkSwitch = "networkSwitch";
    }(r.xAppEvents || (r.xAppEvents = {}));
  }(cc)), cc;
}
var hd;
function Z1() {
  return hd || (hd = 1, function(r) {
    var e = B && B.__createBinding || (Object.create ? function(v, E, A, k) {
      k === void 0 && (k = A);
      var U = Object.getOwnPropertyDescriptor(E, A);
      (!U || ("get" in U ? !E.__esModule : U.writable || U.configurable)) && (U = { enumerable: true, get: function() {
        return E[A];
      } }), Object.defineProperty(v, k, U);
    } : function(v, E, A, k) {
      k === void 0 && (k = A), v[k] = E[A];
    }), t = B && B.__exportStar || function(v, E) {
      for (var A in v) A !== "default" && !Object.prototype.hasOwnProperty.call(E, A) && e(E, v, A);
    }, n = B && B.__awaiter || function(v, E, A, k) {
      function U(P) {
        return P instanceof A ? P : new A(function($) {
          $(P);
        });
      }
      return new (A || (A = Promise))(function(P, $) {
        function ee(R) {
          try {
            H(k.next(R));
          } catch (z) {
            $(z);
          }
        }
        function G(R) {
          try {
            H(k.throw(R));
          } catch (z) {
            $(z);
          }
        }
        function H(R) {
          R.done ? P(R.value) : U(R.value).then(ee, G);
        }
        H((k = k.apply(v, E || [])).next());
      });
    }, s;
    Object.defineProperty(r, "__esModule", { value: true }), r.xApp = void 0;
    const i = Gt, o = dd();
    t(dd(), r);
    const a = 0.25, u = 250, c = 2e3, l = Number(/* @__PURE__ */ new Date());
    let d;
    const h = new Promise((v) => {
      d = (E) => {
        console.log("Doc Ready...");
        const A = (Number(/* @__PURE__ */ new Date()) - l) / 1e3;
        A < a ? (console.log("Doc not alive >= " + a + " sec, stalling for " + (a - A)), setTimeout(function() {
          v(E);
        }, (a - A) * 1e3)) : (console.log("Doc alive " + a + "+ sec, go ahead"), v(E));
      };
    });
    h.then(() => {
      console.log("documentReadyPromise resolved");
    }).catch((v) => {
      console.log(v);
    }), typeof document < "u" && document.addEventListener("readystatechange", (v) => {
      console.log("(readystatechange: [ " + document.readyState + " ])"), document.readyState === "complete" && d();
    }), typeof window < "u" && console.log("Loading xApp SDK");
    let f = typeof window < "u" ? window : {}, g = false;
    f != null && f.parent && ((s = f.parent) === null || s === void 0 || s.postMessage("XAPP_PROXY_INIT", "*"));
    const p = (v, E, A = 0) => n(void 0, void 0, void 0, function* () {
      var k, U;
      if (yield h, typeof (f == null ? void 0 : f.ReactNativeWebView) < "u" || g) {
        const P = (Number(/* @__PURE__ */ new Date()) - l) / 1e3;
        ["close"].indexOf(v) > -1 && P < 4 && (console.log("xApp close, doc alive < minAliveTimeSec, stall: " + (4 - P)), yield new Promise((G) => {
          setTimeout(() => {
            G(true);
          }, (4 - P) * 1e3);
        }));
        const $ = JSON.stringify(Object.assign({ command: v }, E || {}));
        return g ? (k = f.parent) === null || k === void 0 || k.postMessage($, "*") : (U = f.ReactNativeWebView) === null || U === void 0 || U.postMessage($), console.log("xAppActionAttempt Success", v, E), true;
      } else
        return A * u < c ? (console.log("xAppActionAttempt Attempt " + A + " » Retry", v, E), yield new Promise((P) => {
          setTimeout(P, u);
        }), p(v, E, A + 1)) : (console.log("xAppActionAttempt Failed after attempt " + A, v, E), new Error("xApp." + v.replace(/^xApp/, "") + ": could not contact Xumm App Host"));
    });
    class b extends i.EventEmitter {
      constructor() {
        super(), document.readyState === "complete" && d();
        const E = (A) => {
          const k = A;
          if (typeof (k == null ? void 0 : k.data) == "string" && k.data === "XAPP_PROXY_INIT_ACK") {
            console.log("xApp Proxy ACK received, switching to PROXY (SANDBOX) mode"), g = true;
            return;
          }
          try {
            const U = JSON.parse((k == null ? void 0 : k.data) || "{}");
            if (console.log("_event (typeof, {_event}) ", typeof U, { _event: U }), typeof U == "object" && U !== null)
              if (typeof U.method == "string" && U.method in o.xAppEvents) {
                console.log("xApp Event received", U.method, U);
                const P = U.method;
                switch (delete U.method, P) {
                  case String(o.xAppEvents.payloadResolved):
                    this.emit("payload", U);
                    break;
                  case String(o.xAppEvents.scanQr):
                    this.emit("qr", U);
                    break;
                  case String(o.xAppEvents.networkSwitch):
                    this.emit("networkswitch", U);
                    break;
                  case String(o.xAppEvents.selectDestination):
                    this.emit("destination", U);
                    break;
                }
              } else
                console.log("xApp Event received, not in xAppEvents:", U.method);
          } catch (U) {
            const P = (U == null ? void 0 : U.message) || "";
            P.match(/XAPP_PROXY_INIT/) || console.log("xApp Event received, cannot parse as JSON", P);
          }
        };
        typeof window.addEventListener == "function" && window.addEventListener("message", E), typeof document.addEventListener == "function" && document.addEventListener("message", E);
      }
      getEnvironment() {
        const E = _();
        return E ? E.getEnvironment() : { version: "", ott: "" };
      }
      navigate(E) {
        return typeof (E == null ? void 0 : E.xApp) != "string" ? Promise.reject(new Error("xApp.navigate: Invalid argument: `xApp`")) : p("xAppNavigate", E);
      }
      openSignRequest(E) {
        return typeof (E == null ? void 0 : E.uuid) != "string" ? Promise.reject(new Error("xApp.openSignRequest: Invalid argument: `uuid`")) : E.uuid.match(/^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i) ? p("openSignRequest", E) : Promise.reject(new Error("xApp.openSignRequest: Invalid payload UUID"));
      }
      selectDestination(E) {
        return p("selectDestination", E);
      }
      openBrowser(E) {
        return typeof (E == null ? void 0 : E.url) != "string" ? Promise.reject(new Error("xApp.openBrowser: Invalid argument: `url`")) : p("openBrowser", E);
      }
      share(E) {
        return typeof (E == null ? void 0 : E.text) != "string" ? Promise.reject(new Error("xApp.share: Invalid argument: `text`")) : p("share", E);
      }
      scanQr() {
        return p("scanQr");
      }
      tx(E) {
        return typeof (E == null ? void 0 : E.tx) != "string" ? Promise.reject(new Error("xApp.tx: Invalid argument: `tx`")) : typeof (E == null ? void 0 : E.account) != "string" ? Promise.reject(new Error("xApp.tx: Invalid argument: `account`")) : p("txDetails", E);
      }
      close(E) {
        return p("close", E);
      }
      ready() {
        return p("ready");
      }
      customCommand(E, A) {
        return p(E, A);
      }
    }
    const _ = (v) => {
      let E = false;
      v && typeof f == "object" && typeof f._xAppSdk > "u" && (f._xAppSdk = v, E = true);
      const A = f == null ? void 0 : f._xAppSdk;
      return A && E && console.log("xAppSdk attached to window"), A;
    };
    class D {
      constructor() {
        if (this.xummEnvironment = {
          version: "",
          ott: ""
        }, !(typeof window > "u" || typeof document > "u")) {
          if (typeof navigator < "u" && typeof (navigator == null ? void 0 : navigator.userAgent) == "string") {
            const E = navigator.userAgent.trim().match(/xumm\/xapp:([0-9]{1,}\.[0-9]{1,}\.[0-9]{1,}).*ott:([0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12})/);
            E && (this.xummEnvironment.version = E[1], this.xummEnvironment.ott = E[2]);
          }
          this.xummEnvironment.version === "" && console.log("Warning: Xumm Version could not be retrieved from User Agent, possibly not loaded in xApp context?"), _() || _(new b());
        }
      }
      getEnvironment() {
        return this.xummEnvironment;
      }
      on(E, A) {
        const k = _();
        if (k)
          return k.on(E, A), this;
      }
      off(E, A) {
        const k = _();
        if (k)
          return k.off(E, A), this;
      }
      navigate(E) {
        const A = _();
        if (A)
          return A.navigate(E);
      }
      openSignRequest(E) {
        const A = _();
        if (A && E != null && E.uuid)
          return A.openSignRequest(E);
      }
      selectDestination(E) {
        const A = _();
        if (A)
          return A.selectDestination(E);
      }
      openBrowser(E) {
        const A = _();
        if (A)
          return A.openBrowser(E);
      }
      share(E) {
        const A = _();
        if (A)
          return A.share(E);
      }
      scanQr() {
        const E = _();
        if (E)
          return E.scanQr();
      }
      tx(E) {
        const A = _();
        if (A)
          return A.tx(E);
      }
      close(E) {
        const A = _();
        if (A)
          return A.close(E);
      }
      ready() {
        const E = _();
        if (E)
          return E.ready();
      }
      customCommand(E, A) {
        const k = _();
        if (k)
          return k.customCommand(E, A);
      }
    }
    r.xApp = D;
  }(ac)), ac;
}
var Fn = B && B.__awaiter || function(r, e, t, n) {
  function s(i) {
    return i instanceof t ? i : new t(function(o) {
      o(i);
    });
  }
  return new (t || (t = Promise))(function(i, o) {
    function a(l) {
      try {
        c(n.next(l));
      } catch (d) {
        o(d);
      }
    }
    function u(l) {
      try {
        c(n.throw(l));
      } catch (d) {
        o(d);
      }
    }
    function c(l) {
      l.done ? i(l.value) : s(l.value).then(a, u);
    }
    c((n = n.apply(r, e || [])).next());
  });
};
Object.defineProperty(Ju, "__esModule", { value: true });
var jp = Ju.Xumm = void 0;
var J1 = Li;
var em = tl;
var tm = Gt;
var fd = (r) => em.Buffer.from(r, "base64").toString("utf8");
var pd;
(function(r) {
  r.cli = "cli", r.browser = "browser", r.xapp = "xapp";
})(pd || (pd = {}));
var at = {
  cli: false,
  browser: false,
  xapp: false
};
var Ki = new RegExp("^[0-9(a-f|A-F)]{8}-[0-9(a-f|A-F)]{4}-4[0-9(a-f|A-F)]{3}-[89ab][0-9(a-f|A-F)]{3}-[0-9(a-f|A-F)]{12}$");
var le = {};
var Zs = typeof process == "object" && process ? (process == null ? void 0 : process.env) || {} : {};
Object.assign(at, {
  cli: Object.keys(Zs).indexOf("NODE") > -1 || Object.keys(Zs).indexOf("SHELL") > -1 || Object.keys(Zs).indexOf("TERM") > -1 || Object.keys(Zs).indexOf("PATH") > -1
});
Object.assign(at, {
  browser: typeof process == "object" && process && (process == null ? void 0 : process.browser) || typeof document == "object" && document && (document == null ? void 0 : document.location)
});
Object.assign(at, {
  xapp: at.browser && (!!navigator.userAgent.match(/xumm\/xapp/i) || !!navigator.userAgent.match(/xAppBuilder/i))
});
var rm = Object.keys(at).filter((r) => at[r]);
var Tr = [];
var Ue = (r) => Fn(void 0, void 0, void 0, function* () {
  return yield Promise.all(Tr), yield r();
});
var Xi = (r) => new Proxy(r, {
  get(e, t) {
    return ["on", "off"].indexOf(String(t)) < 0 && // Events
    (typeof e[t] == "function" || e.constructor.name === "Promise") ? function() {
      return e.constructor.name === "Promise" ? e.then((n) => Ue(() => n[t](...arguments))) : Ue(() => e[t](...arguments));
    } : e[t];
  }
});
var gi = {
  XummSdkJwt: false,
  XummPkce: false,
  xApp: false
};
var ge;
var fr = "";
var We = {};
var pe = {};
var gd = 0;
var yd = class {
  constructor() {
    this.account = Ue(() => {
      var e, t, n;
      return (t = (e = We == null ? void 0 : We.sub) !== null && e !== void 0 ? e : pe == null ? void 0 : pe.sub) !== null && t !== void 0 ? t : (n = ge == null ? void 0 : ge.account_info) === null || n === void 0 ? void 0 : n.account;
    }), this.picture = Ue(() => {
      var e, t, n, s, i, o, a;
      return (e = pe == null ? void 0 : pe.picture) !== null && e !== void 0 ? e : ((n = (t = We == null ? void 0 : We.sub) !== null && t !== void 0 ? t : pe == null ? void 0 : pe.sub) !== null && n !== void 0 ? n : !((s = ge == null ? void 0 : ge.account_info) === null || s === void 0) && s.account) ? `https://xumm.app/avatar/${(o = (i = We == null ? void 0 : We.sub) !== null && i !== void 0 ? i : pe == null ? void 0 : pe.sub) !== null && o !== void 0 ? o : (a = ge == null ? void 0 : ge.account_info) === null || a === void 0 ? void 0 : a.account}.png` : void 0;
    }), this.name = Ue(() => {
      var e, t;
      return (e = pe == null ? void 0 : pe.name) !== null && e !== void 0 ? e : (t = ge == null ? void 0 : ge.account_info) === null || t === void 0 ? void 0 : t.name;
    }), this.domain = Ue(() => {
      var e, t;
      return (e = pe == null ? void 0 : pe.domain) !== null && e !== void 0 ? e : (t = ge == null ? void 0 : ge.account_info) === null || t === void 0 ? void 0 : t.domain;
    }), this.source = Ue(() => {
      var e, t;
      return (e = pe == null ? void 0 : pe.source) !== null && e !== void 0 ? e : (t = ge == null ? void 0 : ge.account_info) === null || t === void 0 ? void 0 : t.source;
    }), this.networkType = Ue(() => {
      var e, t;
      return (t = (e = pe == null ? void 0 : pe.networkType) !== null && e !== void 0 ? e : We.network_type) !== null && t !== void 0 ? t : ge == null ? void 0 : ge.nodetype;
    }), this.networkEndpoint = Ue(() => {
      var e, t;
      return (t = (e = pe == null ? void 0 : pe.networkEndpoint) !== null && e !== void 0 ? e : We.network_endpoint) !== null && t !== void 0 ? t : ge == null ? void 0 : ge.nodewss;
    }), this.networkId = Ue(() => {
      var e, t;
      return (t = (e = pe == null ? void 0 : pe.networkId) !== null && e !== void 0 ? e : We.network_id) !== null && t !== void 0 ? t : ge == null ? void 0 : ge.networkid;
    }), this.blocked = Ue(() => {
      var e, t;
      return (e = pe == null ? void 0 : pe.blocked) !== null && e !== void 0 ? e : (t = ge == null ? void 0 : ge.account_info) === null || t === void 0 ? void 0 : t.blocked;
    }), this.kycApproved = Ue(() => {
      var e, t;
      return (e = pe == null ? void 0 : pe.kycApproved) !== null && e !== void 0 ? e : (t = ge == null ? void 0 : ge.account_info) === null || t === void 0 ? void 0 : t.kycApproved;
    }), this.proSubscription = Ue(() => {
      var e, t;
      return (e = pe == null ? void 0 : pe.proSubscription) !== null && e !== void 0 ? e : (t = ge == null ? void 0 : ge.account_info) === null || t === void 0 ? void 0 : t.proSubscription;
    }), this.profile = Ue(() => {
      var e, t, n;
      return (e = pe == null ? void 0 : pe.profile) !== null && e !== void 0 ? e : !((n = (t = ge == null ? void 0 : ge.account_info) === null || t === void 0 ? void 0 : t.profile) === null || n === void 0) && n.slug ? ge.account_info.profile : void 0;
    }), this.token = Ue(() => {
      var e;
      return (e = We == null ? void 0 : We.usertoken_uuidv4) !== null && e !== void 0 ? e : null;
    });
  }
};
var nm = class extends tm.EventEmitter {
  constructor(e, t) {
    var n, s, i, o;
    super(), this.instance = "0", this.jwtCredential = false, this.runtime = at, this.apiKeyOrJwt = "", this.apiKeyOrJwt = e, this.apiSecretOrOtt = t, gd++, this.instance = String(gd), typeof (console == null ? void 0 : console.log) < "u" && (at.cli || console.log("Constructed Xumm", { runtime: rm }));
    let a = false;
    if (typeof this.apiKeyOrJwt == "string" && this.apiKeyOrJwt.split(".").length === 3) {
      let c;
      try {
        c = JSON.parse(fd((n = this.apiKeyOrJwt.split(".")) === null || n === void 0 ? void 0 : n[1]));
      } catch {
      }
      if (Date.now() >= c.exp * 1e3) {
        a = true;
        const l = (o = (i = (s = c == null ? void 0 : c.app_uuidv4) !== null && s !== void 0 ? s : c == null ? void 0 : c.client_id) !== null && i !== void 0 ? i : c == null ? void 0 : c.aud) !== null && o !== void 0 ? o : "";
        if (this.apiKeyOrJwt = l, at.cli || console.log("JWT expired, falling back to API KEY: " + l), at.cli || at.xapp) {
          const d = new Error("JWT Expired, cannot fall back to API credential: in CLI/xApp environment");
          throw this.emit("error", d), d;
        }
      }
      a || (this.jwtCredential = true, fr = this.apiKeyOrJwt);
    }
    this.initialize(), this.user = new yd(), this.environment = {
      jwt: Ue(() => We),
      ott: Ue(() => ge),
      openid: Ue(() => pe),
      bearer: Ue(() => fr),
      ready: new Promise((c) => this.on("ready", () => c(void 0))),
      success: new Promise((c) => this.on("success", () => c(void 0))),
      retrieved: new Promise((c) => this.on("retrieved", () => c(void 0))),
      retrieving: new Promise((c) => this.on("retrieving", () => c(void 0)))
    }, this.state = {
      account: "",
      signedIn: false
    }, this.helpers = Xi(Ue(() => le.XummSdk || le.XummSdkJwt)), this.push = Xi(Ue(() => (le.XummSdk || le.XummSdkJwt).Push)), this.payload = Xi(Ue(() => (le.XummSdk || le.XummSdkJwt).payload)), this.userstore = Xi(Ue(() => (le.XummSdk || le.XummSdkJwt).jwtUserdata)), this.backendstore = Xi(Ue(() => (le.XummSdk || le.XummSdkJwt).storage));
    const u = le == null ? void 0 : le.xApp;
    u && (this.xapp = u), setTimeout(
      () => Promise.all([
        ...Tr.filter((c) => (c == null ? void 0 : c.promiseType) !== "pkceRetrieverResolver"),
        /**
         * If PKCE flow: wait for `ready` till account is known
         */
        at.xapp ? Promise.resolve() : new Promise((c) => {
          var l;
          le != null && le.XummPkce ? (this.user.account.then(() => c()), (l = le.XummPkce) === null || l === void 0 || l.on("loggedout", () => c())) : c();
        })
      ]).then(() => this.emit("ready")),
      // Constructor ready
      0
    );
  }
  initialize() {
    ge = void 0, typeof this.apiKeyOrJwt == "string" && this.apiKeyOrJwt.split(".").length === 3 && fr === this.apiKeyOrJwt || (fr = "", We = {}), pe = {}, gi.XummSdkJwt = false;
    const e = () => Fn(this, void 0, void 0, function* () {
      le != null && le.xApp && (gi.xApp = true, le.xApp.on("qr", (s) => {
        this.emit("qr", s, this.instance);
      }), le.xApp.on("payload", (s) => {
        this.emit("payload", s, this.instance);
      }), le.xApp.on("networkswitch", (s) => {
        this.emit("networkswitch", s, this.instance);
      }), le.xApp.on("destination", (s) => {
        this.emit("destination", s, this.instance);
      }));
    });
    this.handlePkceEvents();
    const t = () => Fn(this, void 0, void 0, function* () {
      var s;
      if (le != null && le.XummSdkJwt && !gi.XummSdkJwt) {
        gi.XummSdkJwt = true;
        const i = this.jwtCredential || fr !== "";
        i || (Tr.push(le.XummSdkJwt.getOttData()), Tr.push(le.XummSdkJwt.getJwt()));
        const o = i ? null : yield le.XummSdkJwt.getOttData(), a = i ? fr : yield le.XummSdkJwt.getJwt();
        if (o && (ge = o, ge != null && ge.account && (this.state.account = ge.account, this.state.signedIn = true), this.emit("retrieved"), this.emit("success")), a) {
          fr = a;
          try {
            We = JSON.parse(fd((s = fr.split(".")) === null || s === void 0 ? void 0 : s[1])), i && this.jwtCredential && (setTimeout(() => this.emit("retrieved"), 0), setTimeout(() => this.emit("success"), 0));
          } catch (u) {
            typeof (console == null ? void 0 : console.log) < "u" && (at.cli || console.log("Error decoding JWT", (u == null ? void 0 : u.message) || ""));
          }
        }
      }
    }), n = () => {
      var s, i, o;
      le != null && le.XummSdkJwt || (Object.assign(le, {
        XummSdkJwt: new (jo()).XummSdkJwt(
          this.apiKeyOrJwt,
          // Get OTT from UA if present, otherwise fall back to default behaviour
          typeof ((s = le == null ? void 0 : le.xApp) === null || s === void 0 ? void 0 : s.getEnvironment) < "u" && ((o = (i = le == null ? void 0 : le.xApp) === null || i === void 0 ? void 0 : i.getEnvironment()) === null || o === void 0 ? void 0 : o.ott) || void 0
        )
      }), Tr.push(t()));
    };
    if (at.xapp) {
      if (typeof this.apiKeyOrJwt != "string" || !(Ki.test(this.apiKeyOrJwt) || this.jwtCredential))
        throw new Error("Running in xApp, constructor requires first param. to be Xumm API Key or JWT");
      le != null && le.xApp || Object.assign(le, {
        xApp: new (Z1()).xApp()
      }), Tr.push(e()), n();
    } else if (at.browser) {
      if (typeof this.apiKeyOrJwt != "string" || !(Ki.test(this.apiKeyOrJwt) || this.jwtCredential))
        throw new Error("Running in browser, constructor requires first param. to be Xumm API Key or JWT");
      if (!(le != null && le.XummPkce) && !at.xapp && (Object.assign(le, {
        XummPkce: new J1.XummPkce(this.apiKeyOrJwt, {
          implicit: true
        })
      }), le.XummPkce))
        if (this.jwtCredential)
          n();
        else {
          setTimeout(() => this.emit("retrieving"), 0);
          const s = (o) => {
            var a, u;
            (u = (a = le.XummPkce) === null || a === void 0 ? void 0 : a.state()) === null || u === void 0 || u.then((c) => {
              var l;
              c != null && c.sdk && !(le != null && le.XummSdkJwt) && (Object.assign(le, { XummSdkJwt: c.sdk }), Object.assign(pe, Object.assign({}, (c == null ? void 0 : c.me) || {})), !((l = c == null ? void 0 : c.me) === null || l === void 0) && l.account && (this.state.account = c.me.account, this.state.signedIn = true)), c != null && c.jwt && fr === "" && (fr = c.jwt, t()), o(c);
            });
          };
          Tr.push(this.handlePkceEvents());
          const i = new Promise((o) => {
            var a, u;
            (a = le.XummPkce) === null || a === void 0 || a.on("retrieved", () => {
              s(o);
            }), (u = le.XummPkce) === null || u === void 0 || u.on("success", () => {
              s(o);
            });
          });
          Tr.push(Object.assign(i, {
            promiseType: "pkceRetrieverResolver"
          }));
        }
    } else if (at.cli) {
      if (typeof this.apiKeyOrJwt != "string")
        throw new Error("Running CLI, constructor needs first param. to be Xumm API Key / raw JWT");
      if (Ki.test(this.apiKeyOrJwt) && (typeof this.apiSecretOrOtt != "string" || !Ki.test(this.apiSecretOrOtt)))
        throw new Error("Running CLI, constructor first param. is API Key, but second param. isn't a valid API Secret");
      if (!Ki.test(this.apiKeyOrJwt) && this.apiKeyOrJwt.split(".").length !== 3)
        throw new Error("Running CLI, constructor first param. not a valid JWT, nor a valid API Key");
      this.jwtCredential ? n() : le != null && le.XummSdk || Object.assign(le, {
        XummSdk: new (jo()).XummSdk(this.apiKeyOrJwt, this.apiSecretOrOtt)
      });
    }
  }
  /**
   * PKCE
   */
  authorize() {
    var e;
    return Fn(this, void 0, void 0, function* () {
      try {
        return yield (e = le == null ? void 0 : le.XummPkce) === null || e === void 0 ? void 0 : e.authorize();
      } catch (t) {
        return t;
      }
    });
  }
  /**
   * TODO: CHECK IF EVENTS ARE NOT REGISTERED AND FIRING TWICE
   */
  handlePkceEvents() {
    return Fn(this, void 0, void 0, function* () {
      if (le != null && le.XummPkce && !gi.XummPkce) {
        gi.XummPkce = true;
        const e = () => this.emit("retrieved"), t = () => this.emit("success"), n = (s) => this.emit("error", s);
        le.XummPkce.on("retrieved", e), le.XummPkce.on("success", t), le.XummPkce.on("error", n);
      }
    });
  }
  logout() {
    var e;
    return Fn(this, void 0, void 0, function* () {
      if (at.xapp)
        return;
      let t = false;
      this.state.account = "", this.state.signedIn = false, typeof this.apiKeyOrJwt == "string" && this.apiKeyOrJwt.split(".").length === 3 && (We != null && We.app_uuidv4) && this.jwtCredential && (this.apiKeyOrJwt = We.app_uuidv4, this.jwtCredential = false, t = true, window._XummPkce = void 0), at.browser && (pe != null && pe.sub || t) && ((e = le == null ? void 0 : le.XummPkce) === null || e === void 0 || e.logout(), Object.assign(le, {
        XummSdk: void 0,
        XummSdkJwt: void 0,
        XummPkce: void 0
      }), Tr.length = 0, this.jwtCredential = false, this.initialize(), this.user = new yd(), this.environment = {
        jwt: Ue(() => We),
        ott: Ue(() => ge),
        openid: Ue(() => pe),
        bearer: Ue(() => fr),
        ready: new Promise((n) => this.on("ready", () => n(void 0))),
        success: new Promise((n) => this.on("success", () => n(void 0))),
        retrieved: new Promise((n) => this.on("retrieved", () => n(void 0))),
        retrieving: new Promise((n) => this.on("retrieving", () => n(void 0)))
      }, this.emit("logout"));
    });
  }
  /**
   * SDK
   */
  ping() {
    var e;
    return Fn(this, void 0, void 0, function* () {
      return yield Promise.all(Tr), (e = (le == null ? void 0 : le.XummSdkJwt) || (le == null ? void 0 : le.XummSdk)) === null || e === void 0 ? void 0 : e.ping();
    });
  }
};
jp = Ju.Xumm = nm;
var kn = ra("[Xaman]");
var im = class {
  constructor(e = {}) {
    this.id = "xaman", this.name = "Xaman", this.icon = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjU2IiBoZWlnaHQ9IjI1NiIgdmlld0JveD0iMCAwIDI1NiAyNTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxnIGNsaXAtcGF0aD0idXJsKCNjbGlwMF8zMTE2Xzk1OCkiPgo8cGF0aCBkPSJNMjU2IDBIMFYyNTZIMjU2VjBaIiBmaWxsPSIjMDAzMENGIi8+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMTUyLjc4MiAtMjM3LjMzOEMyMDguMyAtMjE3LjMyMyAyNjIuMTgzIC0xNzIuNjk0IDI5My45MTQgLTEzNi4zNTlDMzI1LjczIC05OS45MjM4IDM0OC4yMTMgLTU3LjAyMDEgMzUzLjI2MSAtNy41MjA3NEMzNTguMzEgNDEuOTkwOSAzNDUuODg1IDk3LjgwNTEgMzA4LjQwMyAxNTkuOTkzQzI3MS4wMDMgMjIyLjA0NiAxOTMuNjYyIDMxNS4zMDYgMTE3Ljc2OSAzODQuMDM3Qzc5LjgzNDQgNDE4LjM5IDQyLjA4NzkgNDQ2Ljc3NyA5LjczNjk0IDQ2Mi4wMzZDLTYuNDMyNzggNDY5LjY2MyAtMjEuNDU1MSA0NzQuMTA3IC0zNC41OTU4IDQ3NC4yNDFDLTQ3LjgzOCA0NzQuMzc3IC01OS4yMTg5IDQ3MC4xMjIgLTY3LjcyMDQgNDYwLjM4NkMtNzYuMDY2NiA0NTAuODI5IC04Mi4xODggNDM1LjMzMSAtODYuNTM0MyA0MTUuNzE3Qy05MC44OTg4IDM5Ni4wMjEgLTkzLjU0NTMgMzcxLjgyNyAtOTQuNzA0NiAzNDQuNTU3Qy05Ny4wMjM0IDI5MC4wMDggLTkzLjQwMjIgMjIyLjg2MSAtODUuNDg1OCAxNTQuMTc0Qy03Ny41Njg0IDg1LjQ3NzMgLTY1LjM0NTMgMTUuMTU5NiAtNTAuNDMxNSAtNDUuNzQzMUMtMzUuNTM2MiAtMTA2LjU3IC0xNy44OTc0IC0xNTguMjYgMC45NDc1NDggLTE4OS41MjdDMTkuODk1MyAtMjIwLjk2NCA0My44NjY3IC0yMzguMDgyIDcwLjI2OTYgLTI0NC42OTNDOTYuNTg3MiAtMjUxLjI4MyAxMjQuOTk3IC0yNDcuMzU1IDE1Mi43ODIgLTIzNy4zMzhaTTcxLjYwNTUgLTIzOS4zNThDNDYuNzgwMiAtMjMzLjE0MiAyMy45NDg5IC0yMTcuMDM1IDUuNjU4MDkgLTE4Ni42ODhDLTEyLjczNTUgLTE1Ni4xNyAtMzAuMjE5IC0xMDUuMTYgLTQ1LjA4OTMgLTQ0LjQzNUMtNTkuOTQxMiAxNi4yMTUxIC03Mi4xMjcyIDg2LjMwMzQgLTgwLjAyMiAxNTQuODA0Qy04Ny45MTc5IDIyMy4zMTMgLTkxLjUxMjIgMjkwLjE1NSAtODkuMjA5NSAzNDQuMzIzQy04OC4wNTggMzcxLjQxMSAtODUuNDM0NSAzOTUuMjU4IC04MS4xNjQ2IDQxNC41MjdDLTc2Ljg3NjYgNDMzLjg3OCAtNzAuOTk5NCA0NDguMjcgLTYzLjU3NzcgNDU2Ljc2OUMtNTYuMzExMSA0NjUuMDkgLTQ2LjU3NzkgNDY4Ljg2MyAtMzQuNjUxOSA0NjguNzQyQy0yMi42MjQzIDQ2OC42MTkgLTguNDI0MTkgNDY0LjUyMSA3LjM5MDY3IDQ1Ny4wNjFDMzkuMDA4OSA0NDIuMTQ4IDc2LjI4MDEgNDE0LjE4OSAxMTQuMDc3IDM3OS45NkMxODkuNjQ0IDMxMS41MjQgMjY2LjYxNiAyMTguNjcgMzAzLjY5MiAxNTcuMTU0QzM0MC42ODggOTUuNzczNiAzNTIuNjk1IDQxLjEzODkgMzQ3Ljc4OSAtNi45NjI3NUMzNDIuODgzIC01NS4wNzY3IDMyMS4wMjUgLTk2Ljk1MDUgMjg5Ljc3MSAtMTMyLjc0MUMyNTguNDI5IC0xNjguNjMxIDIwNS4yODEgLTIxMi41NjQgMTUwLjkxNyAtMjMyLjE2NEMxMjMuNzYgLTI0MS45NTQgOTYuNTE2MSAtMjQ1LjU5NiA3MS42MDU1IC0yMzkuMzU4WiIgZmlsbD0idXJsKCNwYWludDBfbGluZWFyXzMxMTZfOTU4KSIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTE1MC4zOTcgLTIwMS4wNjNDMjAwLjQyMSAtMTgzLjAyOCAyNDguOTUyIC0xNDIuODI4IDI3Ny41MjkgLTExMC4xMDRDMzA2LjE5MyAtNzcuMjggMzI2LjQ1OSAtMzguNjE1MiAzMzEuMDA5IDYuMDAzNDZDMzM1LjU2IDUwLjYzNDQgMzI0LjM1NiAxMDAuOTI2IDI5MC41OTggMTU2LjkzNkMyNTYuOTIyIDIxMi44MSAxODcuMjk3IDI5Ni43NjQgMTE4Ljk3NiAzNTguNjM3Qzg0LjgyODggMzg5LjU2MSA1MC44MzMyIDQxNS4xMzEgMjEuNjgwNyA0MjguODgxQzcuMTEwMjEgNDM1Ljc1NCAtNi40NTA5NiA0MzkuNzcxIC0xOC4zMzMyIDQzOS44OTJDLTMwLjMxNzEgNDQwLjAxNSAtNDAuNjQyMyA0MzYuMTYxIC00OC4zNTUzIDQyNy4zMjlDLTU1LjkxMzIgNDE4LjY3NCAtNjEuNDM0NyA0MDQuNjcxIC02NS4zNDkzIDM4Ny4wMDVDLTY5LjI4MiAzNjkuMjU3IC03MS42NjUxIDM0Ny40NjUgLTcyLjcwODggMzIyLjkxM0MtNzQuNzk2NiAyNzMuOCAtNzEuNTM2MiAyMTMuMzUzIC02NC40MTA0IDE1MS41MjVDLTU3LjI4MzUgODkuNjg4NCAtNDYuMjgwOCAyNi4zOTEgLTMyLjg1NTMgLTI4LjQzNDFDLTE5LjQ0ODMgLTgzLjE4MzkgLTMuNTY1NjQgLTEyOS43MzkgMTMuNDE3NCAtMTU3LjkxNkMzMC41MDMyIC0xODYuMjY0IDUyLjEzNDQgLTIwMS43MjEgNzUuOTc1OSAtMjA3LjY5MUM5OS43MzIxIC0yMTMuNjM5IDEyNS4zNTkgLTIxMC4wODkgMTUwLjM5NyAtMjAxLjA2M1pNNzcuMzExOSAtMjAyLjM1NUM1NS4wNDc5IC0xOTYuNzgxIDM0LjU1NjggLTE4Mi4zMzUgMTguMTI3OSAtMTU1LjA3N0MxLjU5NjI2IC0xMjcuNjQ4IC0xNC4xMzExIC04MS43NzM3IC0yNy41MTMyIC0yNy4xMjZDLTQwLjg3NjggMjcuNDQ2NSAtNTEuODQyMyA5MC41MTQ1IC01OC45NDY1IDE1Mi4xNTVDLTY2LjA1MTggMjEzLjgwNSAtNjkuMjg1NCAyNzMuOTQ3IC02Ny4yMTM3IDMyMi42NzlDLTY2LjE3NzggMzQ3LjA1IC02My44MTc3IDM2OC40OTQgLTU5Ljk3OTYgMzg1LjgxNUMtNTYuMTIzMiA0MDMuMjE4IC01MC44NDYgNDE2LjExNSAtNDQuMjEyNiA0MjMuNzExQy0zNy43MzQ1IDQzMS4xMjkgLTI5LjA1NyA0MzQuNTAyIC0xOC4zODk0IDQzNC4zOTNDLTcuNjIwMjEgNDM0LjI4MyA1LjExODc5IDQzMC42MTIgMTkuMzM0NCA0MjMuOTA3QzQ3Ljc1NDIgNDEwLjUwMiA4MS4yNzQ1IDM4NS4zNiAxMTUuMjg0IDM1NC41NkMxODMuMjc5IDI5Mi45ODIgMjUyLjUzNSAyMDkuNDM0IDI4NS44ODcgMTU0LjA5NkMzMTkuMTU5IDk4Ljg5NDYgMzI5Ljk0NSA0OS43ODI0IDMyNS41MzcgNi41NjE0M0MzMjEuMTI5IC0zNi42NzE4IDMwMS40ODcgLTc0LjMwNjcgMjczLjM4NiAtMTA2LjQ4NkMyNDUuMTk4IC0xMzguNzY0IDE5Ny40MDIgLTE3OC4yNyAxNDguNTMyIC0xOTUuODg5QzEyNC4xMjMgLTIwNC42ODkgOTkuNjYxMSAtMjA3Ljk1MiA3Ny4zMTE5IC0yMDIuMzU1WiIgZmlsbD0idXJsKCNwYWludDFfbGluZWFyXzMxMTZfOTU4KSIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTE0OC4wMTIgLTE2NC43ODhDMTkyLjU0MSAtMTQ4LjczNCAyMzUuNzIxIC0xMTIuOTYxIDI2MS4xNDQgLTgzLjg0ODZDMjg2LjY1NCAtNTQuNjM2NCAzMDQuNzAzIC0yMC4yMTA1IDMwOC43NTYgMTkuNTI3NUMzMTIuODEgNTkuMjc3OCAzMDIuODI3IDEwNC4wNDcgMjcyLjc5MyAxNTMuODc4QzI0Mi44NDEgMjAzLjU3NCAxODAuOTMxIDI3OC4yMjMgMTIwLjE4NCAzMzMuMjM3Qzg5LjgyMjkgMzYwLjczMiA1OS41NzgxIDM4My40ODUgMzMuNjI0MSAzOTUuNzI2QzIwLjY1MjkgNDAxLjg0NSA4LjU1MjgxIDQwNS40MzUgLTIuMDcxMDQgNDA1LjU0NEMtMTIuNzk2NSA0MDUuNjUzIC0yMi4wNjYgNDAyLjIwMSAtMjguOTkwNiAzOTQuMjcxQy0zNS43NiAzODYuNTIgLTQwLjY4MTYgMzc0LjAxMSAtNDQuMTY0NSAzNTguMjkzQy00Ny42NjU2IDM0Mi40OTQgLTQ5Ljc4NTEgMzIzLjEwNCAtNTAuNzEzMyAzMDEuMjY5Qy01Mi41NyAyNTcuNTkyIC00OS42NzAzIDIwMy44NDQgLTQzLjMzNTIgMTQ4Ljg3NkMtMzYuOTk4OSA5My44OTk0IC0yNy4yMTY3IDM3LjYyMjMgLTE1LjI3OTUgLTExLjEyNTJDLTMuMzYwNzIgLTU5Ljc5NzQgMTAuNzY1OCAtMTAxLjIxNyAyNS44ODcgLTEyNi4zMDVDNDEuMTEwOCAtMTUxLjU2NCA2MC40MDIgLTE2NS4zNiA4MS42ODIgLTE3MC42ODhDMTAyLjg3NyAtMTc1Ljk5NSAxMjUuNzIxIC0xNzIuODI0IDE0OC4wMTIgLTE2NC43ODhaTTgzLjAxOCAtMTY1LjM1M0M2My4zMTU1IC0xNjAuNDE5IDQ1LjE2NDUgLTE0Ny42MzUgMzAuNTk3NSAtMTIzLjQ2NkMxNS45Mjc3IC05OS4xMjcgMS45NTY0NyAtNTguMzg3MiAtOS45MzczMiAtOS44MTcwNEMtMjEuODEyNyAzOC42Nzc3IC0zMS41NTc3IDk0LjcyNTUgLTM3Ljg3MTMgMTQ5LjUwNkMtNDQuMTg2IDIwNC4yOTYgLTQ3LjA1ODggMjU3LjczOSAtNDUuMjE4MiAzMDEuMDM2Qy00NC4yOTc4IDMyMi42ODggLTQyLjIwMTIgMzQxLjczMSAtMzguNzk0OCAzNTcuMTAzQy0zNS4zNzAyIDM3Mi41NTggLTMwLjY5MjkgMzgzLjk2MSAtMjQuODQ3OSAzOTAuNjU0Qy0xOS4xNTgyIDM5Ny4xNjkgLTExLjUzNjQgNDAwLjE0IC0yLjEyNzIyIDQwMC4wNDRDNy4zODM1NCAzOTkuOTQ3IDE4LjY2MTQgMzk2LjcwMyAzMS4yNzc4IDM5MC43NTJDNTYuNDk5MSAzNzguODU2IDg2LjI2ODYgMzU2LjUzMSAxMTYuNDkyIDMyOS4xNkMxNzYuOTE0IDI3NC40NDEgMjM4LjQ1NCAyMDAuMTk4IDI2OC4wODIgMTUxLjAzOUMyOTcuNjMgMTAyLjAxNiAzMDcuMTk0IDU4LjQyNTggMzAzLjI4NCAyMC4wODU1QzI5OS4zNzMgLTE4LjI2NyAyODEuOTQ5IC01MS42NjMgMjU3LjAwMSAtODAuMjMwOUMyMzEuOTY3IC0xMDguODk4IDE4OS41MjMgLTE0My45NzYgMTQ2LjE0NiAtMTU5LjYxNEMxMjQuNDg0IC0xNjcuNDIzIDEwMi44MDYgLTE3MC4zMDggODMuMDE4IC0xNjUuMzUzWiIgZmlsbD0idXJsKCNwYWludDJfbGluZWFyXzMxMTZfOTU4KSIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTE0NS42MjcgLTEyOC41MTNDMTg0LjY2MiAtMTE0LjQ0IDIyMi40OTEgLTgzLjA5NTIgMjQ0Ljc2IC01Ny41OTM2QzI2Ny4xMTcgLTMxLjk5MjcgMjgyLjk0OSAtMS44MDU2MyAyODYuNTA0IDMzLjA1MTdDMjkwLjA2IDY3LjkyMTIgMjgxLjMgMTA3LjE2OCAyNTQuOTkgMTUwLjgyMUMyMjguNzYxIDE5NC4zMzggMTc0LjU2NiAyNTkuNjgxIDEyMS4zOTIgMzA3LjgzN0M5NC44MTc0IDMzMS45MDQgNjguMzIzNCAzNTEuODM5IDQ1LjU2NzkgMzYyLjU3MkMzNC4xOTU4IDM2Ny45MzYgMjMuNTU2OSAzNzEuMDk5IDE0LjE5MTQgMzcxLjE5NUM0LjcyNDQxIDM3MS4yOTEgLTMuNDg5MzggMzY4LjI0MSAtOS42MjU2NCAzNjEuMjE0Qy0xNS42MDY3IDM1NC4zNjUgLTE5LjkyODMgMzQzLjM1IC0yMi45Nzk1IDMyOS41ODFDLTI2LjA0ODggMzE1LjczIC0yNy45MDQ4IDI5OC43NDIgLTI4LjcxNzUgMjc5LjYyNUMtMzAuMzQzMSAyNDEuMzg0IC0yNy44MDQzIDE5NC4zMzYgLTIyLjI1OTcgMTQ2LjIyOEMtMTYuNzE0MSA5OC4xMTA1IC04LjE1MjM2IDQ4Ljg1MzYgMi4yOTY1NyA2LjE4Mzc1QzEyLjcyNyAtMzYuNDEwOCAyNS4wOTc1IC03Mi42OTU3IDM4LjM1NjYgLTk0LjY5NDZDNTEuNzE4NiAtMTE2Ljg2NCA2OC42Njk2IC0xMjguOTk4IDg3LjM4ODIgLTEzMy42ODZDMTA2LjAyMiAtMTM4LjM1MiAxMjYuMDgzIC0xMzUuNTU4IDE0NS42MjcgLTEyOC41MTNaTTg4LjcyNDIgLTEyOC4zNUM3MS41ODMxIC0xMjQuMDU4IDU1Ljc3MjIgLTExMi45MzUgNDMuMDY3MiAtOTEuODU1NEMzMC4yNTk0IC03MC42MDU0IDE4LjA0NDIgLTM1LjAwMDYgNy42Mzg3MyA3LjQ5MTkzQy0yLjc0ODMxIDQ5LjkwOTEgLTExLjI3MjkgOTguOTM2NiAtMTYuNzk1OSAxNDYuODU3Qy0yMi4zMTk5IDE5NC43ODggLTI0LjgzMTkgMjQxLjUzMSAtMjMuMjIyNCAyNzkuMzkyQy0yMi40MTc1IDI5OC4zMjYgLTIwLjU4NDUgMzE0Ljk2NyAtMTcuNjA5OCAzMjguMzkxQy0xNC42MTY5IDM0MS44OTcgLTEwLjUzOTUgMzUxLjgwNiAtNS40ODI5MiAzNTcuNTk2Qy0wLjU4MTU4MSAzNjMuMjA5IDUuOTg0NTIgMzY1Ljc3OCAxNC4xMzUzIDM2NS42OTVDMjIuMzg3NiAzNjUuNjExIDMyLjIwNDQgMzYyLjc5NCA0My4yMjE2IDM1Ny41OTdDNjUuMjQ0NCAzNDcuMjEgOTEuMjYzMSAzMjcuNzAyIDExNy43IDMwMy43NkMxNzAuNTQ5IDI1NS45IDIyNC4zNzQgMTkwLjk2MiAyNTAuMjggMTQ3Ljk4MkMyNzYuMTAyIDEwNS4xMzcgMjg0LjQ0NSA2Ny4wNjkzIDI4MS4wMzIgMzMuNjA5N0MyNzcuNjE5IDAuMTM3Nzg3IDI2Mi40MTIgLTI5LjAxOTMgMjQwLjYxOCAtNTMuOTc1OUMyMTguNzM3IC03OS4wMzE4IDE4MS42NDQgLTEwOS42ODEgMTQzLjc2MiAtMTIzLjMzOUMxMjQuODQ3IC0xMzAuMTU4IDEwNS45NTEgLTEzMi42NjQgODguNzI0MiAtMTI4LjM1WiIgZmlsbD0idXJsKCNwYWludDNfbGluZWFyXzMxMTZfOTU4KSIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTE0My4yNDIgLTkyLjIzNzVDMTc2Ljc4MyAtODAuMTQ1MiAyMDkuMjYgLTUzLjIyOSAyMjguMzc2IC0zMS4zMzg3QzI0Ny41NzkgLTkuMzQ4OTIgMjYxLjE5NCAxNi41OTkzIDI2NC4yNTEgNDYuNTc2QzI2Ny4zMDkgNzYuNTY0OSAyNTkuNzcxIDExMC4yODkgMjM3LjE4NCAxNDcuNzY0QzIxNC42NzkgMTg1LjEwMyAxNjguMjAxIDI0MS4xNCAxMjIuNiAyODIuNDM4Qzk5LjgxMTUgMzAzLjA3NSA3Ny4wNjg1IDMyMC4xOTMgNTcuNTExNSAzMjkuNDE3QzQ3LjczODcgMzM0LjAyNyAzOC41NjA5IDMzNi43NjMgMzAuNDUzOSAzMzYuODQ2QzIyLjI0NTIgMzM2LjkyOSAxNS4wODcyIDMzNC4yOCA5LjczOTM0IDMyOC4xNTZDNC41NDY3MiAzMjIuMjEgMC44MjQ5NzYgMzEyLjY5IC0xLjc5NDQ4IDMwMC44NjlDLTQuNDMyMDcgMjg4Ljk2NiAtNi4wMjQ1OSAyNzQuMzggLTYuNzIxNyAyNTcuOTgyQy04LjExNjI1IDIyNS4xNzYgLTUuOTM4MTggMTg0LjgyNyAtMS4xODQyNCAxNDMuNTc5QzMuNTcwNzYgMTAyLjMyMiAxMC45MTIxIDYwLjA4NSAxOS44NzI3IDIzLjQ5MjdDMjguODE0OSAtMTMuMDI0MiAzOS40MjkyIC00NC4xNzQyIDUwLjgyNjUgLTYzLjA4MzlDNjIuMzI2NSAtODIuMTY0IDc2LjkzNzMgLTkyLjYzNzIgOTMuMDk0NiAtOTYuNjgzQzEwOS4xNjcgLTEwMC43MDcgMTI2LjQ0NSAtOTguMjkzIDE0My4yNDIgLTkyLjIzNzVaTTk0LjQzMDUgLTkxLjM0NzhDNzkuODUwOCAtODcuNjk3IDY2LjM4MDEgLTc4LjIzNSA1NS41MzcgLTYwLjI0NDdDNDQuNTkxMSAtNDIuMDgzOSAzNC4xMzIxIC0xMS42MTQxIDI1LjIxNDkgMjQuODAwOUMxNi4zMTYxIDYxLjE0MDQgOS4wMTE5NiAxMDMuMTQ4IDQuMjc5NTkgMTQ0LjIwOUMtMC40NTM4NTIgMTg1LjI3OSAtMi42MDUwNiAyMjUuMzIzIC0xLjIyNjY2IDI1Ny43NDhDLTAuNTM3Mjg2IDI3My45NjUgMS4wMzIyMyAyODguMjAzIDMuNTc1MjYgMjk5LjY3OUM2LjEzNjQzIDMxMS4yMzcgOS42MTM4OSAzMTkuNjUxIDEzLjg4MjEgMzI0LjUzOUMxNy45OTUgMzI5LjI0OCAyMy41MDU0IDMzMS40MTYgMzAuMzk3NyAzMzEuMzQ2QzM3LjM5MTYgMzMxLjI3NCA0NS43NDcyIDMyOC44ODUgNTUuMTY1MiAzMjQuNDQzQzczLjk4OTUgMzE1LjU2NCA5Ni4yNTcyIDI5OC44NzQgMTE4LjkwOCAyNzguMzYxQzE2NC4xODMgMjM3LjM1OCAyMTAuMjkyIDE4MS43MjYgMjMyLjQ3NCAxNDQuOTI0QzI1NC41NzMgMTA4LjI1OCAyNjEuNjk0IDc1LjcxMjkgMjU4Ljc3OSA0Ny4xMzRDMjU1Ljg2NCAxOC41NDI3IDI0Mi44NzQgLTYuMzc1NTggMjI0LjIzNCAtMjcuNzIwOUMyMDUuNTA3IC00OS4xNjU2IDE3My43NjUgLTc1LjM4NyAxNDEuMzc3IC04Ny4wNjM0QzEyNS4yMDkgLTkyLjg5MjMgMTA5LjA5NiAtOTUuMDE5OSA5NC40MzA1IC05MS4zNDc4WiIgZmlsbD0idXJsKCNwYWludDRfbGluZWFyXzMxMTZfOTU4KSIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTE0MC44NTcgLTU1Ljk2MjVDMTY4LjkwNCAtNDUuODUxIDE5Ni4wMjkgLTIzLjM2MjkgMjExLjk5MiAtNS4wODM3M0MyMjguMDQxIDEzLjI5NDggMjM5LjQzOSAzNS4wMDQxIDI0MS45OTkgNjAuMTAwMUMyNDQuNTU5IDg1LjIwODQgMjM4LjI0MiAxMTMuNDEgMjE5LjM4IDE0NC43MDZDMjAwLjU5OCAxNzUuODY3IDE2MS44MzUgMjIyLjU5OSAxMjMuODA3IDI1Ny4wMzhDMTA0LjgwNiAyNzQuMjQ2IDg1LjgxMzggMjg4LjU0NyA2OS40NTUxIDI5Ni4yNjNDNjEuMjgxNiAzMDAuMTE4IDUzLjU2NDkgMzAyLjQyNyA0Ni43MTYzIDMwMi40OTdDMzkuNzY2MSAzMDIuNTY4IDMzLjY2MzggMzAwLjMyIDI5LjEwNDQgMjk1LjA5OUMyNC43MDAxIDI5MC4wNTYgMjEuNTc4MyAyODIuMDMgMTkuMzkwNiAyNzIuMTU3QzE3LjE4NDcgMjYyLjIwMiAxNS44NTU3IDI1MC4wMTggMTUuMjc0MSAyMzYuMzM4QzE0LjExMDYgMjA4Ljk2OCAxNS45Mjc5IDE3NS4zMTkgMTkuODkxMiAxNDAuOTNDMjMuODU1NiAxMDYuNTMzIDI5Ljk3NjQgNzEuMzE2MyAzNy40NDg4IDQwLjgwMTZDNDQuOTAyNyAxMC4zNjI0IDUzLjc2MDkgLTE1LjY1MjYgNjMuMjk2MiAtMzEuNDczMUM3Mi45MzQyIC00Ny40NjQxIDg1LjIwNSAtNTYuMjc2MSA5OC44MDA4IC01OS42ODA1QzExMi4zMTEgLTYzLjA2MzYgMTI2LjgwOCAtNjEuMDI3NyAxNDAuODU3IC01NS45NjI1Wk0xMDAuMTM3IC01NC4zNDUzQzg4LjExODUgLTUxLjMzNTggNzYuOTg3OSAtNDMuNTM1MSA2OC4wMDY3IC0yOC42MzM5TDY1LjY1MTUgLTMwLjA1MzVMNjguMDA2NyAtMjguNjMzOUM1OC45MjI4IC0xMy41NjI0IDUwLjIxOTkgMTEuNzcyNSA0Mi43OTA5IDQyLjEwOThDMzUuMzgwNSA3Mi4zNzE4IDI5LjI5NjggMTA3LjM1OSAyNS4zNTUgMTQxLjU2QzIxLjQxMjIgMTc1Ljc3IDE5LjYyMTggMjA5LjExNSAyMC43NjkxIDIzNi4xMDRDMjEuMzQzIDI0OS42MDMgMjIuNjQ5IDI2MS40MzkgMjQuNzYwMyAyNzAuOTY3QzI2Ljg4OTggMjgwLjU3NyAyOS43NjczIDI4Ny40OTYgMzMuMjQ3MSAyOTEuNDgxTDMxLjE3NTcgMjkzLjI5TDMzLjI0NzEgMjkxLjQ4MUMzNi41NzE2IDI5NS4yODggNDEuMDI2MiAyOTcuMDU1IDQ2LjY2MDEgMjk2Ljk5N0M1Mi4zOTU2IDI5Ni45MzggNTkuMjkwMSAyOTQuOTc2IDY3LjEwODggMjkxLjI4OEM4Mi43MzQ3IDI4My45MTggMTAxLjI1MiAyNzAuMDQ1IDEyMC4xMTUgMjUyLjk2MUMxNTcuODE4IDIxOC44MTcgMTk2LjIxMSAxNzIuNDkxIDIxNC42NjkgMTQxLjg2N0MyMzMuMDQ1IDExMS4zNzkgMjM4Ljk0NCA4NC4zNTY0IDIzNi41MjcgNjAuNjU4MUMyMzQuMTA5IDM2Ljk0NzUgMjIzLjMzNiAxNi4yNjgxIDIwNy44NDkgLTEuNDY2MDJDMTkyLjI3NiAtMTkuMjk5NSAxNjUuODg2IC00MS4wOTI4IDEzOC45OTIgLTUwLjc4ODVDMTI1LjU3MSAtNTUuNjI3IDExMi4yNCAtNTcuMzc2IDEwMC4xMzcgLTU0LjM0NTNaIiBmaWxsPSJ1cmwoI3BhaW50NV9saW5lYXJfMzExNl85NTgpIi8+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMTM4LjQ3MiAtMTkuNjg3NUMxNjEuMDI1IC0xMS41NTY3IDE4Mi43OTkgNi41MDMzOCAxOTUuNjA4IDIxLjE3MTJDMjA4LjUwNCAzNS45Mzg0IDIxNy42ODQgNTMuNDA4OSAyMTkuNzQ2IDczLjYyNDJDMjIxLjgwOSA5My44NTE4IDIxNi43MTMgMTE2LjUzMSAyMDEuNTc0IDE0MS42NDlDMTg2LjUxNyAxNjYuNjMxIDE1NS40NyAyMDQuMDU2IDEyNS4wMTUgMjMxLjYzN0MxMDkuOCAyNDUuNDE2IDk0LjU1ODggMjU2Ljg5OSA4MS4zOTg2IDI2My4xMDZDNzQuODI0MyAyNjYuMjA3IDY4LjU2ODcgMjY4LjA4OCA2Mi45Nzg1IDI2OC4xNDVDNTcuMjg2NyAyNjguMjAzIDUyLjI0MDEgMjY2LjM1NyA0OC40NjkgMjYyLjAzOUM0NC44NTMyIDI1Ny44OTggNDIuMzMxMyAyNTEuMzY3IDQwLjU3NTMgMjQzLjQ0M0MzOC44MDEyIDIzNS40MzcgMzcuNzM1NiAyMjUuNjU1IDM3LjI2OTYgMjE0LjY5MkMzNi4zMzcyIDE5Mi43NTkgMzcuNzkzNyAxNjUuODA5IDQwLjk2NjQgMTM4LjI4MUM0NC4xNDAyIDExMC43NDMgNDkuMDQwNiA4Mi41NDcyIDU1LjAyNDcgNTguMTEwM0M2MC45OTAzIDMzLjc0ODggNjguMDkyNCAxMi44Njg4IDc1Ljc2NTggMC4xMzc1MzNDODMuNTQyIC0xMi43NjQyIDkzLjQ3MjYgLTE5LjkxNSAxMDQuNTA3IC0yMi42NzhDMTE1LjQ1NiAtMjUuNDE5NyAxMjcuMTcgLTIzLjc2MjIgMTM4LjQ3MiAtMTkuNjg3NVpNMTA1Ljg0MyAtMTcuMzQyOEM5Ni4zODYxIC0xNC45NzQ3IDg3LjU5NTYgLTguODM1MjUgODAuNDc2NCAyLjk3NjY3TDc4LjEyMTEgMS41NTcxTDgwLjQ3NjQgMi45NzY2OEM3My4yNTQzIDE0Ljk1OTEgNjYuMzA3NSAzNS4xNTg5IDYwLjM2NjggNTkuNDE4NUM1NC40NDQ2IDgzLjYwMjcgNDkuNTgxNCAxMTEuNTY5IDQ2LjQzMDMgMTM4LjkxQzQzLjI3ODEgMTY2LjI2MSA0MS44NDg0IDE5Mi45MDUgNDIuNzY0NiAyMTQuNDU5QzQzLjIyMjkgMjI1LjIzOSA0NC4yNjU1IDIzNC42NzQgNDUuOTQ1MSAyNDIuMjUzQzQ3LjY0MjggMjQ5LjkxNSA0OS45MjA0IDI1NS4zMzkgNTIuNjExNyAyNTguNDIxQzU1LjE0NzkgMjYxLjMyNSA1OC41NDY5IDI2Mi42OSA2Mi45MjI0IDI2Mi42NDZDNjcuMzk5NSAyNjIuNiA3Mi44MzI5IDI2MS4wNjUgNzkuMDUyNCAyNTguMTMxQzkxLjQ3OTggMjUyLjI3IDEwNi4yNDYgMjQxLjIxNCAxMjEuMzIzIDIyNy41NkMxNTEuNDUzIDIwMC4yNzUgMTgyLjEzIDE2My4yNTUgMTk2Ljg2NCAxMzguODFDMjExLjUxNiAxMTQuNSAyMTYuMTkzIDkyLjk5OTggMjE0LjI3NCA3NC4xODIyQzIxMi4zNTQgNTUuMzUyMyAyMDMuNzk4IDM4LjkxMTggMTkxLjQ2NSAyNC43ODg5QzE3OS4wNDUgMTAuNTY2NyAxNTguMDA3IC02Ljc5ODQgMTM2LjYwNyAtMTQuNTEzNEMxMjUuOTMzIC0xOC4zNjE2IDExNS4zODUgLTE5LjczMjEgMTA1Ljg0MyAtMTcuMzQyOFoiIGZpbGw9InVybCgjcGFpbnQ2X2xpbmVhcl8zMTE2Xzk1OCkiLz4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xMzYuMDg3IDE2LjU4NzZDMTUzLjE0NiAyMi43Mzc3IDE2OS41NjggMzYuMzY5NSAxNzkuMjI0IDQ3LjQyNjFDMTg4Ljk2NiA1OC41ODIgMTk1LjkzIDcxLjgxMzYgMTk3LjQ5NCA4Ny4xNDgzQzE5OS4wNTkgMTAyLjQ5NSAxOTUuMTg1IDExOS42NTIgMTgzLjc3IDEzOC41OTJDMTcyLjQzNiAxNTcuMzk1IDE0OS4xMDUgMTg1LjUxNSAxMjYuMjIzIDIwNi4yMzhDMTE0Ljc5NCAyMTYuNTg3IDEwMy4zMDQgMjI1LjI1MyA5My4zNDIzIDIyOS45NTJDODguMzY3MiAyMzIuMjk4IDgzLjU3MjggMjMzLjc1MyA3OS4yNDEgMjMzLjc5N0M3NC44MDc3IDIzMy44NDIgNzAuODE2NyAyMzIuMzk4IDY3LjgzNDEgMjI4Ljk4Mkw2OS45MDU0IDIyNy4xNzNMNjcuODM0MSAyMjguOTgyQzY1LjAwNjYgMjI1Ljc0NCA2My4wODQ3IDIyMC43MDggNjEuNzYwNCAyMTQuNzMyQzYwLjQxNzkgMjA4LjY3MyA1OS42MTU5IDIwMS4yOTMgNTkuMjY1NCAxOTMuMDQ5QzU4LjU2NDEgMTc2LjU1MSA1OS42NTk4IDE1Ni4zIDYyLjA0MTkgMTM1LjYzMkM2NC40MjUxIDExNC45NTQgNjguMTA1IDkzLjc3ODQgNzIuNjAwOCA3NS40MTkxQzc3LjA3ODIgNTcuMTM1MiA4Mi40MjQyIDQxLjM5MDIgODguMjM1NyAzMS43NDgxQzk0LjE0OTkgMjEuOTM1NiAxMDEuNzQgMTYuNDQ2MiAxMTAuMjEzIDE0LjMyNDVDMTE4LjYwMSAxMi4yMjQyIDEyNy41MzIgMTMuNTAzMiAxMzYuMDg3IDE2LjU4NzZaTTExMS41NDkgMTkuNjU5OEMxMDQuNjU0IDIxLjM4NjQgOTguMjAzNSAyNS44NjQ2IDkyLjk0NjIgMzQuNTg3M0w5MC41OTA5IDMzLjE2NzdMOTIuOTQ2MiAzNC41ODczQzg3LjU4NjEgNDMuNDgwNSA4Mi4zOTU0IDU4LjU0NTMgNzcuOTQzIDc2LjcyNzNDNzMuNTA5IDk0LjgzMzkgNjkuODY2MyAxMTUuNzggNjcuNTA1NyAxMzYuMjYxQzY1LjE0NDEgMTU2Ljc1MiA2NC4wNzUyIDE3Ni42OTggNjQuNzYwNCAxOTIuODE1QzY1LjEwMzIgMjAwLjg3OCA2NS44ODIyIDIwNy45MSA2Ny4xMzAxIDIxMy41NDJDNjguMzk2MSAyMTkuMjU1IDcwLjA3MzggMjIzLjE4NSA3MS45NzY4IDIyNS4zNjRMNjkuOTIyNCAyMjcuMTU4TDcxLjk3NjggMjI1LjM2NEM3My43MjQ1IDIyNy4zNjYgNzYuMDY3OCAyMjguMzI5IDc5LjE4NDkgMjI4LjI5OEM4Mi40MDM2IDIyOC4yNjUgODYuMzc1OCAyMjcuMTU3IDkwLjk5NjEgMjI0Ljk3N0MxMDAuMjI1IDIyMC42MjQgMTExLjI0IDIxMi4zODYgMTIyLjUzMSAyMDIuMTYxQzE0NS4wODcgMTgxLjczMyAxNjguMDQ5IDE1NC4wMTkgMTc5LjA1OSAxMzUuNzUyQzE4OS45ODcgMTE3LjYyMSAxOTMuNDQzIDEwMS42NDMgMTkyLjAyMiA4Ny43MDYzQzE5MC41OTkgNzMuNzU3IDE4NC4yNiA2MS41NTU0IDE3NS4wODEgNTEuMDQzOEMxNjUuODE1IDQwLjQzMjkgMTUwLjEyOCAyNy40OTU5IDEzNC4yMjIgMjEuNzYxN0MxMjYuMjk1IDE4LjkwMzkgMTE4LjUzIDE3LjkxMTggMTExLjU0OSAxOS42NTk4WiIgZmlsbD0idXJsKCNwYWludDdfbGluZWFyXzMxMTZfOTU4KSIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzMy43MDIgNTIuODYyOUMxNDUuMjY3IDU3LjAzMjMgMTU2LjMzOCA2Ni4yMzYgMTYyLjg0IDczLjY4MTRDMTY5LjQyOCA4MS4yMjYgMTc0LjE3NSA5MC4yMTg4IDE3NS4yNDEgMTAwLjY3M0MxNzYuMzA4IDExMS4xMzkgMTczLjY1NiAxMjIuNzc0IDE2NS45NjUgMTM1LjUzNEMxNTguMzU1IDE0OC4xNiAxNDIuNzM5IDE2Ni45NzQgMTI3LjQzIDE4MC44MzhDMTE5Ljc4OCAxODcuNzU5IDExMi4wNDkgMTkzLjYwNyAxMDUuMjg2IDE5Ni43OTdDMTAxLjkxIDE5OC4zODkgOTguNTc2NiAxOTkuNDE3IDk1LjUwMzIgMTk5LjQ0OEM5Mi4zMjgzIDE5OS40ODEgODkuMzkzIDE5OC40MzcgODcuMTk4OCAxOTUuOTI1Qzg1LjE1OTcgMTkzLjU5IDgzLjgzNzcgMTkwLjA0OCA4Mi45NDUxIDE4Ni4wMkM4Mi4wMzQ0IDE4MS45MSA4MS40OTU5IDE3Ni45MzIgODEuMjYwOSAxNzEuNDA1QzgwLjc5MDcgMTYwLjM0MyA4MS41MjU2IDE0Ni43OTIgODMuMTE3MSAxMzIuOTgzQzg0LjcwOTYgMTE5LjE2NSA4Ny4xNjkxIDEwNS4wMSA5MC4xNzY2IDkyLjcyODJDOTMuMTY1NyA4MC41MjIgOTYuNzU1NiA2OS45MTE5IDEwMC43MDUgNjMuMzU5MUMxMDQuNzU3IDU2LjYzNTggMTEwLjAwOCA1Mi44MDc2IDExNS45MTkgNTEuMzI3M0MxMjEuNzQ2IDQ5Ljg2ODQgMTI3Ljg5NCA1MC43Njg5IDEzMy43MDIgNTIuODYyOVpNMTE3LjI1NSA1Ni42NjI2QzExMi45MjEgNTcuNzQ3OCAxMDguODExIDYwLjU2NDggMTA1LjQxNiA2Ni4xOTgzTDEwMy4wNiA2NC43Nzg3TDEwNS40MTYgNjYuMTk4M0MxMDEuOTE3IDcyLjAwMjIgOTguNDgyOSA4MS45MzIxIDk1LjUxODggOTQuMDM2NEM5Mi41NzMyIDEwNi4wNjUgOTAuMTUwOCAxMTkuOTkxIDg4LjU4MDkgMTMzLjYxM0M4Ny4wMSAxNDcuMjQ0IDg2LjMwMTkgMTYwLjQ5IDg2Ljc1NiAxNzEuMTcxQzg2Ljk4MzIgMTc2LjUxNiA4Ny40OTg3IDE4MS4xNDcgODguMzE0OSAxODQuODNDODkuMTQ5MiAxODguNTk1IDkwLjIyNjkgMTkxLjAzMSA5MS4zNDE1IDE5Mi4zMDdDOTIuMzAwOCAxOTMuNDA1IDkzLjU4ODQgMTkzLjk2OCA5NS40NDcxIDE5My45NDlDOTcuNDA3MyAxOTMuOTI5IDk5LjkxODUgMTkzLjI0OCAxMDIuOTM5IDE5MS44MjNDMTA4Ljk3IDE4OC45NzggMTE2LjIzNCAxODMuNTU3IDEyMy43MzggMTc2Ljc2MUMxMzguNzIyIDE2My4xOTIgMTUzLjk2OCAxNDQuNzg0IDE2MS4yNTQgMTMyLjY5NUwxNjMuNjA5IDEzNC4xMTVMMTYxLjI1NCAxMzIuNjk1QzE2OC40NTggMTIwLjc0MiAxNzAuNjkzIDExMC4yODcgMTY5Ljc2OSAxMDEuMjMxQzE2OC44NDQgOTIuMTYyMiAxNjQuNzIzIDg0LjE5OTQgMTU4LjY5NyA3Ny4yOTkxTDE2MC43NjggNzUuNDkwMkwxNTguNjk3IDc3LjI5OTFDMTUyLjU4NCA3MC4yOTk0IDE0Mi4yNDkgNjEuNzkwNSAxMzEuODM3IDU4LjAzNjlDMTI2LjY1NyA1Ni4xNjk1IDEyMS42NzUgNTUuNTU2IDExNy4yNTUgNTYuNjYyNloiIGZpbGw9InVybCgjcGFpbnQ4X2xpbmVhcl8zMTE2Xzk1OCkiLz4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xMzEuMzE4IDg5LjEzNzlDMTM3LjM4OCA5MS4zMjY1IDE0My4xMDcgOTYuMTAyMSAxNDYuNDU2IDk5LjkzNjJDMTQ5Ljg5MSAxMDMuODcgMTUyLjQyIDEwOC42MjMgMTUyLjk4OCAxMTQuMTk3QzE1My41NTggMTE5Ljc4MiAxNTIuMTI3IDEyNS44OTUgMTQ4LjE2IDEzMi40NzdMMTQ1LjgwNSAxMzEuMDU3TDE0OC4xNiAxMzIuNDc3QzE0NC4yNzUgMTM4LjkyNCAxMzYuMzc0IDE0OC40MzIgMTI4LjYzOCAxNTUuNDM4QzEyNC43ODMgMTU4LjkzIDEyMC43OTQgMTYxLjk2MSAxMTcuMjMgMTYzLjY0MkMxMTUuNDUzIDE2NC40OCAxMTMuNTgxIDE2NS4wODEgMTExLjc2NiAxNjUuMDk5QzEwOS44NDkgMTY1LjExOSAxMDcuOTcgMTY0LjQ3NyAxMDYuNTY0IDE2Mi44NjdDMTA1LjMxMyAxNjEuNDM1IDEwNC41OTEgMTU5LjM4NyAxMDQuMTMgMTU3LjMwN0MxMDMuNjUxIDE1NS4xNDYgMTAzLjM3NiAxNTIuNTcgMTAzLjI1NyAxNDkuNzYxQzEwMy4wMTggMTQ0LjEzNSAxMDMuMzkyIDEzNy4yODMgMTA0LjE5MyAxMzAuMzM0QzEwNC45OTUgMTIzLjM3NiAxMDYuMjM0IDExNi4yNDEgMTA3Ljc1MyAxMTAuMDM3QzEwOS4yNTQgMTAzLjkwOCAxMTEuMDg3IDk4LjQzMzMgMTEzLjE3NSA5NC45Njk3QzExNS4zNjUgOTEuMzM1NiAxMTguMjc2IDg5LjE2ODcgMTIxLjYyNiA4OC4zMjk4QzEyNC44OTEgODcuNTEyMyAxMjguMjU2IDg4LjAzNDIgMTMxLjMxOCA4OS4xMzc5Wk0xMjIuOTYyIDkzLjY2NTFDMTIxLjE4OSA5NC4xMDkgMTE5LjQxOSA5NS4yNjQ2IDExNy44ODUgOTcuODA4OUMxMTYuMjQ5IDEwMC41MjQgMTE0LjU3MSAxMDUuMzE5IDExMy4wOTUgMTExLjM0NUMxMTEuNjM4IDExNy4yOTYgMTEwLjQzNiAxMjQuMjAyIDEwOS42NTcgMTMwLjk2NEMxMDguODc2IDEzNy43MzUgMTA4LjUyOSAxNDQuMjgxIDEwOC43NTIgMTQ5LjUyN0MxMDguODY0IDE1Mi4xNTQgMTA5LjExNiAxNTQuMzgyIDEwOS41IDE1Ni4xMTdDMTA5LjkwMyAxNTcuOTM0IDExMC4zOCAxNTguODc1IDExMC43MDcgMTU5LjI0OUwxMTAuNzA3IDE1OS4yNDlDMTEwLjg3OCAxNTkuNDQ1IDExMS4xMDkgMTU5LjYwNSAxMTEuNzEgMTU5LjU5OUMxMTIuNDExIDE1OS41OTIgMTEzLjQ2MSAxNTkuMzM4IDExNC44ODMgMTU4LjY2OEMxMTcuNzE1IDE1Ny4zMzIgMTIxLjIyOSAxNTQuNzI4IDEyNC45NDYgMTUxLjM2MUMxMzIuMzU3IDE0NC42NTEgMTM5Ljg4OCAxMzUuNTQ4IDE0My40NSAxMjkuNjM4QzE0Ni45MyAxMjMuODYzIDE0Ny45NDMgMTE4LjkzIDE0Ny41MTcgMTE0Ljc1NUMxNDcuMDkgMTEwLjU2NyAxNDUuMTg1IDEwNi44NDMgMTQyLjMxMyAxMDMuNTU0QzEzOS4zNTQgMTAwLjE2NSAxMzQuMzcgOTYuMDg0OCAxMjkuNDUyIDk0LjMxMkMxMjcuMDIgOTMuNDM0OSAxMjQuODIgOTMuMTk5OSAxMjIuOTYyIDkzLjY2NTFaIiBmaWxsPSJ1cmwoI3BhaW50OV9saW5lYXJfMzExNl85NTgpIi8+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNMjMwLjg3NCAxMTEuNzY0QzIzNi42MTMgMTA1LjUyOCAyMzYuMTQzIDk1Ljg4IDIyOS44MjggOTAuMjE0M0MyMjMuNTEzIDg0LjU0ODggMjEzLjc0MSA4NS4wMTEgMjA4LjAwNSA5MS4yNDczTDE2Ni44NTQgMTM1Ljk3MUwxNTAuMjE3IDExOC43MjJDMTQ0LjMzMyAxMTIuNjIxIDEzNC41NTMgMTEyLjM4NSAxMjguMzc0IDExOC4xOTZDMTIyLjE5NSAxMjQuMDA3IDEyMS45NTcgMTMzLjY2MyAxMjcuODQxIDEzOS43NjRMMTU1LjkzMyAxNjguODg5QzE1OC44OTIgMTcxLjk1NyAxNjMuMDExIDE3My42NzIgMTY3LjMwMyAxNzMuNjIyQzE3MS41OTMgMTczLjU3MiAxNzUuNjcxIDE3MS43NjMgMTc4LjU1NSAxNjguNjI2TDIzMC44NzQgMTExLjc2NFpNMTE0LjQwMyAxNTAuMDU3TDk2LjQ3OCAxMzIuMTk4TDExNC40MDMgMTE0LjM0QzExOC4yNzggMTEwLjUxMyAxMjAuMjE2IDEwNy4yNzEgMTIwLjIxNiAxMDQuNjEzQzEyMC4yMTYgMTAxLjg0OSAxMTguMjc4IDk4LjU1MzggMTE0LjQwMyA5NC43MjdDMTEwLjUyNyA5MC45MDAzIDEwNy4yNDQgODguOTg2OCAxMDQuNTUyIDg4Ljk4NjhDMTAxLjg2MSA4OC45ODY4IDk4LjU3NzMgOTAuOTAwMyA5NC43MDE4IDk0LjcyN0w3Ni45Mzg4IDExMi41ODZMNTkuMDE0MyA5NC43MjdDNTUuMTM4OCA5MC45MDAzIDUxLjg1NTIgODguOTg2OCA0OS4xNjM3IDg4Ljk4NjhDNDYuNTggODguOTg2OCA0My4yOTY1IDkwLjkwMDMgMzkuMzEzMyA5NC43MjdDMzUuNDM3OCA5OC41NTM4IDMzLjUgMTAxLjg0OSAzMy41IDEwNC42MTNDMzMuNSAxMDcuMjcxIDM1LjQzNzggMTEwLjUxMyAzOS4zMTMzIDExNC4zNEw1Ny4yMzggMTMyLjE5OEwzOS4zMTMzIDE1MC4wNTdDMzUuNDM3OCAxNTMuODg0IDMzLjUgMTU3LjE3OSAzMy41IDE1OS45NDNDMzMuNSAxNjIuNiAzNS40Mzc4IDE2NS44NDMgMzkuMzEzMyAxNjkuNjY5QzQzLjI5NjUgMTczLjM5IDQ2LjU4IDE3NS4yNSA0OS4xNjM3IDE3NS4yNUM1MS44NTUyIDE3NS4yNSA1NS4xMzg4IDE3My4zMzcgNTkuMDE0MyAxNjkuNTFMNzYuOTM4OCAxNTEuODExTDk0LjcwMTggMTY5LjUxQzk4LjU3NzMgMTczLjMzNyAxMDEuODYxIDE3NS4yNSAxMDQuNTUyIDE3NS4yNUMxMDcuMjQ0IDE3NS4yNSAxMTAuNTI3IDE3My4zOSAxMTQuNDAzIDE2OS42NjlDMTE4LjI3OCAxNjUuODQzIDEyMC4yMTYgMTYyLjYgMTIwLjIxNiAxNTkuOTQzQzEyMC4yMTYgMTU3LjE3OSAxMTguMjc4IDE1My44ODQgMTE0LjQwMyAxNTAuMDU3WiIgZmlsbD0id2hpdGUiLz4KPC9nPgo8ZGVmcz4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDBfbGluZWFyXzMxMTZfOTU4IiB4MT0iMTg1LjE2NyIgeTE9Ii0yMzIuOTM4IiB4Mj0iNzAuODMyOSIgeTI9IjQ4OC45MzciIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agb2Zmc2V0PSIwLjQ1IiBzdG9wLWNvbG9yPSIjMjI0N0ZGIi8+CjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzBEMUM2NSIvPgo8L2xpbmVhckdyYWRpZW50Pgo8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50MV9saW5lYXJfMzExNl85NTgiIHgxPSIxNzkuNDUiIHkxPSItMTk2Ljg0NCIgeDI9Ijc2LjU0OTgiIHkyPSI0NTIuODQ1IiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CjxzdG9wIG9mZnNldD0iMC40NSIgc3RvcC1jb2xvcj0iIzIyNDdGRiIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiMwRDFDNjUiLz4KPC9saW5lYXJHcmFkaWVudD4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDJfbGluZWFyXzMxMTZfOTU4IiB4MT0iMTczLjczMyIgeTE9Ii0xNjAuNzUiIHgyPSI4Mi4yNjYyIiB5Mj0iNDE2Ljc1IiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CjxzdG9wIG9mZnNldD0iMC40NSIgc3RvcC1jb2xvcj0iIzIyNDdGRiIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiMwRDFDNjUiLz4KPC9saW5lYXJHcmFkaWVudD4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDNfbGluZWFyXzMxMTZfOTU4IiB4MT0iMTY4LjAxNyIgeTE9Ii0xMjQuNjU3IiB4Mj0iODcuOTgzMSIgeTI9IjM4MC42NTgiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agb2Zmc2V0PSIwLjQ1IiBzdG9wLWNvbG9yPSIjMjI0N0ZGIi8+CjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzBEMUM2NSIvPgo8L2xpbmVhckdyYWRpZW50Pgo8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50NF9saW5lYXJfMzExNl85NTgiIHgxPSIxNjIuMyIgeTE9Ii04OC41NjI4IiB4Mj0iOTMuNjk5NyIgeTI9IjM0NC41NjIiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agb2Zmc2V0PSIwLjQ1IiBzdG9wLWNvbG9yPSIjMjI0N0ZGIi8+CjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzBEMUM2NSIvPgo8L2xpbmVhckdyYWRpZW50Pgo8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50NV9saW5lYXJfMzExNl85NTgiIHgxPSIxNTYuNTgzIiB5MT0iLTUyLjQ2OSIgeDI9Ijk5LjQxNjUiIHkyPSIzMDguNDciIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agb2Zmc2V0PSIwLjQ1IiBzdG9wLWNvbG9yPSIjMjI0N0ZGIi8+CjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzBEMUM2NSIvPgo8L2xpbmVhckdyYWRpZW50Pgo8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50Nl9saW5lYXJfMzExNl85NTgiIHgxPSIxNTAuODY3IiB5MT0iLTE2LjM3NTMiIHgyPSIxMDUuMTMzIiB5Mj0iMjcyLjM3NSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPgo8c3RvcCBvZmZzZXQ9IjAuNDUiIHN0b3AtY29sb3I9IiMyMjQ3RkYiLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjMEQxQzY1Ii8+CjwvbGluZWFyR3JhZGllbnQ+CjxsaW5lYXJHcmFkaWVudCBpZD0icGFpbnQ3X2xpbmVhcl8zMTE2Xzk1OCIgeDE9IjE0NS4xNSIgeTE9IjE5LjcxODUiIHgyPSIxMTAuODUiIHkyPSIyMzYuMjgxIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CjxzdG9wIG9mZnNldD0iMC40NSIgc3RvcC1jb2xvcj0iIzIyNDdGRiIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiMwRDFDNjUiLz4KPC9saW5lYXJHcmFkaWVudD4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDhfbGluZWFyXzMxMTZfOTU4IiB4MT0iMTM5LjQzMyIgeTE9IjU1LjgxMjUiIHgyPSIxMTYuNTY2IiB5Mj0iMjAwLjE4OCIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPgo8c3RvcCBvZmZzZXQ9IjAuNDUiIHN0b3AtY29sb3I9IiMyMjQ3RkYiLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjMEQxQzY1Ii8+CjwvbGluZWFyR3JhZGllbnQ+CjxsaW5lYXJHcmFkaWVudCBpZD0icGFpbnQ5X2xpbmVhcl8zMTE2Xzk1OCIgeDE9IjEzMy43MTciIHkxPSI5MS45MDYzIiB4Mj0iMTIyLjI4MyIgeTI9IjE2NC4wOTQiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agb2Zmc2V0PSIwLjQ1IiBzdG9wLWNvbG9yPSIjMjI0N0ZGIi8+CjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzBEMUM2NSIvPgo8L2xpbmVhckdyYWRpZW50Pgo8Y2xpcFBhdGggaWQ9ImNsaXAwXzMxMTZfOTU4Ij4KPHJlY3Qgd2lkdGg9IjI1NiIgaGVpZ2h0PSIyNTYiIHJ4PSI2MCIgZmlsbD0id2hpdGUiLz4KPC9jbGlwUGF0aD4KPC9kZWZzPgo8L3N2Zz4K", this.url = "https://xaman.app", this.client = null, this.currentAccount = null, this.options = e;
  }
  /**
   * Xaman is always available (uses OAuth flow, no extension needed)
   */
  async isAvailable() {
    return true;
  }
  /**
   * Connect to Xaman wallet
   */
  async connect(e) {
    const t = (e == null ? void 0 : e.apiKey) || this.options.apiKey;
    if (!t)
      throw me.connectionFailed(
        this.name,
        new Error(
          "API key is required for Xaman. Please provide it in connect options or adapter constructor."
        )
      );
    const n = (e == null ? void 0 : e.onQRCode) || this.options.onQRCode, s = (e == null ? void 0 : e.onDeepLink) || this.options.onDeepLink;
    n && (this.options.onQRCode = n), s && (this.options.onDeepLink = s);
    try {
      this.client = new jp(t), kn.debug("Starting authorization flow");
      const i = await this.client.authorize();
      if (!i || i instanceof Error)
        throw i || new Error("Authorization failed");
      kn.debug("Authorization successful");
      const o = i.me.account, a = this.parseNetwork(i.me.networkEndpoint || "");
      return this.currentAccount = {
        address: o,
        publicKey: void 0,
        // Xaman doesn't expose public key in authorize response
        network: a
      }, this.currentAccount;
    } catch (i) {
      throw kn.error("Authorization failed:", i), me.connectionFailed(this.name, i);
    }
  }
  /**
   * Disconnect from Xaman
   */
  async disconnect() {
    if (this.client)
      try {
        await this.client.logout(), this.cleanup();
      } catch {
        this.cleanup();
      }
  }
  /**
   * Get current account
   */
  async getAccount() {
    return this.currentAccount;
  }
  /**
   * Get current network
   */
  async getNetwork() {
    if (!this.currentAccount)
      throw me.notConnected();
    return this.currentAccount.network;
  }
  /**
   * Sign and optionally submit a transaction
   * Note: Xaman only supports signing via popup flow. The submit parameter is ignored.
   * Users must submit the signed transaction separately or use Xaman's auto-submit feature.
   */
  async signAndSubmit(e, t) {
    var n;
    if (!this.client || !this.currentAccount)
      throw me.notConnected();
    try {
      const s = await ((n = this.client.payload) == null ? void 0 : n.createAndSubscribe(e));
      if (!s)
        throw new Error("Failed to create payload");
      this.openSignWindow(s.created.next.always);
      const i = await this.waitForSignature(s.websocket.url);
      if (!i.signed)
        throw me.signRejected();
      return {
        hash: i.txid || "",
        tx_blob: i.tx_blob,
        signature: i.signature
      };
    } catch (s) {
      throw s instanceof Error && s.message.includes("rejected") ? me.signRejected() : me.signFailed(s);
    }
  }
  /**
   * Sign a message (for authentication/verification)
   */
  async signMessage(e) {
    var t;
    if (!this.client || !this.currentAccount)
      throw me.notConnected();
    try {
      const n = typeof e == "string" ? e : new TextDecoder().decode(e), s = await ((t = this.client.payload) == null ? void 0 : t.create({
        TransactionType: "SignIn"
      }));
      if (!s)
        throw new Error("Failed to create sign message payload");
      return this.openSignWindow(s.next.always), {
        message: n,
        signature: "",
        // Would need to extract from Xaman response
        publicKey: this.currentAccount.publicKey || ""
      };
    } catch (n) {
      throw me.signFailed(n);
    }
  }
  /**
   * Parse network from endpoint URL
   */
  parseNetwork(e) {
    const t = e.toLowerCase();
    return t.includes("testnet") || t.includes("altnet") ? {
      id: "testnet",
      name: "Testnet",
      wss: e,
      walletConnectId: "xrpl:1"
    } : t.includes("devnet") ? {
      id: "devnet",
      name: "Devnet",
      wss: e,
      walletConnectId: "xrpl:2"
    } : {
      id: "mainnet",
      name: "Mainnet",
      wss: e || "wss://xrplcluster.com",
      walletConnectId: "xrpl:0"
    };
  }
  /**
   * Open popup window for signing or trigger QR code callback
   */
  openSignWindow(e) {
    if (kn.debug("openSignWindow called with URL:", e.substring(0, 50) + "..."), kn.debug("onQRCode callback exists:", !!this.options.onQRCode), this.options.onQRCode) {
      kn.debug("Calling onQRCode callback"), this.options.onQRCode(e);
      return;
    }
    kn.debug("Opening popup window");
    const t = 500, n = 600, s = window.screen.width / 2 - t / 2, i = window.screen.height / 2 - n / 2;
    window.open(
      e,
      "Xaman Sign",
      `width=${t},height=${n},left=${s},top=${i},resizable=yes,scrollbars=yes`
    );
  }
  /**
   * Get deep link URI for mobile (Xaman app)
   */
  getDeepLinkURI(e) {
    return this.options.onDeepLink ? this.options.onDeepLink(e) : `xumm://xumm.app/sign/${e.split("/").pop()}`;
  }
  /**
   * Wait for signature via WebSocket
   */
  waitForSignature(e) {
    return new Promise((t, n) => {
      const s = new WebSocket(e), i = setTimeout(
        () => {
          s.close(), n(new Error("Signing timeout - user did not respond"));
        },
        5 * 60 * 1e3
      );
      s.onmessage = (o) => {
        try {
          const a = JSON.parse(o.data);
          a.signed === true ? (clearTimeout(i), s.close(), t({
            signed: true,
            txid: a.txid,
            tx_blob: a.tx_blob,
            signature: a.signature,
            account: a.account
          })) : a.signed === false && (clearTimeout(i), s.close(), n(new Error("Transaction signing was rejected by user")));
        } catch (a) {
          clearTimeout(i), s.close(), n(a);
        }
      }, s.onerror = (o) => {
        clearTimeout(i), n(new Error("WebSocket error: " + o));
      }, s.onclose = () => {
        clearTimeout(i);
      };
    });
  }
  /**
   * Cleanup adapter state
   */
  cleanup() {
    this.client = null, this.currentAccount = null;
  }
};
var Cp = { exports: {} };
(function(r, e) {
  (function(t, n) {
    r.exports = n();
  })(B, () => (() => {
    var t = { 7531: (s) => {
      var i = typeof Reflect == "object" ? Reflect : null, o = i && typeof i.apply == "function" ? i.apply : function(v, E, A) {
        return Function.prototype.apply.call(v, E, A);
      }, a = i && typeof i.ownKeys == "function" ? i.ownKeys : Object.getOwnPropertySymbols ? function(v) {
        return Object.getOwnPropertyNames(v).concat(Object.getOwnPropertySymbols(v));
      } : function(v) {
        return Object.getOwnPropertyNames(v);
      }, u = Number.isNaN || function(v) {
        return v != v;
      };
      function c() {
        c.init.call(this);
      }
      s.exports = c, s.exports.once = function(v, E) {
        return new Promise(function(A, k) {
          function U(H) {
            v.removeListener(E, P), k(H);
          }
          function P() {
            typeof v.removeListener == "function" && v.removeListener("error", U), A([].slice.call(arguments));
          }
          var $, ee, G;
          D(v, E, P, { once: true }), E !== "error" && (ee = U, G = { once: true }, typeof ($ = v).on == "function") && D($, "error", ee, G);
        });
      }, (c.EventEmitter = c).prototype._events = void 0, c.prototype._eventsCount = 0, c.prototype._maxListeners = void 0;
      var l = 10;
      function d(v) {
        if (typeof v != "function") throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof v);
      }
      function h(v) {
        return v._maxListeners === void 0 ? c.defaultMaxListeners : v._maxListeners;
      }
      function f(v, E, A, k) {
        var U, P;
        return d(A), (U = v._events) === void 0 ? (U = v._events = /* @__PURE__ */ Object.create(null), v._eventsCount = 0) : (U.newListener !== void 0 && (v.emit("newListener", E, A.listener || A), U = v._events), P = U[E]), P === void 0 ? (P = U[E] = A, ++v._eventsCount) : (typeof P == "function" ? P = U[E] = k ? [A, P] : [P, A] : k ? P.unshift(A) : P.push(A), 0 < (U = h(v)) && P.length > U && !P.warned && (P.warned = true, (k = new Error("Possible EventEmitter memory leak detected. " + P.length + " " + String(E) + " listeners added. Use emitter.setMaxListeners() to increase limit")).name = "MaxListenersExceededWarning", k.emitter = v, k.type = E, k.count = P.length, A = k, console) && console.warn && console.warn(A)), v;
      }
      function g(v, E, A) {
        return v = { fired: false, wrapFn: void 0, target: v, type: E, listener: A }, E = (function() {
          if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
        }).bind(v), E.listener = A, v.wrapFn = E;
      }
      function p(v, E, A) {
        if (v = v._events, v === void 0) return [];
        if (v = v[E], v === void 0) return [];
        if (typeof v == "function") return A ? [v.listener || v] : [v];
        if (A) {
          for (var k = v, U = new Array(k.length), P = 0; P < U.length; ++P) U[P] = k[P].listener || k[P];
          return U;
        }
        return _(v, v.length);
      }
      function b(v) {
        var E = this._events;
        if (E !== void 0) {
          if (E = E[v], typeof E == "function") return 1;
          if (E !== void 0) return E.length;
        }
        return 0;
      }
      function _(v, E) {
        for (var A = new Array(E), k = 0; k < E; ++k) A[k] = v[k];
        return A;
      }
      function D(v, E, A, k) {
        if (typeof v.on == "function") k.once ? v.once(E, A) : v.on(E, A);
        else {
          if (typeof v.addEventListener != "function") throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof v);
          v.addEventListener(E, function U(P) {
            k.once && v.removeEventListener(E, U), A(P);
          });
        }
      }
      Object.defineProperty(c, "defaultMaxListeners", { enumerable: true, get: function() {
        return l;
      }, set: function(v) {
        if (typeof v != "number" || v < 0 || u(v)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + v + ".");
        l = v;
      } }), c.init = function() {
        this._events !== void 0 && this._events !== Object.getPrototypeOf(this)._events || (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
      }, c.prototype.setMaxListeners = function(v) {
        if (typeof v != "number" || v < 0 || u(v)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + v + ".");
        return this._maxListeners = v, this;
      }, c.prototype.getMaxListeners = function() {
        return h(this);
      }, c.prototype.emit = function(v) {
        for (var E = [], A = 1; A < arguments.length; A++) E.push(arguments[A]);
        var k = v === "error", U = this._events;
        if (U !== void 0) k = k && U.error === void 0;
        else if (!k) return false;
        if (k)
          throw (P = 0 < E.length ? E[0] : P) instanceof Error ? P : (k = new Error("Unhandled error." + (P ? " (" + P.message + ")" : "")), k.context = P, k);
        var P = U[v];
        if (P === void 0) return false;
        if (typeof P == "function") o(P, this, E);
        else for (var $ = P.length, ee = _(P, $), A = 0; A < $; ++A) o(ee[A], this, E);
        return true;
      }, c.prototype.on = c.prototype.addListener = function(v, E) {
        return f(this, v, E, false);
      }, c.prototype.prependListener = function(v, E) {
        return f(this, v, E, true);
      }, c.prototype.once = function(v, E) {
        return d(E), this.on(v, g(this, v, E)), this;
      }, c.prototype.prependOnceListener = function(v, E) {
        return d(E), this.prependListener(v, g(this, v, E)), this;
      }, c.prototype.off = c.prototype.removeListener = function(v, E) {
        var A, k, U, P, $;
        if (d(E), (k = this._events) !== void 0 && (A = k[v]) !== void 0) {
          if (A === E || A.listener === E) --this._eventsCount == 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete k[v], k.removeListener && this.emit("removeListener", v, A.listener || E));
          else if (typeof A != "function") {
            for (U = -1, P = A.length - 1; 0 <= P; P--) if (A[P] === E || A[P].listener === E) {
              $ = A[P].listener, U = P;
              break;
            }
            if (U < 0) return this;
            if (U === 0) A.shift();
            else {
              for (var ee = A, G = U; G + 1 < ee.length; G++) ee[G] = ee[G + 1];
              ee.pop();
            }
            A.length === 1 && (k[v] = A[0]), k.removeListener !== void 0 && this.emit("removeListener", v, $ || E);
          }
        }
        return this;
      }, c.prototype.removeAllListeners = function(v) {
        var E, A = this._events;
        if (A !== void 0) {
          if (A.removeListener === void 0) arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : A[v] !== void 0 && (--this._eventsCount == 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete A[v]);
          else if (arguments.length === 0) {
            for (var k, U = Object.keys(A), P = 0; P < U.length; ++P) (k = U[P]) !== "removeListener" && this.removeAllListeners(k);
            this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0;
          } else if (typeof (E = A[v]) == "function") this.removeListener(v, E);
          else if (E !== void 0) for (P = E.length - 1; 0 <= P; P--) this.removeListener(v, E[P]);
        }
        return this;
      }, c.prototype.listeners = function(v) {
        return p(this, v, true);
      }, c.prototype.rawListeners = function(v) {
        return p(this, v, false);
      }, c.listenerCount = function(v, E) {
        return typeof v.listenerCount == "function" ? v.listenerCount(E) : b.call(v, E);
      }, c.prototype.listenerCount = b, c.prototype.eventNames = function() {
        return 0 < this._eventsCount ? a(this._events) : [];
      };
    }, 9616: function(s, i, o) {
      var a = this && this.__createBinding || (Object.create ? function(g, p, b, _) {
        _ === void 0 && (_ = b);
        var D = Object.getOwnPropertyDescriptor(p, b);
        D && ("get" in D ? p.__esModule : !D.writable && !D.configurable) || (D = { enumerable: true, get: function() {
          return p[b];
        } }), Object.defineProperty(g, _, D);
      } : function(g, p, b, _) {
        g[_ = _ === void 0 ? b : _] = p[b];
      }), u = this && this.__setModuleDefault || (Object.create ? function(g, p) {
        Object.defineProperty(g, "default", { enumerable: true, value: p });
      } : function(g, p) {
        g.default = p;
      }), c = this && this.__importStar || function(g) {
        if (g && g.__esModule) return g;
        var p = {};
        if (g != null) for (var b in g) b !== "default" && Object.prototype.hasOwnProperty.call(g, b) && a(p, g, b);
        return u(p, g), p;
      };
      Object.defineProperty(i, "__esModule", { value: true }), i.Sdk = void 0;
      const l = c(o(5149)), d = c(o(9386));
      var h = c(o(9815));
      class f extends l.CustomEmitter {
        constructor(b) {
          super();
          S(this, "mount");
          S(this, "api");
          S(this, "session");
          S(this, "env");
          S(this, "async");
          S(this, "sync");
          S(this, "methods");
          S(this, "app", h.Projects.titles.crossmark);
          b != null && b.project && (this.app = b == null ? void 0 : b.project), this.env = new l.Env(), this.api = new l.Api(this), this.session = new l.Session(this), this.mount = new l.Mount(this), this.async = new d.Async(this), this.sync = new d.Sync(this), this.methods = Object.assign({}, this.async, this.sync), new l.CustomEvents(this);
        }
      }
      i.Sdk = f;
    }, 614: function(s, i, o) {
      var a = this && this.__createBinding || (Object.create ? function(d, h, f, g) {
        g === void 0 && (g = f);
        var p = Object.getOwnPropertyDescriptor(h, f);
        p && ("get" in p ? h.__esModule : !p.writable && !p.configurable) || (p = { enumerable: true, get: function() {
          return h[f];
        } }), Object.defineProperty(d, g, p);
      } : function(d, h, f, g) {
        d[g = g === void 0 ? f : g] = h[f];
      }), u = this && this.__setModuleDefault || (Object.create ? function(d, h) {
        Object.defineProperty(d, "default", { enumerable: true, value: h });
      } : function(d, h) {
        d.default = h;
      }), c = this && this.__importStar || function(d) {
        if (d && d.__esModule) return d;
        var h = {};
        if (d != null) for (var f in d) f !== "default" && Object.prototype.hasOwnProperty.call(d, f) && a(h, d, f);
        return u(h, d), h;
      };
      Object.defineProperty(i, "__esModule", { value: true }), i.Async = void 0;
      const l = c(o(9815));
      i.Async = class {
        constructor(d) {
          S(this, "sdk");
          S(this, "api");
          S(this, "session");
          S(this, "mount");
          S(this, "signInAndWait", (d6) => this.api.awaitRequest({ command: l.COMMANDS.SIGN, data: { tx: { TransactionType: "SignIn" }, hex: d6 } }));
          S(this, "signAndWait", (d6, h) => this.api.awaitRequest({ command: l.COMMANDS.SIGN, data: { tx: d6, opts: h } }));
          S(this, "submitAndWait", (d6, h, f) => this.api.awaitRequest({ command: l.COMMANDS.SUBMIT, data: { address: d6, txblob: h, opts: f } }));
          S(this, "signAndSubmitAndWait", (d6, h) => this.api.awaitRequest({ command: l.COMMANDS.SIGNANDSUBMIT, data: { tx: d6, opts: h } }));
          S(this, "bulkSignAndWait", (d6, h) => this.api.awaitRequest({ command: l.COMMANDS.BULKSIGN, data: { txns: d6, opts: h } }));
          S(this, "bulkSubmitAndWait", (d6, h, f) => this.api.awaitRequest({ command: l.COMMANDS.BULKSUBMIT, data: { address: d6, txblobs: h, opts: f } }));
          S(this, "bulkSignAndSubmitAndWait", (d6, h) => this.api.awaitRequest({ command: l.COMMANDS.BULK, data: { txns: d6, opts: h } }));
          S(this, "encryptAndWait", { aes: (d6, h, f) => this.api.awaitRequest({ command: l.COMMANDS.ENCRYPT, data: { address: d6, data: h, opts: f } }) });
          S(this, "decryptAndAwait", { aes: (d6, h, f) => this.api.awaitRequest({ command: l.COMMANDS.DECRYPT, data: { address: d6, hex: h, opts: f } }) });
          S(this, "isLockedAndWait", () => this.api.awaitRequest({ command: l.COMMANDS.IS_LOCKED }));
          S(this, "versionAndWait", () => this.api.awaitRequest({ command: l.COMMANDS.VERSION }));
          S(this, "verifyAndWait", (d6) => this.api.awaitRequest({ command: l.COMMANDS.VERIFY, data: { hex: d6 } }));
          S(this, "connect", (d6) => this.mount.loop(d6));
          S(this, "detect", (d6) => this.mount.loop(d6));
          this.sdk = d, this.api = d.api, this.session = d.session, this.mount = d.mount;
        }
      };
    }, 9386: (s, i, o) => {
      Object.defineProperty(i, "__esModule", { value: true }), i.Sync = i.Async = void 0;
      var a = o(614), u = (Object.defineProperty(i, "Async", { enumerable: true, get: function() {
        return a.Async;
      } }), o(8258));
      Object.defineProperty(i, "Sync", { enumerable: true, get: function() {
        return u.Sync;
      } });
    }, 8258: function(s, i, o) {
      var a = this && this.__createBinding || (Object.create ? function(d, h, f, g) {
        g === void 0 && (g = f);
        var p = Object.getOwnPropertyDescriptor(h, f);
        p && ("get" in p ? h.__esModule : !p.writable && !p.configurable) || (p = { enumerable: true, get: function() {
          return h[f];
        } }), Object.defineProperty(d, g, p);
      } : function(d, h, f, g) {
        d[g = g === void 0 ? f : g] = h[f];
      }), u = this && this.__setModuleDefault || (Object.create ? function(d, h) {
        Object.defineProperty(d, "default", { enumerable: true, value: h });
      } : function(d, h) {
        d.default = h;
      }), c = this && this.__importStar || function(d) {
        if (d && d.__esModule) return d;
        var h = {};
        if (d != null) for (var f in d) f !== "default" && Object.prototype.hasOwnProperty.call(d, f) && a(h, d, f);
        return u(h, d), h;
      };
      Object.defineProperty(i, "__esModule", { value: true }), i.Sync = void 0;
      const l = c(o(9815));
      i.Sync = class {
        constructor(d) {
          S(this, "sdk");
          S(this, "api");
          S(this, "session");
          S(this, "mount");
          S(this, "signIn", (d6) => this.api.request({ command: l.COMMANDS.SIGN, data: { tx: { TransactionType: "SignIn" }, hex: d6 } }));
          S(this, "sign", (d6, h) => this.api.request({ command: l.COMMANDS.SIGN, data: { tx: d6, opts: h } }));
          S(this, "submit", (d6, h, f) => this.api.request({ command: l.COMMANDS.SUBMIT, data: { address: d6, txblob: h, opts: f } }));
          S(this, "signAndSubmit", (d6, h) => this.api.request({ command: l.COMMANDS.SIGNANDSUBMIT, data: { tx: d6, opts: h } }));
          S(this, "bulkSign", (d6, h) => this.api.request({ command: l.COMMANDS.BULKSIGN, data: { txns: d6, opts: h } }));
          S(this, "bulkSubmit", (d6, h, f) => this.api.request({ command: l.COMMANDS.BULKSUBMIT, data: { address: d6, txblobs: h, opts: f } }));
          S(this, "encrypt", { aes: (d6, h, f) => this.api.request({ command: l.COMMANDS.ENCRYPT, data: { address: d6, data: h, opts: f } }) });
          S(this, "decrypt", { aes: (d6, h, f) => this.api.request({ command: l.COMMANDS.DECRYPT, data: { address: d6, hex: h, opts: f } }) });
          S(this, "bulkSignAndSubmit", (d6, h) => this.api.request({ command: l.COMMANDS.BULK, data: { txns: d6, opts: h } }));
          S(this, "getResponse", (d6) => this.session.responses.get(d6));
          S(this, "isConnected", () => this.mount.isDetected);
          S(this, "isInstalled", () => this.mount.isDetected);
          S(this, "isLocked", () => this.api.request({ command: l.COMMANDS.IS_LOCKED }));
          S(this, "isOpen", () => this.session.isOpen);
          S(this, "version", () => this.api.request({ command: l.COMMANDS.VERSION }));
          S(this, "verify", (d6) => this.api.request({ command: l.COMMANDS.VERIFY, data: { hex: d6 } }));
          S(this, "getAddress", () => this.session.address);
          S(this, "getNetwork", () => this.session.network);
          S(this, "getUser", () => this.session.user);
          this.sdk = d, this.api = d.api, this.session = d.session, this.mount = d.mount;
        }
      };
    }, 6515: function(s, i, o) {
      var g, p, b;
      var a = this && this.__createBinding || (Object.create ? function(_, D, v, E) {
        E === void 0 && (E = v);
        var A = Object.getOwnPropertyDescriptor(D, v);
        A && ("get" in A ? D.__esModule : !A.writable && !A.configurable) || (A = { enumerable: true, get: function() {
          return D[v];
        } }), Object.defineProperty(_, E, A);
      } : function(_, D, v, E) {
        _[E = E === void 0 ? v : E] = D[v];
      }), u = this && this.__setModuleDefault || (Object.create ? function(_, D) {
        Object.defineProperty(_, "default", { enumerable: true, value: D });
      } : function(_, D) {
        _.default = D;
      }), c = this && this.__importStar || function(_) {
        if (_ && _.__esModule) return _;
        var D = {};
        if (_ != null) for (var v in _) v !== "default" && Object.prototype.hasOwnProperty.call(_, v) && a(D, _, v);
        return u(D, _), D;
      }, l = this && this.__importDefault || function(_) {
        return _ && _.__esModule ? _ : { default: _ };
      }, l = (Object.defineProperty(i, "__esModule", { value: true }), i.Api = void 0, l(o(7531)));
      const d = c(o(9815)), h = o(266);
      class f extends l.default {
        constructor(v) {
          super();
          S(this, "sdk");
          S(this, "active", /* @__PURE__ */ new Map());
          S(this, "uuid");
          S(this, "connected");
          S(this, "target");
          S(this, "timestamp");
          Hs(this, g, (v6) => {
            var U, P, $, ee;
            try {
              if (window && (!window || v6.source === window && v6.source && v6.origin === window.location.origin) && v6.data) {
                var E = ((U = v6.data) == null ? void 0 : U.type) || void 0, A = ((P = v6.data) == null ? void 0 : P.response) || void 0, k = (($ = v6.data) == null ? void 0 : $.app) || void 0;
                if ((E !== "request" || k === this.sdk.app) && E !== d.TYPES.UPDATE) return E === d.TYPES.EVENT && "type" in v6.data ? Vi(this, p).call(this, v6.data) : (A && A.type === d.TYPES.RESPONSE && this.emit(d.EVENTS.RESPONSE, v6.data), A && A.type === d.EVENTS.RESPONSE && this.active.get(A.id) ? (ee = this.active.get(A.id)) == null ? void 0 : ee.resolve(v6.data) : void 0);
              }
            } catch {
            }
          });
          Hs(this, p, (v6) => {
            v6.event === d.EVENTS.PING && this.emit(d.EVENTS.PING), v6.event === d.EVENTS.CLOSE && this.emit(d.EVENTS.CLOSE), v6.event === d.EVENTS.OPEN && this.emit(d.EVENTS.OPEN), v6.event === d.EVENTS.SIGNOUT && this.emit(d.EVENTS.SIGNOUT), v6.event === d.EVENTS.USER_CHANGE && this.emit(d.EVENTS.USER_CHANGE, v6.data), v6.event === d.EVENTS.NETWORK_CHANGE && this.emit(d.EVENTS.NETWORK_CHANGE, v6.data);
          });
          Hs(this, b, async (v6) => {
            var E = await new Promise((A, k) => {
              this.active.set(v6.id, { resolve: A, reject: k }), window && window.postMessage(v6);
            });
            return this.active.delete(v6.id), E;
          });
          S(this, "awaitRequest", async (v6) => {
            try {
              return await Vi(this, b).call(this, { app: this.sdk.app, type: d.TYPES.REQUEST, id: (0, h.uuid)(), ...v6 });
            } catch (E) {
              throw E;
            }
          });
          S(this, "request", (v6) => {
            try {
              var E = (0, h.uuid)();
              return Vi(this, b).call(this, { app: this.sdk.app, type: d.TYPES.REQUEST, id: E, ...v6 }), E;
            } catch (A) {
              throw A;
            }
          });
          this.sdk = v, this.uuid = (0, h.uuid)(), this.connected = false, this.timestamp = Date.now(), typeof window < "u" && (this.target = window.origin, window.addEventListener("message", Vi(this, g)));
        }
      }
      g = /* @__PURE__ */ new WeakMap(), p = /* @__PURE__ */ new WeakMap(), b = /* @__PURE__ */ new WeakMap(), i.Api = f;
    }, 2585: (s, i) => {
      Object.defineProperty(i, "__esModule", { value: true }), i.Env = void 0;
      class o {
        constructor() {
          S(this, "isAndroid", false);
          S(this, "isIos", false);
          S(this, "isOpera", false);
          S(this, "isWindows", false);
          S(this, "isSSR", false);
          S(this, "isXApp", false);
          S(this, "isMobile", false);
          S(this, "isDesktop", false);
          typeof window < "u" && (this.isAndroid = !!(window != null && window.navigator.userAgent.match(/Android/i)), this.isIos = !!(window != null && window.navigator.userAgent.match(/iPhone|iPad|iPod/i)), this.isOpera = !!(window != null && window.navigator.userAgent.match(/Opera Mini/i)), this.isWindows = !!(window != null && window.navigator.userAgent.match(/IEMobile/i)), this.isSSR = !!(window != null && window.navigator.userAgent.match(/SSR/i)), this.isXApp = !!(window != null && window.navigator.userAgent.match(/xumm/i)), this.isMobile = !!(this.isAndroid || this.isIos || this.isOpera || this.isWindows), this.isDesktop = !this.isMobile && !this.isSSR);
        }
      }
      i.Env = o, i.default = new o();
    }, 6962: function(s, i, o) {
      var a = this && this.__createBinding || (Object.create ? function(f, g, p, b) {
        b === void 0 && (b = p);
        var _ = Object.getOwnPropertyDescriptor(g, p);
        _ && ("get" in _ ? g.__esModule : !_.writable && !_.configurable) || (_ = { enumerable: true, get: function() {
          return g[p];
        } }), Object.defineProperty(f, b, _);
      } : function(f, g, p, b) {
        f[b = b === void 0 ? p : b] = g[p];
      }), u = this && this.__setModuleDefault || (Object.create ? function(f, g) {
        Object.defineProperty(f, "default", { enumerable: true, value: g });
      } : function(f, g) {
        f.default = g;
      }), c = this && this.__importStar || function(f) {
        if (f && f.__esModule) return f;
        var g = {};
        if (f != null) for (var p in f) p !== "default" && Object.prototype.hasOwnProperty.call(f, p) && a(g, f, p);
        return u(g, f), g;
      }, l = this && this.__importDefault || function(f) {
        return f && f.__esModule ? f : { default: f };
      }, l = (Object.defineProperty(i, "__esModule", { value: true }), i.CustomEvents = i.CustomEmitter = void 0, l(o(7531)));
      const d = c(o(9815));
      class h extends l.default {
      }
      i.CustomEmitter = h, i.CustomEvents = class extends h {
        constructor(g) {
          super();
          S(this, "sdk");
          S(this, "api");
          this.sdk = g, this.api = this.sdk.api, this.api.on(d.EVENTS.PING, () => this.sdk.emit(d.EVENTS.PING)), this.api.on(d.EVENTS.RESPONSE, (p) => {
            this.sdk.emit(d.EVENTS.RESPONSE, p), this.sdk.emit(d.EVENTS.ALL, { type: d.EVENTS.RESPONSE, resp: p });
          }), this.api.on(d.EVENTS.USER_CHANGE, (p) => {
            this.sdk.emit(d.EVENTS.USER_CHANGE, p), this.sdk.emit(d.EVENTS.ALL, { type: d.EVENTS.USER_CHANGE, user: p });
          }), this.api.on(d.EVENTS.NETWORK_CHANGE, (p) => {
            this.sdk.emit(d.EVENTS.NETWORK_CHANGE, p), this.sdk.emit(d.EVENTS.ALL, { type: d.EVENTS.NETWORK_CHANGE, network: p });
          }), this.api.on(d.EVENTS.OPEN, () => {
            this.sdk.emit(d.EVENTS.OPEN), this.sdk.emit(d.EVENTS.ALL, { type: d.EVENTS.OPEN });
          }), this.api.on(d.EVENTS.CLOSE, () => {
            this.sdk.emit(d.EVENTS.CLOSE), this.sdk.emit(d.EVENTS.ALL, { type: d.EVENTS.CLOSE });
          }), this.api.on(d.EVENTS.SIGNOUT, () => {
            this.sdk.emit(d.EVENTS.SIGNOUT), this.sdk.emit(d.EVENTS.ALL, { type: d.EVENTS.SIGNOUT });
          });
        }
      };
    }, 5149: (s, i, o) => {
      Object.defineProperty(i, "__esModule", { value: true }), i.Session = i.Scheme = i.Mount = i.CustomEvents = i.CustomEmitter = i.Env = i.Api = void 0;
      var a = o(6515), u = (Object.defineProperty(i, "Api", { enumerable: true, get: function() {
        return a.Api;
      } }), o(2585)), c = (Object.defineProperty(i, "Env", { enumerable: true, get: function() {
        return u.Env;
      } }), o(6962)), l = (Object.defineProperty(i, "CustomEmitter", { enumerable: true, get: function() {
        return c.CustomEmitter;
      } }), Object.defineProperty(i, "CustomEvents", { enumerable: true, get: function() {
        return c.CustomEvents;
      } }), o(288)), d = (Object.defineProperty(i, "Mount", { enumerable: true, get: function() {
        return l.Mount;
      } }), o(2821)), h = (Object.defineProperty(i, "Scheme", { enumerable: true, get: function() {
        return d.Scheme;
      } }), o(2413));
      Object.defineProperty(i, "Session", { enumerable: true, get: function() {
        return h.Session;
      } });
    }, 288: function(s, i, o) {
      var a = this && this.__createBinding || (Object.create ? function(g, p, b, _) {
        _ === void 0 && (_ = b);
        var D = Object.getOwnPropertyDescriptor(p, b);
        D && ("get" in D ? p.__esModule : !D.writable && !D.configurable) || (D = { enumerable: true, get: function() {
          return p[b];
        } }), Object.defineProperty(g, _, D);
      } : function(g, p, b, _) {
        g[_ = _ === void 0 ? b : _] = p[b];
      }), u = this && this.__setModuleDefault || (Object.create ? function(g, p) {
        Object.defineProperty(g, "default", { enumerable: true, value: p });
      } : function(g, p) {
        g.default = p;
      }), c = this && this.__importStar || function(g) {
        if (g && g.__esModule) return g;
        var p = {};
        if (g != null) for (var b in g) b !== "default" && Object.prototype.hasOwnProperty.call(g, b) && a(p, g, b);
        return u(p, g), p;
      }, l = this && this.__importDefault || function(g) {
        return g && g.__esModule ? g : { default: g };
      }, l = (Object.defineProperty(i, "__esModule", { value: true }), i.Mount = void 0, l(o(7531)));
      const d = o(266), h = c(o(9815));
      class f extends l.default {
        constructor(b) {
          super();
          S(this, "isDetected");
          S(this, "sdk");
          S(this, "loop", async (b6) => new Promise(async (_, D) => {
            this.isDetected && _(true);
            var v = Date.now();
            if (this.sdk.app === h.Projects.titles.embark) for (; ; ) {
              if (typeof window < "u" && window.xrpl && window.xrpl.isEmbark) {
                this.isDetected = window.xrpl.isEmbark, window.embark = Object.assign({}, window == null ? void 0 : window.embark, this.sdk), this.emit("detected"), this.sdk.emit("detected"), _(true);
                break;
              }
              if (await (0, d.sleep)(500), Date.now() > v + (b6 ?? 1e4)) {
                _(false);
                break;
              }
            }
            else for (; ; ) {
              if (typeof window < "u" && window.xrpl && window.xrpl.isCrossmark) {
                this.isDetected = window.xrpl.isCrossmark, window.crossmark = Object.assign({}, window == null ? void 0 : window.crossmark, this.sdk), this.emit("detected"), this.sdk.emit("detected"), _(true);
                break;
              }
              if (await (0, d.sleep)(500), Date.now() > v + (b6 ?? 1e4)) {
                _(false);
                break;
              }
            }
          }));
          this.sdk = b, this.loop(1e4);
        }
      }
      i.Mount = f;
    }, 2821: function(s, i, o) {
      var a = this && this.__importDefault || function(c) {
        return c && c.__esModule ? c : { default: c };
      };
      Object.defineProperty(i, "__esModule", { value: true }), i.Scheme = void 0;
      const u = a(o(2585));
      i.Scheme = { get: (c, l) => {
        if (l.startsWith("_")) throw new Error("Access denied");
        if (u.default.isMobile) throw new Error("Crossmark only available from desktop");
        return l = c[l], typeof l == "function" ? l.bind(c) : l;
      }, set: (c, l, d) => {
        if (l.startsWith("_")) throw new Error("Access denied");
        return c[l] = d, true;
      }, deleteProperty: (c, l) => {
        if (l.startsWith("_")) throw new Error("Access denied");
        return delete c[l], true;
      }, ownKeys: (c) => Object.keys(c).filter((l) => !l.startsWith("_")) };
    }, 2413: function(s, i, o) {
      var a = this && this.__createBinding || (Object.create ? function(h, f, g, p) {
        p === void 0 && (p = g);
        var b = Object.getOwnPropertyDescriptor(f, g);
        b && ("get" in b ? f.__esModule : !b.writable && !b.configurable) || (b = { enumerable: true, get: function() {
          return f[g];
        } }), Object.defineProperty(h, p, b);
      } : function(h, f, g, p) {
        h[p = p === void 0 ? g : p] = f[g];
      }), u = this && this.__setModuleDefault || (Object.create ? function(h, f) {
        Object.defineProperty(h, "default", { enumerable: true, value: f });
      } : function(h, f) {
        h.default = f;
      }), c = this && this.__importStar || function(h) {
        if (h && h.__esModule) return h;
        var f = {};
        if (h != null) for (var g in h) g !== "default" && Object.prototype.hasOwnProperty.call(h, g) && a(f, h, g);
        return u(f, h), f;
      };
      Object.defineProperty(i, "__esModule", { value: true }), i.Session = void 0;
      const l = c(o(9815));
      class d {
        constructor(f) {
          S(this, "sdk");
          S(this, "user");
          S(this, "network");
          S(this, "address");
          S(this, "isOpen", false);
          S(this, "lastPing");
          S(this, "state", "unactive");
          S(this, "responses", /* @__PURE__ */ new Map());
          S(this, "handleDetect", async () => {
            this.network = (await this.sdk.api.awaitRequest({ command: l.COMMANDS.NETWORK })).response.data.network, this.user = (await this.sdk.api.awaitRequest({ command: l.COMMANDS.USER })).response.data.user, this.address = (await this.sdk.api.awaitRequest({ command: l.COMMANDS.ADDRESS })).response.data.address, this.network && this.user && this.address && (this.state = "active");
          });
          S(this, "handlePing", () => this.lastPing = Date.now());
          S(this, "handleClose", () => this.isOpen = false);
          S(this, "handleOpen", () => this.isOpen = true);
          S(this, "handleSignOut", () => {
            this.state = "unactive", this.address = void 0, this.network = void 0, this.user = void 0;
          });
          S(this, "handleNetworkChange", (f6) => {
            this.network = f6.network;
          });
          S(this, "handleUserChange", (f6) => {
            this.user = f6.user, this.address = void 0;
          });
          S(this, "handleResponse", (f6) => {
            "address" in f6.response.data && (this.state = "active", this.address = f6.response.data.address), "network" in f6.response.data && (this.network = f6.response.data.network), "user" in f6.response.data && (this.user = f6.response.data.user), this.responses.set(f6.request.id, f6);
          });
          this.sdk = f, this.sdk.on(l.EVENTS.PING, this.handlePing), this.sdk.on(l.EVENTS.RESPONSE, this.handleResponse), this.sdk.on(l.EVENTS.USER_CHANGE, this.handleUserChange), this.sdk.on(l.EVENTS.NETWORK_CHANGE, this.handleNetworkChange), this.sdk.on(l.EVENTS.OPEN, this.handleOpen), this.sdk.on(l.EVENTS.CLOSE, this.handleClose), this.sdk.on(l.EVENTS.SIGNOUT, this.handleSignOut), this.sdk.on("detected", this.handleDetect);
        }
      }
      (i.Session = d).prototype.user = void 0, d.prototype.network = void 0, d.prototype.address = void 0;
    }, 4240: function(s, i, o) {
      var a = this && this.__createBinding || (Object.create ? function(h, f, g, p) {
        p === void 0 && (p = g);
        var b = Object.getOwnPropertyDescriptor(f, g);
        b && ("get" in b ? f.__esModule : !b.writable && !b.configurable) || (b = { enumerable: true, get: function() {
          return f[g];
        } }), Object.defineProperty(h, p, b);
      } : function(h, f, g, p) {
        h[p = p === void 0 ? g : p] = f[g];
      }), u = this && this.__setModuleDefault || (Object.create ? function(h, f) {
        Object.defineProperty(h, "default", { enumerable: true, value: f });
      } : function(h, f) {
        h.default = f;
      }), d = this && this.__importStar || function(h) {
        if (h && h.__esModule) return h;
        var f = {};
        if (h != null) for (var g in h) g !== "default" && Object.prototype.hasOwnProperty.call(h, g) && a(f, h, g);
        return u(f, h), f;
      };
      Object.defineProperty(i, "__esModule", { value: true }), i.typings = i.modules = i.vanilla = void 0;
      const c = o(9616);
      Object.defineProperty(i, "vanilla", { enumerable: true, get: function() {
        return c.Sdk;
      } });
      var l = d(o(40)), d = (i.modules = l, d(o(9815)));
      i.typings = d, i.default = l.xmark;
    }, 2898: function(s, i, o) {
      var a = this && this.__createBinding || (Object.create ? function(h, f, g, p) {
        p === void 0 && (p = g);
        var b = Object.getOwnPropertyDescriptor(f, g);
        b && ("get" in b ? f.__esModule : !b.writable && !b.configurable) || (b = { enumerable: true, get: function() {
          return f[g];
        } }), Object.defineProperty(h, p, b);
      } : function(h, f, g, p) {
        h[p = p === void 0 ? g : p] = f[g];
      }), u = this && this.__setModuleDefault || (Object.create ? function(h, f) {
        Object.defineProperty(h, "default", { enumerable: true, value: f });
      } : function(h, f) {
        h.default = f;
      }), d = this && this.__importStar || function(h) {
        if (h && h.__esModule) return h;
        var f = {};
        if (h != null) for (var g in h) g !== "default" && Object.prototype.hasOwnProperty.call(h, g) && a(f, h, g);
        return u(f, h), f;
      }, c = (Object.defineProperty(i, "__esModule", { value: true }), o(9616)), l = d(o(5149)), d = d(o(9815));
      i.default = new Proxy(new c.Sdk({ project: d.Projects.titles.crossmark }), l.Scheme);
    }, 477: function(s, i, o) {
      var a = this && this.__createBinding || (Object.create ? function(h, f, g, p) {
        p === void 0 && (p = g);
        var b = Object.getOwnPropertyDescriptor(f, g);
        b && ("get" in b ? f.__esModule : !b.writable && !b.configurable) || (b = { enumerable: true, get: function() {
          return f[g];
        } }), Object.defineProperty(h, p, b);
      } : function(h, f, g, p) {
        h[p = p === void 0 ? g : p] = f[g];
      }), u = this && this.__setModuleDefault || (Object.create ? function(h, f) {
        Object.defineProperty(h, "default", { enumerable: true, value: f });
      } : function(h, f) {
        h.default = f;
      }), d = this && this.__importStar || function(h) {
        if (h && h.__esModule) return h;
        var f = {};
        if (h != null) for (var g in h) g !== "default" && Object.prototype.hasOwnProperty.call(h, g) && a(f, h, g);
        return u(f, h), f;
      }, c = (Object.defineProperty(i, "__esModule", { value: true }), o(9616)), l = d(o(5149)), d = d(o(9815));
      i.default = new Proxy(new c.Sdk({ project: d.Projects.titles.embark }), l.Scheme);
    }, 40: function(s, i, o) {
      var a = this && this.__importDefault || function(l) {
        return l && l.__esModule ? l : { default: l };
      }, u = (Object.defineProperty(i, "__esModule", { value: true }), i.embark = i.xmark = void 0, o(2898)), c = (Object.defineProperty(i, "xmark", { enumerable: true, get: function() {
        return a(u).default;
      } }), o(477));
      Object.defineProperty(i, "embark", { enumerable: true, get: function() {
        return a(c).default;
      } });
    }, 5007: (s, i) => {
      Object.defineProperty(i, "__esModule", { value: true }), i.uuid = void 0, i.uuid = () => {
        let o = "", a;
        for (a = 0; a < 32; a += 1) switch (a) {
          case 8:
          case 20:
            o = (o += "-") + (16 * Math.random() | 0).toString(16);
            break;
          case 12:
            o = o + "-4";
            break;
          case 16:
            o = (o += "-") + (4 * Math.random() | 8).toString(16);
            break;
          default:
            o += (16 * Math.random() | 0).toString(16);
        }
        return o;
      };
    }, 266: (s, i, o) => {
      Object.defineProperty(i, "__esModule", { value: true }), i.uuid = i.sleep = void 0;
      var a = o(2200), u = (Object.defineProperty(i, "sleep", { enumerable: true, get: function() {
        return a.sleep;
      } }), o(5007));
      Object.defineProperty(i, "uuid", { enumerable: true, get: function() {
        return u.uuid;
      } });
    }, 2200: (s, i) => {
      Object.defineProperty(i, "__esModule", { value: true }), i.sleep = void 0, i.sleep = async (o) => {
        await new Promise((a) => {
          setTimeout(a, o);
        });
      };
    }, 2025: (s, i) => {
      var o;
      Object.defineProperty(i, "__esModule", { value: true }), i.Config = void 0, i.Config = (o = class {
      }, S(o, "config"), o);
    }, 7268: (s, i) => {
      var o;
      Object.defineProperty(i, "__esModule", { value: true }), i.Events = void 0, i.Events = (o = class {
      }, S(o, "GenericEvent"), S(o, "BaseEvent"), S(o, "EventMessage"), S(o, "NetworkEvent"), S(o, "UserEvent"), S(o, "StateEvent"), S(o, "SignoutEvent"), o);
    }, 9291: (s, i) => {
      var o;
      Object.defineProperty(i, "__esModule", { value: true }), i.Models = void 0, i.Models = (o = class {
      }, S(o, "Request"), S(o, "Response"), S(o, "FullResponse"), S(o, "IsConnectedRequest"), S(o, "IsLockedRequest"), S(o, "SignInRequest"), S(o, "IsOpenRequest"), S(o, "SignRequest"), S(o, "VersionRequest"), S(o, "NetworkRequest"), S(o, "UserRequest"), S(o, "AddressRequest"), S(o, "VerifyRequest"), S(o, "SignAndSubmitRequest"), S(o, "SubmitRequest"), S(o, "EncryptRequest"), S(o, "DecryptRequest"), S(o, "IsConnectedResponse"), S(o, "IsLockedResponse"), S(o, "SignInResponse"), S(o, "IsOpenResponse"), S(o, "SignResponse"), S(o, "VersionResponse"), S(o, "AddressResponse"), S(o, "NetworkResponse"), S(o, "UserResponse"), S(o, "VerifyResponse"), S(o, "SignAndSubmitResponse"), S(o, "SubmitResponse"), S(o, "IsConnectedFullResponse"), S(o, "IsLockedFullResponse"), S(o, "SignInFullResponse"), S(o, "IsOpenFullResponse"), S(o, "SignFullResponse"), S(o, "VersionFullResponse"), S(o, "AddressFullResponse"), S(o, "NetworkFullResponse"), S(o, "UserFullResponse"), S(o, "VerifyFullResponse"), S(o, "SignAndSubmitFullResponse"), S(o, "SubmitFullResponse"), S(o, "BulkSubmitRequest"), S(o, "BulkSignRequest"), S(o, "BulkSignAndSubmitRequest"), S(o, "BulkSubmitFullResponse"), S(o, "BulkSignFullResponse"), S(o, "BulkSignAndSubmitFullResponse"), S(o, "BulkSubmitResponse"), S(o, "BulkSignResponse"), S(o, "BulkSignAndSubmitResponse"), S(o, "EncryptResponse"), S(o, "EncryptFullResponse"), S(o, "DecryptResponse"), S(o, "DecryptFullResponse"), S(o, "SenderFullResponse"), S(o, "SenderRequest"), S(o, "SenderResponse"), S(o, "ManagerFullResponse"), S(o, "ManagerRequest"), S(o, "ManagerResponse"), S(o, "AllTransactionRequest"), S(o, "AllTransactionResponse"), S(o, "AllTransactionMetadata"), S(o, "AllTxResponse"), S(o, "AllSubmitResponse"), S(o, "AllTransactionStream"), S(o, "AllTransaction"), S(o, "AllFullTransaction"), S(o, "IndexedTransactionRequest"), S(o, "SignTransaction"), S(o, "SignOpts"), S(o, "CryptOpts"), S(o, "ExtendedSignOpts"), S(o, "Status"), o);
    }, 4151: (s, i) => {
      Object.defineProperty(i, "__esModule", { value: true }), i.CatchAllEvent = i.TYPES = i.EVENTS = i.COMMANDS = i.Extension = void 0;
      class o {
      }
      S(o, "CatchAllEvent"), S(o, "BasicUser"), S(o, "BasicNetwork"), S(o, "CleanExtMessage"), S(o, "CommResponse"), S(o, "CleanResponse"), S(o, "PostMessage"), S(o, "PortMessage"), S(o, "Payload"), S(o, "AppStatus"), S(o, "AllExtMessage"), S(o, "ExtMessage"), S(o, "RequestMessage"), S(o, "ResponseMessage"), S(o, "Targets"), S(o, "Events"), S(o, "Commands"), S(o, "Types");
      var a, u;
      i.Extension = o, a = o || (i.Extension = o = {}), (u = a.TYPES || (a.TYPES = {})).INIT = "init", u.REFRESH = "refresh", u.DISCONNECT = "disconnect", u.PING = "ping", u.REQUEST = "request", u.RESPONSE = "response", u.UPDATE = "update", u.EVENT = "event", (u = a.COMMANDS || (a.COMMANDS = {})).VERSION = "version", u.IS_CONNECTED = "isConnected", u.IS_LOCKED = "isLocked", u.OPEN = "open", u.SIGN = "sign", u.SIGNANDSUBMIT = "sign-and-submit", u.BULKSUBMIT = "bulk-submit", u.BULKSIGN = "bulk-sign", u.BULK = "bulk", u.SUBMIT = "submit", u.MANAGER = "manager", u.ADDRESS = "address", u.NETWORK = "network", u.USER = "user", u.VERIFY = "verify", u.SENDER = "sender", u.CHANGENODE = "change-node", u.CHANGEUSER = "change-user", u.DECRYPT = "decrypt", u.ENCRYPT = "encrypt", (u = a.EVENTS || (a.EVENTS = {})).ACCOUNTS_CHANGED = "accountsChanged", u.CHAIN_CHANGED = "chainChanged", u.CONNECT = "connect", u.DISCONNECT = "disconnect", u.MESSAGE = "message", u.POPUP_MODE = "popup-mode", u.STATE_UPDATE = "state-update", u.NETWORK_CHANGE = "network-change", u.USER_CHANGE = "user-change", u.OPEN = "open", u.CLOSE = "close", u.PING = "ping", u.SIGNIN = "signin", u.SIGNOUT = "signout", u.RESPONSE = "response", u.ALL = "all", (u = a.TARGETS || (a.TARGETS = {})).CONTENT = "content", u.BG = "bg", u.POP = "pop", i.COMMANDS = o.COMMANDS, i.EVENTS = o.EVENTS, i.TYPES = o.TYPES, i.CatchAllEvent = o.CatchAllEvent;
    }, 9312: (s, i) => {
      var o;
      Object.defineProperty(i, "__esModule", { value: true }), i.Types = void 0, i.Types = (o = class {
      }, S(o, "AgreementsSchema"), S(o, "GeneralSchema"), S(o, "NetworkSchema"), S(o, "CardSchema"), S(o, "ContactSchema"), S(o, "ProfileSchema"), S(o, "SecuritySchema"), S(o, "StateSchema"), S(o, "UserSchema"), S(o, "AppSchema"), S(o, "PreferenceSchema"), S(o, "VaultSchema"), S(o, "MountedUserSchema"), S(o, "Blank"), o);
    }, 7579: function(s, i, o) {
      var a = this && this.__createBinding || (Object.create ? function(d, h, f, g) {
        g === void 0 && (g = f);
        var p = Object.getOwnPropertyDescriptor(h, f);
        p && ("get" in p ? h.__esModule : !p.writable && !p.configurable) || (p = { enumerable: true, get: function() {
          return h[f];
        } }), Object.defineProperty(d, g, p);
      } : function(d, h, f, g) {
        d[g = g === void 0 ? f : g] = h[f];
      }), u = this && this.__setModuleDefault || (Object.create ? function(d, h) {
        Object.defineProperty(d, "default", { enumerable: true, value: h });
      } : function(d, h) {
        d.default = h;
      }), c = this && this.__importStar || function(d) {
        if (d && d.__esModule) return d;
        var h = {};
        if (d != null) for (var f in d) f !== "default" && Object.prototype.hasOwnProperty.call(d, f) && a(h, d, f);
        return u(h, d), h;
      }, c = (Object.defineProperty(i, "__esModule", { value: true }), i.Types = void 0, c(o(9312)));
      class l {
      }
      S(l, "Api", c), i.Types = l, o = l || (i.Types = l = {}), (c = o.TWCardColor || (o.TWCardColor = {})).color1 = "tw-bg-cardGradient1", c.color2 = "tw-bg-cardGradient2", c.color3 = "tw-bg-cardGradient3", c.color4 = "tw-bg-cardGradient4", c.color5 = "tw-bg-cardGradient5", c.color6 = "tw-bg-cardGradient6", c.color7 = "tw-bg-cardGradient7", c.color8 = "tw-bg-cardGradient8", c.color9 = "tw-bg-cardGradient9", c.color10 = "tw-bg-cardGradient10", (c = o.CardColor || (o.CardColor = {})).color1 = "color1", c.color2 = "color2", c.color3 = "color3", c.color4 = "color4", c.color5 = "color5", c.color6 = "color6", c.color7 = "color7", c.color8 = "color8", c.color9 = "color9", c.color10 = "color10", (c = o.NetworkTypes || (o.NetworkTypes = {})).main = "main", c.live = "live", c.test = "test", c.dev = "dev", c.hooks = "hooks", c.experimental = "experimental", c.sidechain = "sidechain", c.xls30 = "xls-30d", c.xls38 = "xls-38d", c.xahautest = "xahau-test", (c = o.Protocol || (o.Protocol = {})).xrpl = "XRPL", c.evm = "EVM", c.btc = "BTC", c.bsc = "BSC", c.ada = "ADA", c.sol = "SOL", c.usd = "USD", (c = o.XRPLExplorers || (o.XRPLExplorers = {})).bithomp = "bithomp", c.xrplorg = "xrpl.org", c.xrplf = "xrplf", c.xrpscan = "xrpscan", (o.EVMExplorers || (o.EVMExplorers = {})).evmSideChain = "evm-sidechain", o.networkColorMap = { [o.NetworkTypes.main]: "tw-bg-[#38DBFF]", [o.NetworkTypes.live]: "tw-bg-[#38FFDB]", [o.NetworkTypes.test]: "tw-bg-[#DE7EFF]", [o.NetworkTypes.dev]: "tw-bg-[#FFB648]", [o.NetworkTypes.experimental]: "tw-bg-[#FF7B9B]", [o.NetworkTypes.sidechain]: "tw-bg-[#7CFF99]", [o.NetworkTypes.xls30]: "tw-bg-[#FF9C7C]", [o.NetworkTypes.xls38]: "tw-bg-[#C34D27]", [o.NetworkTypes.hooks]: "tw-bg-[#CF4C27]", [o.NetworkTypes.xahautest]: "tw-bg-[#CF4C27]" }, o.BithompHost = { [o.NetworkTypes.main]: "https://bithomp.com/explorer", [o.NetworkTypes.test]: "https://test.bithomp.com/explorer", [o.NetworkTypes.dev]: "https://dev.bithomp.com/explorer", [o.NetworkTypes.xls30]: "https://amm.bithomp.com/explorer", [o.NetworkTypes.hooks]: "https://beta.bithomp.com/explorer", [o.NetworkTypes.live]: "https://bithomp.com/explorer", [o.NetworkTypes.experimental]: "", [o.NetworkTypes.sidechain]: "", [o.NetworkTypes.xls38]: "", [o.NetworkTypes.xahautest]: "https://test.xahauexplorer.com/explorer" }, o.XrplfHost = { [o.NetworkTypes.main]: "https://explorer.xrplf.org", [o.NetworkTypes.test]: "https://explorer-testnet.xrplf.org", [o.NetworkTypes.hooks]: "https://hooks-testnet-v3-explorer.xrpl-labs.com", [o.NetworkTypes.dev]: "", [o.NetworkTypes.xls30]: "", [o.NetworkTypes.live]: "", [o.NetworkTypes.experimental]: "", [o.NetworkTypes.sidechain]: "", [o.NetworkTypes.xls38]: "", [o.NetworkTypes.xahautest]: "https://explorer.xahau-test.net" }, o.XrplOrgHost = { [o.NetworkTypes.main]: "https://livenet.xrpl.org", [o.NetworkTypes.test]: "https://testnet.xrpl.org", [o.NetworkTypes.dev]: "https://devnet.xrpl.org", [o.NetworkTypes.xls30]: "", [o.NetworkTypes.hooks]: "", [o.NetworkTypes.live]: "", [o.NetworkTypes.experimental]: "", [o.NetworkTypes.sidechain]: "", [o.NetworkTypes.xls38]: "", [o.NetworkTypes.xahautest]: "" }, o.XRPScanHost = { [o.NetworkTypes.main]: "https://xrpscan.com", [o.NetworkTypes.test]: "", [o.NetworkTypes.dev]: "", [o.NetworkTypes.xls30]: "", [o.NetworkTypes.hooks]: "", [o.NetworkTypes.live]: "", [o.NetworkTypes.experimental]: "", [o.NetworkTypes.sidechain]: "", [o.NetworkTypes.xls38]: "", [o.NetworkTypes.xahautest]: "" }, o.EvmSideChainHost = { [o.NetworkTypes.dev]: "https://evm-sidechain.xrpl.org", [o.NetworkTypes.main]: "", [o.NetworkTypes.test]: "", [o.NetworkTypes.xls30]: "", [o.NetworkTypes.hooks]: "", [o.NetworkTypes.live]: "", [o.NetworkTypes.experimental]: "", [o.NetworkTypes.sidechain]: "", [o.NetworkTypes.xls38]: "", [o.NetworkTypes.xahautest]: "" }, o.ExplorerAddressPath = { [o.XRPLExplorers.bithomp]: "", [o.XRPLExplorers.xrplorg]: "/address", [o.XRPLExplorers.xrplf]: "", [o.XRPLExplorers.xrpscan]: "/account", [o.EVMExplorers.evmSideChain]: "/address" }, o.ExplorerTxPath = { [o.XRPLExplorers.bithomp]: "", [o.XRPLExplorers.xrplorg]: "/transactions", [o.XRPLExplorers.xrplf]: "/tx", [o.XRPLExplorers.xrpscan]: "/tx", [o.EVMExplorers.evmSideChain]: "/tx" }, o.availableProtocols = [o.Protocol.xrpl, o.Protocol.evm];
    }, 2083: (s, i, o) => {
      var a;
      Object.defineProperty(i, "__esModule", { value: true }), i.Types = void 0, o(7579).Types.Api.Types, i.Types = (a = class {
      }, S(a, "AgreementsSchema"), S(a, "GeneralSchema"), S(a, "NodeSchema"), S(a, "CardSchema"), S(a, "ContactSchema"), S(a, "ProfileSchema"), S(a, "SecuritySchema"), S(a, "StateSchema"), S(a, "UserSchema"), S(a, "AppSchema"), S(a, "PreferenceSchema"), S(a, "VaultSchema"), S(a, "MountedUserSchema"), S(a, "SecurityTypes"), S(a, "SecurityLevel"), S(a, "Blank"), a);
    }, 4855: (s, i) => {
      Object.defineProperty(i, "__esModule", { value: true }), i.Card = void 0;
      class o {
      }
      S(o, "MappedAddresses"), S(o, "ThemeArray"), S(o, "Color");
      var a, u;
      i.Card = o, i = o || (i.Card = o = {}), (a = i.TWCardColor || (i.TWCardColor = {})).color1 = "tw-bg-cardGradient1", a.color2 = "tw-bg-cardGradient2", a.color3 = "tw-bg-cardGradient3", a.color4 = "tw-bg-cardGradient4", a.color5 = "tw-bg-cardGradient5", a.color6 = "tw-bg-cardGradient6", a.color7 = "tw-bg-cardGradient7", a.color8 = "tw-bg-cardGradient8", a.color9 = "tw-bg-cardGradient9", a.color10 = "tw-bg-cardGradient10", (u = a = i.cardColorTheme || (i.cardColorTheme = {})).dark = "Dark", u.light = "Light", i.cardColorBg = { [a.light]: "tw-bg-black", [a.dark]: "tw-bg-white" }, i.cardColorStroke = { [a.light]: "tw-stroke-black", [a.dark]: "tw-stroke-white" }, i.cardColorText = { [a.light]: "tw-text-black", [a.dark]: "tw-text-white" }, i.cardColorFill = { [a.light]: "tw-fill-black", [a.dark]: "tw-fill-white" }, (u = i.CardColor || (i.CardColor = {})).color1 = "color1", u.color2 = "color2", u.color3 = "color3", u.color4 = "color4", u.color5 = "color5", u.color6 = "color6", u.color7 = "color7", u.color8 = "color8", u.color9 = "color9", u.color10 = "color10";
    }, 4284: (s, i, o) => {
      Object.defineProperty(i, "__esModule", { value: true }), i.AES_CBC = void 0;
      var a = o(6914);
      i.AES_CBC = class {
        constructor() {
          S(this, "algo");
          S(this, "type", a.AlgoTypes.aes_cbc);
          S(this, "iv");
          S(this, "derivation");
          S(this, "encrypt");
          S(this, "decrypt");
        }
      };
    }, 410: (s, i, o) => {
      Object.defineProperty(i, "__esModule", { value: true }), i.AES_GCM = void 0;
      var a = o(6914);
      i.AES_GCM = class {
        constructor() {
          S(this, "algo");
          S(this, "type", a.AlgoTypes.aes_gcm);
          S(this, "iv");
          S(this, "tag");
          S(this, "derivation");
          S(this, "encrypt");
          S(this, "decrypt");
        }
      };
    }, 6914: (s, i) => {
      Object.defineProperty(i, "__esModule", { value: true }), i.AlgoTypes = void 0, i.AlgoTypes = { standard: "sha512", pbkdf2: "pbkdf2-sha512", aes_cbc: "aes-512-cbc", aes_gcm: "aes-512-gcm" };
    }, 2625: (s, i, o) => {
      Object.defineProperty(i, "__esModule", { value: true }), i.Standard = i.PBKDF2 = i.AES_CBC = i.AES_GCM = void 0;
      var a = o(410), u = (Object.defineProperty(i, "AES_GCM", { enumerable: true, get: function() {
        return a.AES_GCM;
      } }), o(4284)), c = (Object.defineProperty(i, "AES_CBC", { enumerable: true, get: function() {
        return u.AES_CBC;
      } }), o(1055)), l = (Object.defineProperty(i, "PBKDF2", { enumerable: true, get: function() {
        return c.PBKDF2;
      } }), o(8633));
      Object.defineProperty(i, "Standard", { enumerable: true, get: function() {
        return l.Standard;
      } });
    }, 1055: (s, i, o) => {
      Object.defineProperty(i, "__esModule", { value: true }), i.PBKDF2 = void 0;
      var a = o(6914);
      i.PBKDF2 = class {
        constructor() {
          S(this, "type", a.AlgoTypes.pbkdf2);
          S(this, "iterations");
          S(this, "keylet");
          S(this, "iv");
          S(this, "encrypt");
        }
      };
    }, 8633: (s, i, o) => {
      Object.defineProperty(i, "__esModule", { value: true }), i.Standard = void 0;
      var a = o(6914);
      i.Standard = class {
        constructor() {
          S(this, "type", a.AlgoTypes.standard);
          S(this, "encrypt");
        }
      };
    }, 4575: function(s, i, f) {
      var a = this && this.__createBinding || (Object.create ? function(p, b, _, D) {
        D === void 0 && (D = _);
        var v = Object.getOwnPropertyDescriptor(b, _);
        v && ("get" in v ? b.__esModule : !v.writable && !v.configurable) || (v = { enumerable: true, get: function() {
          return b[_];
        } }), Object.defineProperty(p, D, v);
      } : function(p, b, _, D) {
        p[D = D === void 0 ? _ : D] = b[_];
      }), u = this && this.__setModuleDefault || (Object.create ? function(p, b) {
        Object.defineProperty(p, "default", { enumerable: true, value: b });
      } : function(p, b) {
        p.default = b;
      }), h = this && this.__importStar || function(p) {
        if (p && p.__esModule) return p;
        var b = {};
        if (p != null) for (var _ in p) _ !== "default" && Object.prototype.hasOwnProperty.call(p, _) && a(b, p, _);
        return u(b, p), b;
      }, c = (Object.defineProperty(i, "__esModule", { value: true }), i.Types = void 0, f(1437)), l = h(f(2083)), d = h(f(4855)), h = h(f(2789)), f = f(2164);
      class g {
      }
      S(g, "AllNetworks", c.AllNetworks), S(g, "AllNodeTypes", c.AllNetworks.AllNodeTypes), S(g, "AllNodeExplorers", c.AllNetworks.AllNodeExplorers), S(g, "AllProtocols", f.Protocols), S(g, "Api", l), S(g, "Card", d.Card), S(g, "Security", h.Security), S(g, "BasicNetwork"), S(g, "BasicUser"), S(g, "NodeTypes"), S(g, "NodeExplorers"), S(g, "Protocols"), S(g, "Networks"), S(g, "Icons"), S(g, "EncryptionTypes"), S(g, "EncryptTypes"), S(g, "CardEncryptionTypes"), S(g, "PasscodeEncryptionTypes"), S(g, "availableProtocols", [f.Protocols.xrpl, f.Protocols.evm]), S(g, "NetworkIdentifiers", { [c.AllNetworks.NetworkLabels.xrpl]: c.AllNetworks.XrplLedger, [c.AllNetworks.NetworkLabels.xevm]: c.AllNetworks.Xevm, [c.AllNetworks.NetworkLabels.xahau]: c.AllNetworks.Xahau }), i.Types = g;
    }, 8950: (s, i) => {
      Object.defineProperty(i, "__esModule", { value: true }), i.NetworkIcons = void 0, i.NetworkIcons = { xrpl: "/assets/chains/xrpl/info/logo.png", xevm: "/assets/chains/xevm/info/logo.jpg", xahau: "/assets/chains/xahau/info/logo.jpg" };
    }, 7782: (s, i) => {
      Object.defineProperty(i, "__esModule", { value: true }), i.NetworkLabels = void 0, i.NetworkLabels = { xrpl: "xrp ledger", xevm: "xevm sidechain", xahau: "xahau" };
    }, 1437: (s, i, d) => {
      Object.defineProperty(i, "__esModule", { value: true }), i.AllNetworks = void 0;
      var a = d(1396), u = d(1743), c = d(4942), l = d(8950), d = d(7782), h = a.XahauNetwork.NetworkTypes, f = u.XrplLedgerNetwork.NetworkTypes, g = c.XevmNetwork.NetworkTypes, p = a.XahauNetwork.Explorers, b = u.XrplLedgerNetwork.Explorers, _ = c.XevmNetwork.Explorers;
      class D {
      }
      S(D, "Xahau", a.XahauNetwork), S(D, "XrplLedger", u.XrplLedgerNetwork), S(D, "Xevm", c.XevmNetwork), S(D, "AllNodeTypes", { xahau: h, xrpl: f, xevm: g }), S(D, "AllNodeExplorers", { xahauExpl: p, xrplExpl: b, xevmExpl: _ }), S(D, "NetworkLabels", d.NetworkLabels), S(D, "NetworkIcons", l.NetworkIcons), i.AllNetworks = D;
    }, 1396: (s, i, l) => {
      Object.defineProperty(i, "__esModule", { value: true }), i.XahauNetwork = void 0;
      var a, u = l(2164), c = l(8950), l = l(7782);
      class d {
      }
      S(d, "protocol", u.Protocols.xrpl), S(d, "Types"), S(d, "label", l.NetworkLabels.xahau), S(d, "icon", c.NetworkIcons.xahau), S(d, "asset", "XAH"), S(d, "active", true), S(d, "defaultReserves", { base: "1", inc: "0.2" }), i.XahauNetwork = d, a = d || (i.XahauNetwork = d = {}), (u = a.NetworkTypes || (a.NetworkTypes = {})).mainnet = "mainnet", u.testnet = "testnet", u.devnet = "devnet", (u = a.Explorers || (a.Explorers = {})).bithomp = "bithomp", u.xrplf = "xrplf", u.xrplorg = "xrpl.org", a.colors = { [a.NetworkTypes.mainnet]: "tw-bg-[#38DBFF]", [a.NetworkTypes.devnet]: "tw-bg-[#38FFDB]", [a.NetworkTypes.testnet]: "tw-bg-[#DE7EFF]" }, a.BithompHost = { [a.NetworkTypes.mainnet]: "https://xahauexplorer.com", [a.NetworkTypes.testnet]: "https://test.xahauexplorer.com", [a.NetworkTypes.devnet]: "" }, a.XrplfHost = { [a.NetworkTypes.mainnet]: "https://explorer.xahau.network", [a.NetworkTypes.testnet]: "https://explorer.xahau-test.net", [a.NetworkTypes.devnet]: "" }, a.XrplOrgHost = { [a.NetworkTypes.mainnet]: "https://xahau.xrpl.org", [a.NetworkTypes.testnet]: "https://xahau-testnet.xrpl.org", [a.NetworkTypes.devnet]: "" }, a.Hosts = { [a.Explorers.bithomp]: a.BithompHost, [a.Explorers.xrplf]: a.XrplfHost, [a.Explorers.xrplorg]: a.XrplOrgHost }, a.ExplorerAddressPath = { [a.Explorers.bithomp]: "", [a.Explorers.xrplf]: "/address", [a.Explorers.xrplorg]: "/accounts" }, a.ExplorerTxPath = { [a.Explorers.bithomp]: "", [a.Explorers.xrplf]: "/tx", [a.Explorers.xrplorg]: "/transactions" }, a.getExplorerHost = (h, f) => h === a.Explorers.bithomp ? a.BithompHost[f] : h === a.Explorers.xrplf ? a.XrplfHost[f] : h === a.Explorers.xrplorg ? a.XrplOrgHost[f] : void 0, a.getExplorerPath = (h, f) => f === "address" ? a.ExplorerAddressPath[h] : f === "tx" ? a.ExplorerTxPath[h] : void 0;
    }, 4942: (s, i, l) => {
      Object.defineProperty(i, "__esModule", { value: true }), i.XevmNetwork = void 0;
      var a, u = l(2164), c = l(8950), l = l(7782);
      class d {
      }
      S(d, "protocol", u.Protocols.evm), S(d, "Types"), S(d, "label", l.NetworkLabels.xevm), S(d, "icon", c.NetworkIcons.xevm), S(d, "asset", "EXRP"), S(d, "active", false), S(d, "defaultReserves", { base: "0", inc: "0" }), i.XevmNetwork = d, a = d || (i.XevmNetwork = d = {}), (u = a.NetworkTypes || (a.NetworkTypes = {})).mainnet = "mainnet", u.testnet = "testnet", u.devnet = "devnet", (a.Explorers || (a.Explorers = {})).peersyst = "peersyst", a.colors = { [a.NetworkTypes.mainnet]: "tw-bg-[#38DBFF]", [a.NetworkTypes.testnet]: "tw-bg-[#DE7EFF]", [a.NetworkTypes.devnet]: "tw-bg-[#FFB648]" }, a.PeersysHost = { [a.NetworkTypes.mainnet]: "", [a.NetworkTypes.testnet]: "", [a.NetworkTypes.devnet]: "https://evm-sidechain.xrpl.org" }, a.Hosts = { [a.Explorers.peersyst]: a.PeersysHost }, a.ExplorerAddressPath = { [a.Explorers.peersyst]: "/address" }, a.ExplorerTxPath = { [a.Explorers.peersyst]: "/tx" }, a.getExplorerHost = (h, f) => {
        if (h === a.Explorers.peersyst) return a.PeersysHost[f];
      }, a.getExplorerPath = (h, f) => f === "address" ? a.ExplorerAddressPath[h] : f === "tx" ? a.ExplorerTxPath[h] : void 0;
    }, 1743: (s, i, l) => {
      Object.defineProperty(i, "__esModule", { value: true }), i.XrplLedgerNetwork = void 0;
      var a, u = l(2164), c = l(8950), l = l(7782);
      class d {
      }
      S(d, "protocol", u.Protocols.xrpl), S(d, "Types"), S(d, "label", l.NetworkLabels.xrpl), S(d, "icon", c.NetworkIcons.xrpl), S(d, "asset", "XRP"), S(d, "active", true), S(d, "defaultReserves", { base: "10", inc: "2" }), i.XrplLedgerNetwork = d, a = d || (i.XrplLedgerNetwork = d = {}), (u = a.NetworkTypes || (a.NetworkTypes = {})).mainnet = "mainnet", u.testnet = "testnet", u.devnet = "devnet", u.xls30d = "xls30d", u.xls38d = "xls38d", (u = a.Explorers || (a.Explorers = {})).bithomp = "bithomp", u.xrplorg = "xrpl.org", u.xrplf = "xrplf", u.xrpscan = "xrpscan", a.colors = { [a.NetworkTypes.mainnet]: "tw-bg-[#38DBFF]", [a.NetworkTypes.testnet]: "tw-bg-[#DE7EFF]", [a.NetworkTypes.devnet]: "tw-bg-[#FFB648]", [a.NetworkTypes.xls30d]: "tw-bg-[#FF9C7C]", [a.NetworkTypes.xls38d]: "tw-bg-[#C34D27]" }, a.BithompHost = { [a.NetworkTypes.mainnet]: "https://bithomp.com/explorer", [a.NetworkTypes.testnet]: "https://test.bithomp.com/explorer", [a.NetworkTypes.devnet]: "https://dev.bithomp.com/explorer", [a.NetworkTypes.xls30d]: "https://amm.bithomp.com/explorer", [a.NetworkTypes.xls38d]: "" }, a.XrplfHost = { [a.NetworkTypes.mainnet]: "https://explorer.xrplf.org", [a.NetworkTypes.testnet]: "https://explorer-testnet.xrplf.org", [a.NetworkTypes.devnet]: "", [a.NetworkTypes.xls30d]: "", [a.NetworkTypes.xls38d]: "" }, a.XrplOrgHost = { [a.NetworkTypes.mainnet]: "https://livenet.xrpl.org", [a.NetworkTypes.testnet]: "https://testnet.xrpl.org", [a.NetworkTypes.devnet]: "https://devnet.xrpl.org", [a.NetworkTypes.xls30d]: "", [a.NetworkTypes.xls38d]: "" }, a.XRPScanHost = { [a.NetworkTypes.mainnet]: "https://xrpscan.com", [a.NetworkTypes.testnet]: "", [a.NetworkTypes.devnet]: "", [a.NetworkTypes.xls30d]: "", [a.NetworkTypes.xls38d]: "" }, a.Hosts = { [a.Explorers.bithomp]: a.BithompHost, [a.Explorers.xrplf]: a.XrplfHost, [a.Explorers.xrplorg]: a.XrplOrgHost, [a.Explorers.xrpscan]: a.XRPScanHost }, a.ExplorerAddressPath = { [a.Explorers.bithomp]: "", [a.Explorers.xrplorg]: "/address", [a.Explorers.xrplf]: "", [a.Explorers.xrpscan]: "/account" }, a.ExplorerTxPath = { [a.Explorers.bithomp]: "", [a.Explorers.xrplorg]: "/transactions", [a.Explorers.xrplf]: "/tx", [a.Explorers.xrpscan]: "/tx" }, a.getExplorerHost = (h, f) => h === a.Explorers.bithomp ? a.BithompHost[f] : h === a.Explorers.xrplf ? a.XrplfHost[f] : h === a.Explorers.xrplorg ? a.XrplOrgHost[f] : h === a.Explorers.xrpscan ? a.XRPScanHost[f] : void 0, a.getExplorerPath = (h, f) => f === "address" ? a.ExplorerAddressPath[h] : f === "tx" ? a.ExplorerTxPath[h] : void 0;
    }, 2164: (s, i) => {
      Object.defineProperty(i, "__esModule", { value: true }), i.Protocols = void 0, i.Protocols = { xrpl: "XRPL", evm: "EVM", btc: "BTC", bsc: "BSC", ada: "ADA", sol: "SOL", usd: "USD" };
    }, 2789: (s, i, o) => {
      Object.defineProperty(i, "__esModule", { value: true }), i.Security = void 0;
      const a = o(2625);
      class u {
      }
      S(u, "EncryptTypes"), S(u, "AlgoTypes", o(6914).AlgoTypes), ((i.Security = u) || (i.Security = u = {})).AllEncryptionTypes = { AES_CBC: a.AES_CBC, AES_GCM: a.AES_GCM, PBKDF2: a.PBKDF2, Standard: a.Standard };
    }, 7083: (s, i, o) => {
      var a;
      Object.defineProperty(i, "__esModule", { value: true }), i.Types = void 0, o(4575).Types.Api.Types, i.Types = (a = class {
      }, S(a, "AgreementsSchema"), S(a, "GeneralSchema"), S(a, "NodeSchema"), S(a, "CardSchema"), S(a, "ContactSchema"), S(a, "ProfileSchema"), S(a, "SecuritySchema"), S(a, "StateSchema"), S(a, "UserSchema"), S(a, "AppSchema"), S(a, "PreferenceSchema"), S(a, "VaultSchema"), S(a, "MountedUserSchema"), S(a, "SecurityTypes"), S(a, "SecurityLevel"), S(a, "Blank"), a);
    }, 191: (s, i) => {
      Object.defineProperty(i, "__esModule", { value: true }), i.Apps = void 0;
      class o {
      }
      S(o, "AppTitle"), S(o, "AppTypes"), i.Apps = o, (i = (i = o || (i.Apps = o = {})).titles || (i.titles = {})).crossmark = "crossmark", i.embark = "embark";
    }, 5659: function(s, i, p) {
      var a = this && this.__createBinding || (Object.create ? function(_, D, v, E) {
        E === void 0 && (E = v);
        var A = Object.getOwnPropertyDescriptor(D, v);
        A && ("get" in A ? D.__esModule : !A.writable && !A.configurable) || (A = { enumerable: true, get: function() {
          return D[v];
        } }), Object.defineProperty(_, E, A);
      } : function(_, D, v, E) {
        _[E = E === void 0 ? v : E] = D[v];
      }), u = this && this.__setModuleDefault || (Object.create ? function(_, D) {
        Object.defineProperty(_, "default", { enumerable: true, value: D });
      } : function(_, D) {
        _.default = D;
      }), g = this && this.__importStar || function(_) {
        if (_ && _.__esModule) return _;
        var D = {};
        if (_ != null) for (var v in _) v !== "default" && Object.prototype.hasOwnProperty.call(_, v) && a(D, _, v);
        return u(D, _), D;
      }, c = (Object.defineProperty(i, "__esModule", { value: true }), i.Projects = i.BasicUser = i.BasicNetwork = i.Types = void 0, p(1437)), l = g(p(7083)), d = g(p(4855)), h = g(p(2789)), f = g(p(8084)), g = g(p(191)), p = p(2164);
      class b {
      }
      S(b, "AllNetworks", c.AllNetworks), S(b, "AllNodeTypes", c.AllNetworks.AllNodeTypes), S(b, "AllNodeExplorers", c.AllNetworks.AllNodeExplorers), S(b, "Themes", f), S(b, "Apps", g), S(b, "AllProtocols", p.Protocols), S(b, "Api", l), S(b, "Card", d.Card), S(b, "Security", h.Security), S(b, "BasicNetwork"), S(b, "BasicUser"), S(b, "NodeTypes"), S(b, "NodeExplorers"), S(b, "Protocols"), S(b, "Networks"), S(b, "Icons"), S(b, "EncryptionTypes"), S(b, "EncryptTypes"), S(b, "CardEncryptionTypes"), S(b, "PasscodeEncryptionTypes"), S(b, "availableProtocols", [p.Protocols.xrpl, p.Protocols.evm]), S(b, "NetworkIdentifiers", { [c.AllNetworks.NetworkLabels.xrpl]: c.AllNetworks.XrplLedger, [c.AllNetworks.NetworkLabels.xevm]: c.AllNetworks.Xevm, [c.AllNetworks.NetworkLabels.xahau]: c.AllNetworks.Xahau }), i.Types = b, i.BasicNetwork = b.BasicNetwork, i.BasicUser = b.BasicUser, i.Projects = g.Apps;
    }, 8084: (s, i, o) => {
      Object.defineProperty(i, "__esModule", { value: true }), i.Themes = void 0;
      const a = o(191);
      class u {
      }
      S(u, "ThemeTypes");
      var c;
      i.Themes = u, o = u || (i.Themes = u = {}), (c = i = o.availableThemes || (o.availableThemes = {})).theme1 = "theme1", c.theme2 = "theme2", c.theme3 = "theme3", c.theme4 = "theme4", c.theme5 = "theme5", c.theme6 = "theme6", o.DefaultThemes = { [a.Apps.titles.crossmark]: i.theme1, [a.Apps.titles.embark]: i.theme6 }, o.CrossmarkThemeKey = { [i.theme1]: "light", [i.theme2]: "dark", [i.theme3]: "moon", [i.theme4]: "sun", [i.theme5]: "blueberry", [i.theme6]: "treeberry" }, o.EmbarkThemeKey = { [i.theme1]: "", [i.theme2]: "", [i.theme3]: "", [i.theme4]: "", [i.theme5]: "", [i.theme6]: "treeberry" }, o.ThemeKey = { [a.Apps.titles.crossmark]: o.CrossmarkThemeKey, [a.Apps.titles.embark]: o.EmbarkThemeKey }, o.ToastColor = { [i.theme1]: "light", [i.theme2]: "dark", [i.theme3]: "light", [i.theme4]: "light", [i.theme5]: "dark", [i.theme6]: "dark" }, o.SpinnerColor = { [i.theme1]: "black", [i.theme2]: "white", [i.theme3]: "black", [i.theme4]: "black", [i.theme5]: "light", [i.theme6]: "light" };
    }, 2876: function(s, i, l) {
      var a = this && this.__createBinding || (Object.create ? function(h, f, g, p) {
        p === void 0 && (p = g);
        var b = Object.getOwnPropertyDescriptor(f, g);
        b && ("get" in b ? f.__esModule : !b.writable && !b.configurable) || (b = { enumerable: true, get: function() {
          return f[g];
        } }), Object.defineProperty(h, p, b);
      } : function(h, f, g, p) {
        h[p = p === void 0 ? g : p] = f[g];
      }), u = this && this.__setModuleDefault || (Object.create ? function(h, f) {
        Object.defineProperty(h, "default", { enumerable: true, value: f });
      } : function(h, f) {
        h.default = f;
      }), c = this && this.__importStar || function(h) {
        if (h && h.__esModule) return h;
        var f = {};
        if (h != null) for (var g in h) g !== "default" && Object.prototype.hasOwnProperty.call(h, g) && a(f, h, g);
        return u(f, h), f;
      }, c = (Object.defineProperty(i, "__esModule", { value: true }), i.Types = void 0, c(l(4080))), l = l(5659).Types.Api.Types;
      class d {
      }
      S(d, "AgreementsSchema"), S(d, "GeneralSchema"), S(d, "NodeSchema"), S(d, "ContactSchema"), S(d, "ProfileSchema"), S(d, "AppSchema"), S(d, "PreferenceSchema"), S(d, "VaultSchema"), S(d, "CardSchema"), S(d, "StateSchema"), S(d, "SecuritySchema"), S(d, "UserSchema"), S(d, "MountedUserSchema"), S(d, "SecurityTypes", c), S(d, "SecurityLevel", l.SecurityLevel), S(d, "Blank"), i.Types = d;
    }, 43: (s, i) => {
      Object.defineProperty(i, "__esModule", { value: true }), i.Apps = void 0;
      class o {
      }
      S(o, "AppTitle"), S(o, "AppTypes"), i.Apps = o, (i = (i = o || (i.Apps = o = {})).titles || (i.titles = {})).crossmark = "crossmark", i.embark = "embark";
    }, 9455: (s, i) => {
      Object.defineProperty(i, "__esModule", { value: true }), i.Index = void 0, i.Index = class {
        constructor() {
          S(this, "algo");
          S(this, "type");
          S(this, "opts");
        }
      };
    }, 3710: (s, i, o) => {
      Object.defineProperty(i, "__esModule", { value: true }), i.HashTypes = i.AesTypes = i.Standard = i.Pbkdf2 = i.hash = i.aes = void 0;
      var a = o(9455);
      Object.defineProperty(i, "aes", { enumerable: true, get: function() {
        return a.Index;
      } });
      const u = o(1261), c = (Object.defineProperty(i, "Standard", { enumerable: true, get: function() {
        return u.Index;
      } }), o(4483));
      Object.defineProperty(i, "Pbkdf2", { enumerable: true, get: function() {
        return c.Index;
      } }), i.hash = { Pbkdf2: c.Index, Standard: u.Index }, i.AesTypes = { cbc: "aes-cbc", gcm: "aes-gcm", ctr: "aes-ctr", cfb: "aes-cfb", ecb: "aes-ecb", ofb: "aes-ofb" }, i.HashTypes = { standard: "hmac256", pbkdf2: "pbkdf2" };
    }, 4483: (s, i, o) => {
      Object.defineProperty(i, "__esModule", { value: true }), i.Index = void 0;
      var a = o(3710);
      i.Index = class {
        constructor() {
          S(this, "type", a.HashTypes.pbkdf2);
          S(this, "opts");
          S(this, "make");
        }
      };
    }, 1261: (s, i, o) => {
      Object.defineProperty(i, "__esModule", { value: true }), i.Index = void 0;
      var a = o(3710);
      i.Index = class {
        constructor() {
          S(this, "type", a.HashTypes.standard);
          S(this, "make");
        }
      };
    }, 5541: function(s, i, p) {
      var a = this && this.__createBinding || (Object.create ? function(_, D, v, E) {
        E === void 0 && (E = v);
        var A = Object.getOwnPropertyDescriptor(D, v);
        A && ("get" in A ? D.__esModule : !A.writable && !A.configurable) || (A = { enumerable: true, get: function() {
          return D[v];
        } }), Object.defineProperty(_, E, A);
      } : function(_, D, v, E) {
        _[E = E === void 0 ? v : E] = D[v];
      }), u = this && this.__setModuleDefault || (Object.create ? function(_, D) {
        Object.defineProperty(_, "default", { enumerable: true, value: D });
      } : function(_, D) {
        _.default = D;
      }), g = this && this.__importStar || function(_) {
        if (_ && _.__esModule) return _;
        var D = {};
        if (_ != null) for (var v in _) v !== "default" && Object.prototype.hasOwnProperty.call(_, v) && a(D, _, v);
        return u(D, _), D;
      }, c = (Object.defineProperty(i, "__esModule", { value: true }), i.AllHashTypes = i.AllEncryptionTypes = i.Projects = i.BasicUser = i.BasicNetwork = i.Types = void 0, p(1437)), l = g(p(2876)), d = g(p(4855)), h = g(p(4080)), f = g(p(2897)), g = g(p(43)), p = p(2164);
      class b {
      }
      S(b, "AllNetworks", c.AllNetworks), S(b, "AllNodeTypes", c.AllNetworks.AllNodeTypes), S(b, "AllNodeExplorers", c.AllNetworks.AllNodeExplorers), S(b, "Themes", f), S(b, "Apps", g), S(b, "AllProtocols", p.Protocols), S(b, "Api", l), S(b, "Card", d.Card), S(b, "Security", h), S(b, "BasicNetwork"), S(b, "BasicUser"), S(b, "NodeTypes"), S(b, "NodeExplorers"), S(b, "Protocols"), S(b, "Networks"), S(b, "Icons"), S(b, "EncryptionTypes"), S(b, "EncryptTypes"), S(b, "HashTypes"), S(b, "CardEncryptionTypes"), S(b, "PasscodeHashTypes"), S(b, "availableProtocols", [p.Protocols.xrpl, p.Protocols.evm]), S(b, "NetworkIdentifiers", { [c.AllNetworks.NetworkLabels.xrpl]: c.AllNetworks.XrplLedger, [c.AllNetworks.NetworkLabels.xevm]: c.AllNetworks.Xevm, [c.AllNetworks.NetworkLabels.xahau]: c.AllNetworks.Xahau }), i.Types = b, i.BasicNetwork = b.BasicNetwork, i.BasicUser = b.BasicUser, i.Projects = g.Apps, i.AllEncryptionTypes = h.AllEncryptionTypes, i.AllHashTypes = h.AllHashTypes;
    }, 4080: function(s, i, o) {
      var a = this && this.__createBinding || (Object.create ? function(l, d, h, f) {
        f === void 0 && (f = h);
        var g = Object.getOwnPropertyDescriptor(d, h);
        g && ("get" in g ? d.__esModule : !g.writable && !g.configurable) || (g = { enumerable: true, get: function() {
          return d[h];
        } }), Object.defineProperty(l, f, g);
      } : function(l, d, h, f) {
        l[f = f === void 0 ? h : f] = d[h];
      }), u = this && this.__setModuleDefault || (Object.create ? function(l, d) {
        Object.defineProperty(l, "default", { enumerable: true, value: d });
      } : function(l, d) {
        l.default = d;
      }), c = this && this.__importStar || function(l) {
        if (l && l.__esModule) return l;
        var d = {};
        if (l != null) for (var h in l) h !== "default" && Object.prototype.hasOwnProperty.call(l, h) && a(d, l, h);
        return u(d, l), d;
      }, c = (Object.defineProperty(i, "__esModule", { value: true }), i.AllHashTypes = i.AllEncryptionTypes = void 0, c(o(3710)));
      i.AllEncryptionTypes = { AES_CBC: c.AesTypes.cbc, AES_GCM: c.AesTypes.gcm, AES_CTR: c.AesTypes.ctr, AES_ECB: c.AesTypes.ecb, AES_OFB: c.AesTypes.ofb, AES_CFB: c.AesTypes.cfb }, i.AllHashTypes = { PBKDF2: c.HashTypes.pbkdf2, Standard: c.HashTypes.standard };
    }, 2897: (s, i, o) => {
      Object.defineProperty(i, "__esModule", { value: true }), i.Themes = void 0;
      const a = o(43);
      class u {
      }
      S(u, "ThemeTypes");
      var c;
      i.Themes = u, o = u || (i.Themes = u = {}), (c = i = o.availableThemes || (o.availableThemes = {})).theme1 = "theme1", c.theme2 = "theme2", c.theme3 = "theme3", c.theme4 = "theme4", c.theme5 = "theme5", c.theme6 = "theme6", o.DefaultThemes = { [a.Apps.titles.crossmark]: i.theme1, [a.Apps.titles.embark]: i.theme6 }, o.CrossmarkThemeKey = { [i.theme1]: "light", [i.theme2]: "dark", [i.theme3]: "moon", [i.theme4]: "sun", [i.theme5]: "blueberry", [i.theme6]: "treeberry" }, o.EmbarkThemeKey = { [i.theme1]: "", [i.theme2]: "", [i.theme3]: "", [i.theme4]: "", [i.theme5]: "", [i.theme6]: "treeberry" }, o.ThemeKey = { [a.Apps.titles.crossmark]: o.CrossmarkThemeKey, [a.Apps.titles.embark]: o.EmbarkThemeKey }, o.ToastColor = { [i.theme1]: "light", [i.theme2]: "dark", [i.theme3]: "light", [i.theme4]: "light", [i.theme5]: "dark", [i.theme6]: "dark" }, o.SpinnerColor = { [i.theme1]: "black", [i.theme2]: "white", [i.theme3]: "black", [i.theme4]: "black", [i.theme5]: "light", [i.theme6]: "light" };
    }, 9815: (s, i, o) => {
      Object.defineProperty(i, "__esModule", { value: true }), i.HashTypes = i.EncryptionAlgos = i.Projects = i.BasicUser = i.BasicNetwork = i.CatchAllEvent = i.TYPES = i.COMMANDS = i.EVENTS = i.Events = i.Models = i.Config = void 0;
      var a = o(2025), u = (Object.defineProperty(i, "Config", { enumerable: true, get: function() {
        return a.Config;
      } }), o(9291)), c = (Object.defineProperty(i, "Models", { enumerable: true, get: function() {
        return u.Models;
      } }), o(7268)), l = (Object.defineProperty(i, "Events", { enumerable: true, get: function() {
        return c.Events;
      } }), o(4151)), d = (Object.defineProperty(i, "EVENTS", { enumerable: true, get: function() {
        return l.EVENTS;
      } }), Object.defineProperty(i, "COMMANDS", { enumerable: true, get: function() {
        return l.COMMANDS;
      } }), Object.defineProperty(i, "TYPES", { enumerable: true, get: function() {
        return l.TYPES;
      } }), Object.defineProperty(i, "CatchAllEvent", { enumerable: true, get: function() {
        return l.CatchAllEvent;
      } }), o(5541));
      Object.defineProperty(i, "BasicNetwork", { enumerable: true, get: function() {
        return d.BasicNetwork;
      } }), Object.defineProperty(i, "BasicUser", { enumerable: true, get: function() {
        return d.BasicUser;
      } }), Object.defineProperty(i, "Projects", { enumerable: true, get: function() {
        return d.Projects;
      } }), Object.defineProperty(i, "EncryptionAlgos", { enumerable: true, get: function() {
        return d.AllEncryptionTypes;
      } }), Object.defineProperty(i, "HashTypes", { enumerable: true, get: function() {
        return d.AllHashTypes;
      } });
    } }, n = {};
    return function s(i) {
      var o = n[i];
      return o === void 0 && (o = n[i] = { exports: {} }, t[i].call(o.exports, o, o.exports, s)), o.exports;
    }(4240);
  })());
})(Cp);
var sm = Cp.exports;
var Js = Cs(sm);
var om = class {
  constructor(e = {}) {
    this.id = "crossmark", this.name = "Crossmark", this.icon = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjE1MCIgaGVpZ2h0PSIxNDgiPgo8cGF0aCBkPSJNMCAwIEM0OS41IDAgOTkgMCAxNTAgMCBDMTUwIDQ4Ljg0IDE1MCA5Ny42OCAxNTAgMTQ4IEMxMDAuNSAxNDggNTEgMTQ4IDAgMTQ4IEMwIDk5LjE2IDAgNTAuMzIgMCAwIFogIiBmaWxsPSIjRTE0QzQ3IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLDApIi8+CjxwYXRoIGQ9Ik0wIDAgQzMuMTU0NTE2NSAxLjM0NDczMTcyIDUuODE3Mjg5NzcgMy4zMDUxNTA3OSA4LjU3NDIxODc1IDUuMzEyNSBDMTkuNzIxNjI5NDEgMTMuMzg2NTU5MTIgMjguNzgyNDI2MTMgMTQuNjU0ODMzNDcgNDIuMTk5MjE4NzUgMTMuOTM3NSBDNTAuNTE1OTg5OTcgMTIuNTE1MjExNTkgNTguMzgzMTU2NzYgNy41OTg0NjY2MyA2NC41NzQyMTg3NSAyIEM2Ny4xOTkyMTg3NSAtMC4wNjI1IDY3LjE5OTIxODc1IC0wLjA2MjUgNjkuMTU2MjUgMC4xMzY3MTg3NSBDNzEuNDIzOTM1NzIgMS4wMjU1ODIxOCA3Mi43NjEwMjIyNyAyLjAwMTk2NTkyIDc0LjUxMTcxODc1IDMuNjg3NSBDNzUuMzEwMjkyOTcgNC40MjIyNjU2MyA3NS4zMTAyOTI5NyA0LjQyMjI2NTYzIDc2LjEyNSA1LjE3MTg3NSBDNzcuMTk5MjE4NzUgNi45Mzc1IDc3LjE5OTIxODc1IDYuOTM3NSA3Ny4xNDA2MjUgOS4yMTQ4NDM3NSBDNzUuNjgzMDU4OCAxMy40MzAyOTQ1NSA3My4xMjc0ODczOSAxNi44NjQ0NjQ1NyA3MC42MTMyODEyNSAyMC41MDE5NTMxMiBDNjUuNjQ0Nzg3OTggMjcuODk3NDg5OTkgNjMuNjQ1Nzk5NDkgMzQuMzg5NDEyNDEgNjMuNzYxNzE4NzUgNDMuMzEyNSBDNjMuNzc2MzQxNTUgNDQuNTcyNDc4MDMgNjMuNzc2MzQxNTUgNDQuNTcyNDc4MDMgNjMuNzkxMjU5NzcgNDUuODU3OTEwMTYgQzY0LjA5MjU1MDcxIDU2LjM4Nzc3MzE5IDY3LjkyODcwODczIDYzLjIzNzYwNTk3IDc0LjI4ODgxODM2IDcxLjM4NjIzMDQ3IEM3Ni4xODQ1NDY3MSA3My45MDk5NDU4IDc3LjIxMTYzNjA1IDc1LjQwNTg4NDQzIDc3LjEzNjcxODc1IDc4LjYxMzI4MTI1IEM3Ni4xNTk2MjEwOCA4MS4wMzU2NjkyMiA3NS4yMjg5ODA2OCA4Mi40NzQ5MDIwMyA3My4zODY3MTg3NSA4NC4zMTI1IEM3Mi44ODUyNzM0NCA4NC44MzU4NTkzNyA3Mi4zODM4MjgxMiA4NS4zNTkyMTg3NSA3MS44NjcxODc1IDg1Ljg5ODQzNzUgQzcwLjE5OTIxODc1IDg2LjkzNzUgNzAuMTk5MjE4NzUgODYuOTM3NSA2OC4yODkwNjI1IDg2LjgwNDY4NzUgQzY1LjczNzc1NjY4IDg1Ljc0NjAxNDgxIDYzLjc4NTM0MDkxIDg0LjM0NDA0MTAzIDYxLjU3NDIxODc1IDgyLjY4NzUgQzQ5LjgzNTgyNzgyIDc0LjI3MzI1NTE3IDM5LjU2MzA4NzIxIDcxLjkzMTg3OTEyIDI1LjE5OTIxODc1IDcyLjkzNzUgQzE3LjcyNDQ2NzQ4IDc0LjQzNjc2NDY4IDExLjg5MzA0NiA3OS4wNDU3OTE2NiA2LjAxOTI4NzExIDgzLjY3MTM4NjcyIEMxLjc0NTc1MTM4IDg2Ljk0NjIwNTgzIDEuNzQ1NzUxMzggODYuOTQ2MjA1ODMgLTEuMDA3ODEyNSA4Ni45MDIzNDM3NSBDLTIuOTg4MDU0NTYgODUuODM2NzIzMyAtNC40OTE1OTEwNSA4NC43NDg4Mjk1MiAtNi4xMTMyODEyNSA4My4xODc1IEMtNi42NDU2NjQwNiA4Mi42OTc2NTYyNSAtNy4xNzgwNDY4NyA4Mi4yMDc4MTI1IC03LjcyNjU2MjUgODEuNzAzMTI1IEMtOC44MDA3ODEyNSA3OS45Mzc1IC04LjgwMDc4MTI1IDc5LjkzNzUgLTguNzA3MDMxMjUgNzcuNTYyNSBDLTcuNjE1MTk1OTcgNzQuMzk5OTQyNjMgLTYuMDU3NDk4MDMgNzIuMzEzMzcwNjUgLTMuOTg4MjgxMjUgNjkuNjg3NSBDMy44MTAzMTMyNSA1OS4zMDMzNDk5OCA2LjA2Nzg2NDI3IDQ5Ljg2ODg0NTUzIDUuMTk5MjE4NzUgMzYuOTM3NSBDMy43MTgyNjUxNSAyNy44NDc5Nzc0MiAtMS4yMTI1NjMxMyAyMC4yNjYxNDQwOCAtNy4wMTU2MjUgMTMuMjY1NjI1IEMtOC44MDA3ODEyNSAxMC45Mzc1IC04LjgwMDc4MTI1IDEwLjkzNzUgLTguOTI1NzgxMjUgOC41IEMtNy4zNDk5MTAxNyA0LjkxMDUxNTg3IC00LjM4MzcwMTUxIC0wLjE1MjE0NTgyIDAgMCBaICIgZmlsbD0iI0UyNEU0NyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNDAuODAwNzgxMjUsMzIuMDYyNSkiLz4KPHBhdGggZD0iTTAgMCBDMy4xNTQ1MTY1IDEuMzQ0NzMxNzIgNS44MTcyODk3NyAzLjMwNTE1MDc5IDguNTc0MjE4NzUgNS4zMTI1IEMxOS43MjE2Mjk0MSAxMy4zODY1NTkxMiAyOC43ODI0MjYxMyAxNC42NTQ4MzM0NyA0Mi4xOTkyMTg3NSAxMy45Mzc1IEM1MC41MTU5ODk5NyAxMi41MTUyMTE1OSA1OC4zODMxNTY3NiA3LjU5ODQ2NjYzIDY0LjU3NDIxODc1IDIgQzY3LjE5OTIxODc1IC0wLjA2MjUgNjcuMTk5MjE4NzUgLTAuMDYyNSA2OS4xNTYyNSAwLjEzNjcxODc1IEM3MS40MjM5MzU3MiAxLjAyNTU4MjE4IDcyLjc2MTAyMjI3IDIuMDAxOTY1OTIgNzQuNTExNzE4NzUgMy42ODc1IEM3NS4zMTAyOTI5NyA0LjQyMjI2NTYzIDc1LjMxMDI5Mjk3IDQuNDIyMjY1NjMgNzYuMTI1IDUuMTcxODc1IEM3Ny4xOTkyMTg3NSA2LjkzNzUgNzcuMTk5MjE4NzUgNi45Mzc1IDc3LjE0MDYyNSA5LjIxNDg0Mzc1IEM3NS42ODMwNTg4IDEzLjQzMDI5NDU1IDczLjEyNzQ4NzM5IDE2Ljg2NDQ2NDU3IDcwLjYxMzI4MTI1IDIwLjUwMTk1MzEyIEM2NS42NDQ3ODc5OCAyNy44OTc0ODk5OSA2My42NDU3OTk0OSAzNC4zODk0MTI0MSA2My43NjE3MTg3NSA0My4zMTI1IEM2My43NzYzNDE1NSA0NC41NzI0NzgwMyA2My43NzYzNDE1NSA0NC41NzI0NzgwMyA2My43OTEyNTk3NyA0NS44NTc5MTAxNiBDNjQuMDkyNTUwNzEgNTYuMzg3NzczMTkgNjcuOTI4NzA4NzMgNjMuMjM3NjA1OTcgNzQuMjg4ODE4MzYgNzEuMzg2MjMwNDcgQzc2LjE4NDU0NjcxIDczLjkwOTk0NTggNzcuMjExNjM2MDUgNzUuNDA1ODg0NDMgNzcuMTM2NzE4NzUgNzguNjEzMjgxMjUgQzc2LjE1OTYyMTA4IDgxLjAzNTY2OTIyIDc1LjIyODk4MDY4IDgyLjQ3NDkwMjAzIDczLjM4NjcxODc1IDg0LjMxMjUgQzcyLjg4NTI3MzQ0IDg0LjgzNTg1OTM3IDcyLjM4MzgyODEyIDg1LjM1OTIxODc1IDcxLjg2NzE4NzUgODUuODk4NDM3NSBDNzAuMTk5MjE4NzUgODYuOTM3NSA3MC4xOTkyMTg3NSA4Ni45Mzc1IDY4LjI4OTA2MjUgODYuODA0Njg3NSBDNjUuNzM3NzU2NjggODUuNzQ2MDE0ODEgNjMuNzg1MzQwOTEgODQuMzQ0MDQxMDMgNjEuNTc0MjE4NzUgODIuNjg3NSBDNDkuODM1ODI3ODIgNzQuMjczMjU1MTcgMzkuNTYzMDg3MjEgNzEuOTMxODc5MTIgMjUuMTk5MjE4NzUgNzIuOTM3NSBDMTcuNzI0NDY3NDggNzQuNDM2NzY0NjggMTEuODkzMDQ2IDc5LjA0NTc5MTY2IDYuMDE5Mjg3MTEgODMuNjcxMzg2NzIgQzEuNzQ1NzUxMzggODYuOTQ2MjA1ODMgMS43NDU3NTEzOCA4Ni45NDYyMDU4MyAtMS4wMDc4MTI1IDg2LjkwMjM0Mzc1IEMtMi45ODgwNTQ1NiA4NS44MzY3MjMzIC00LjQ5MTU5MTA1IDg0Ljc0ODgyOTUyIC02LjExMzI4MTI1IDgzLjE4NzUgQy02LjY0NTY2NDA2IDgyLjY5NzY1NjI1IC03LjE3ODA0Njg3IDgyLjIwNzgxMjUgLTcuNzI2NTYyNSA4MS43MDMxMjUgQy04LjgwMDc4MTI1IDc5LjkzNzUgLTguODAwNzgxMjUgNzkuOTM3NSAtOC43MDcwMzEyNSA3Ny41NjI1IEMtNy42MTUxOTU5NyA3NC4zOTk5NDI2MyAtNi4wNTc0OTgwMyA3Mi4zMTMzNzA2NSAtMy45ODgyODEyNSA2OS42ODc1IEMzLjgxMDMxMzI1IDU5LjMwMzM0OTk4IDYuMDY3ODY0MjcgNDkuODY4ODQ1NTMgNS4xOTkyMTg3NSAzNi45Mzc1IEMzLjcxODI2NTE1IDI3Ljg0Nzk3NzQyIC0xLjIxMjU2MzEzIDIwLjI2NjE0NDA4IC03LjAxNTYyNSAxMy4yNjU2MjUgQy04LjgwMDc4MTI1IDEwLjkzNzUgLTguODAwNzgxMjUgMTAuOTM3NSAtOC45MjU3ODEyNSA4LjUgQy03LjM0OTkxMDE3IDQuOTEwNTE1ODcgLTQuMzgzNzAxNTEgLTAuMTUyMTQ1ODIgMCAwIFogTS0wLjgwMDc4MTI1IDUuOTM3NSBDLTEuNDYwNzgxMjUgNi41OTc1IC0yLjEyMDc4MTI1IDcuMjU3NSAtMi44MDA3ODEyNSA3LjkzNzUgQy0yLjQ2MzgxNTI5IDExLjU2NTc2MTM1IC0wLjUxMTgyNzg0IDE0LjA1Nzg0MTI1IDEuNTExNzE4NzUgMTcgQzguMzE5MDQ1NjggMjcuNDI3NjUwNyAxMS42ODQ1MDAzOCAzOC40ODQ1NjM1IDkuNzM4MjgxMjUgNTAuODcxMDkzNzUgQzcuODQ2Nzc0NjggNTkuNDI3Mzc5MzUgNC40NTQ1MTI1NyA2Ny4wOTc5MjI2NyAtMS4yMzgyODEyNSA3My44MTI1IEMtMy4xMTg0ODE1IDc1Ljg3ODc2MTMyIC0zLjExODQ4MTUgNzUuODc4NzYxMzIgLTIuNTUwNzgxMjUgNzguNzUgQy0yLjMwMzI4MTI1IDc5LjQ3MTg3NSAtMi4wNTU3ODEyNSA4MC4xOTM3NSAtMS44MDA3ODEyNSA4MC45Mzc1IEMyLjMwMjQ2NDg1IDgwLjM5Mzc4MzY0IDQuNTgyNjIwNyA3OS4xNTY0ODIwOSA3LjgyNDIxODc1IDc2LjYyNSBDMTIuOTc1NTQxODYgNzIuODYzODM5MDUgMTguMTQyMTgyMDcgNzAuODEyMDU3MTEgMjQuMTk5MjE4NzUgNjguOTM3NSBDMjUuNjg0MjE4NzUgNjguNDQyNSAyNS42ODQyMTg3NSA2OC40NDI1IDI3LjE5OTIxODc1IDY3LjkzNzUgQzQxLjYyMjg4NzM4IDY2Ljk5MzQ4NTE2IDUyLjYwNzczOTY1IDcwLjA1NTgyMzY4IDY0LjEzNjcxODc1IDc4Ljg3NSBDNjYuODgxNTA4MyA4MS4xODkzMDk5NSA2Ni44ODE1MDgzIDgxLjE4OTMwOTk1IDY5LjMyODEyNSA4MC43NTM5MDYyNSBDNjkuOTQ1NTg1OTQgODAuNDg0NDkyMTkgNzAuNTYzMDQ2ODcgODAuMjE1MDc4MTMgNzEuMTk5MjE4NzUgNzkuOTM3NSBDNzEuNjk0MjE4NzUgNzguNDUyNSA3MS42OTQyMTg3NSA3OC40NTI1IDcyLjE5OTIxODc1IDc2LjkzNzUgQzcwLjg3ODUwNTUzIDc0LjY0NDg4NDk2IDY5LjUyMDE2NjgxIDcyLjUzNzQ2NDU0IDY4LjAxMTcxODc1IDcwLjM3NSBDNTkuNzUyMjc2ODkgNTcuODgyODkzNDQgNTcuNTcyNTQ5OTQgNDcuNjU4MjI5NyA1OS42MzY3MTg3NSAzMi43ODUxNTYyNSBDNjEuMDgzNzEzODUgMjYuNDgxNjgzODMgNjQuMDI1NDE3MTQgMjEuNTQ4NDE4NzkgNjcuNjc1NzgxMjUgMTYuMjUgQzY5LjM0MzIxNDk5IDEzLjkzNTIyNjY2IDY5LjM0MzIxNDk5IDEzLjkzNTIyNjY2IDcwLjE5OTIxODc1IDEwLjkzNzUgQzcwLjg1OTIxODc1IDEwLjkzNzUgNzEuNTE5MjE4NzUgMTAuOTM3NSA3Mi4xOTkyMTg3NSAxMC45Mzc1IEM3MS43MDQyMTg3NSA4Ljk1NzUgNzEuNzA0MjE4NzUgOC45NTc1IDcxLjE5OTIxODc1IDYuOTM3NSBDNjkuNDQwMzUwMDQgNi4xMzIxNzA4OCA2OS40NDAzNTAwNCA2LjEzMjE3MDg4IDY3LjE5OTIxODc1IDUuOTM3NSBDNjQuODM0MzUyMjkgNy4yMTc4MDQ2IDY0LjgzNDM1MjI5IDcuMjE3ODA0NiA2Mi41MTE3MTg3NSA5LjEyNSBDNTcuOTQ3MzMxODUgMTIuNDk5NTU0MDggNTMuNTA2NTE0NzYgMTQuOTUxOTY5MDUgNDguMTk5MjE4NzUgMTYuOTM3NSBDNDcuMjg5MTQwNjMgMTcuMjkzMjgxMjUgNDYuMzc5MDYyNSAxNy42NDkwNjI1IDQ1LjQ0MTQwNjI1IDE4LjAxNTYyNSBDMzUuNzQxNTkwMzQgMjAuNzczNjQ0OTQgMjUuMDE5Mzc3NDIgMTkuODU3MjIxMjEgMTUuOTkyMTg3NSAxNS41MTE3MTg3NSBDMTIuMDQ4ODgzNTkgMTMuMjg5MTI5MjggOC4yMjc0ODUxNSAxMC45MjQyODc4OCA0LjQ3NjU2MjUgOC4zOTA2MjUgQzIuMTgyMDUzMzkgNi43OTYzNzg4IDIuMTgyMDUzMzkgNi43OTYzNzg4IC0wLjgwMDc4MTI1IDUuOTM3NSBaICIgZmlsbD0iI0Y5RURFRCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNDAuODAwNzgxMjUsMzIuMDYyNSkiLz4KPHBhdGggZD0iTTAgMCBDMC41ODEzNjcxOSAwLjIzMDc0MjE5IDEuMTYyNzM0MzcgMC40NjE0ODQzNyAxLjc2MTcxODc1IDAuNjk5MjE4NzUgQzAuNjc4OTA2MjUgMS41MDM1OTM3NSAwLjY3ODkwNjI1IDEuNTAzNTkzNzUgLTAuNDI1NzgxMjUgMi4zMjQyMTg3NSBDLTMuNDg2MTIzMjUgNC45MDg1MDc1NSAtNS43NTA0ODEzNiA3LjU3MTY5ODg5IC04LjIzODI4MTI1IDEwLjY5OTIxODc1IEMtOC45Mzc1IDguOTM3NSAtOC45Mzc1IDguOTM3NSAtOS4yMzgyODEyNSA2LjY5OTIxODc1IEMtNy45NDUzMTI1IDQuNzQyMTg3NSAtNy45NDUzMTI1IDQuNzQyMTg3NSAtNi4wNTA3ODEyNSAyLjg4NjcxODc1IEMtNS40Mzg0NzY1NiAyLjI2MTUyMzQ0IC00LjgyNjE3MTg4IDEuNjM2MzI4MTIgLTQuMTk1MzEyNSAwLjk5MjE4NzUgQy0yLjIzODI4MTI1IC0wLjMwMDc4MTI1IC0yLjIzODI4MTI1IC0wLjMwMDc4MTI1IDAgMCBaICIgZmlsbD0iI0Y1REFERSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNDEuMjM4MjgxMjUsMzIuMzAwNzgxMjUpIi8+CjxwYXRoIGQ9Ik0wIDAgQzIuMzEgMCA0LjYyIDAgNyAwIEM2LjAyNDMzODg4IDEuMTY5NTk5ODcgNS4wNDQzNzUgMi4zMzU2MTE3NyA0LjA2MjUgMy41IEMzLjUxNzIyNjU2IDQuMTQ5Njg3NSAyLjk3MTk1MzEyIDQuNzk5Mzc1IDIuNDEwMTU2MjUgNS40Njg3NSBDMS45NDQ4MDQ2OSA1Ljk3NDA2MjUgMS40Nzk0NTMxMyA2LjQ3OTM3NSAxIDcgQzAuNjcgNyAwLjM0IDcgMCA3IEMwIDQuNjkgMCAyLjM4IDAgMCBaICIgZmlsbD0iIzFDMUIyMyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCwwKSIvPgo8cGF0aCBkPSJNMCAwIEMyLjMxIDAgNC42MiAwIDcgMCBDNyAxLjk4IDcgMy45NiA3IDYgQzUuODMwNTQyMDggNS4xOTE1MjI3MSA0LjY2NDQ5NTM5IDQuMzc4MTA4ODggMy41IDMuNTYyNSBDMi44NTAzMTI1IDMuMTEwMDM5MDYgMi4yMDA2MjUgMi42NTc1NzgxMiAxLjUzMTI1IDIuMTkxNDA2MjUgQzEuMDI1OTM3NSAxLjc5ODI0MjE5IDAuNTIwNjI1IDEuNDA1MDc4MTIgMCAxIEMwIDAuNjcgMCAwLjM0IDAgMCBaICIgZmlsbD0iIzI2MjEyMSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTQzLDApIi8+CjxwYXRoIGQ9Ik0wIDAgQzAuNjYgMC4zMyAxLjMyIDAuNjYgMiAxIEMtMC42NCAzLjY0IC0zLjI4IDYuMjggLTYgOSBDLTYgNiAtNiA2IC0zLjU2MjUgMy4zNzUgQy0yLjcxNjg3NSAyLjU5MTI1IC0xLjg3MTI1IDEuODA3NSAtMSAxIEMtMC42NyAwLjY3IC0wLjM0IDAuMzQgMCAwIFogIiBmaWxsPSIjQkYzNTUzIiB0cmFuc2Zvcm09InRyYW5zbGF0ZSg3LDApIi8+Cjwvc3ZnPgo=", this.url = "https://crossmark.io", this.currentAccount = null;
  }
  /**
   * Check if Crossmark is installed
   */
  async isAvailable() {
    try {
      return !!Js.sync.isInstalled();
    } catch {
      return false;
    }
  }
  /**
   * Connect to Crossmark wallet
   */
  async connect(e) {
    try {
      if (!await this.isAvailable())
        throw me.notInstalled(this.name);
      const n = this.resolveNetwork(e == null ? void 0 : e.network), s = this.generateRandomHash(), i = await Js.methods.signInAndWait(s);
      if (!i || !i.response || !i.response.data)
        throw new Error("Failed to sign in with Crossmark");
      const { address: o, publicKey: a } = i.response.data;
      if (!o)
        throw new Error("No address returned from Crossmark");
      return this.currentAccount = {
        address: o,
        publicKey: a,
        network: n
      }, this.currentAccount;
    } catch (t) {
      throw me.connectionFailed(this.name, t);
    }
  }
  /**
   * Disconnect from Crossmark
   */
  async disconnect() {
    this.currentAccount = null;
  }
  /**
   * Get current account
   */
  async getAccount() {
    return this.currentAccount;
  }
  /**
   * Get current network
   */
  async getNetwork() {
    if (!this.currentAccount)
      throw me.notConnected();
    return this.currentAccount.network;
  }
  /**
   * Sign and optionally submit a transaction
   * @param transaction - The transaction to sign
   * @param submit - Whether to submit to the ledger (default: true)
   */
  async signAndSubmit(e) {
    if (!this.currentAccount)
      throw me.notConnected();
    try {
      const t = {
        ...e,
        Account: e.Account || this.currentAccount.address
      }, n = await Js.methods.signAndSubmitAndWait(t);
      if (!n.response.data.resp.result.hash)
        throw new Error("Failed to sign transaction with Crossmark");
      return {
        hash: n.response.data.resp.result.hash
      };
    } catch (t) {
      throw t instanceof Error && t.message.toLowerCase().includes("reject") ? me.signRejected() : me.signFailed(t);
    }
  }
  /**
   * Sign a message
   */
  async signMessage(e) {
    if (!this.currentAccount)
      throw me.notConnected();
    try {
      const t = typeof e == "string" ? e : new TextDecoder().decode(e), n = await Js.methods.signInAndWait(t);
      if (!n || !n.response || !n.response.data)
        throw new Error("Failed to sign message with Crossmark");
      const { signature: s, publicKey: i } = n.response.data;
      return {
        message: t,
        signature: s || "",
        publicKey: i || this.currentAccount.publicKey || ""
      };
    } catch (t) {
      throw me.signFailed(t);
    }
  }
  /**
   * Resolve network configuration
   */
  resolveNetwork(e) {
    if (!e)
      return Ci.mainnet;
    if (typeof e == "string") {
      const t = Ci[e];
      if (!t)
        throw me.unknown(`Unknown network: ${e}`);
      return t;
    }
    return e;
  }
  /**
   * Generate a random hash for signing
   */
  generateRandomHash() {
    const e = new Uint8Array(32);
    if (typeof window < "u" && window.crypto)
      window.crypto.getRandomValues(e);
    else
      for (let t = 0; t < e.length; t++)
        e[t] = Math.floor(Math.random() * 256);
    return Array.from(e, (t) => t.toString(16).padStart(2, "0")).join("");
  }
};
var xi = {};
var Lp = {};
var ua = {};
var Ke = {};
var la = {};
Object.defineProperty(la, "__esModule", { value: true });
la.API_ERROR_BAD_REQUEST = void 0;
la.API_ERROR_BAD_REQUEST = "gem_BAD_REQUEST";
var zp = {};
Object.defineProperty(zp, "__esModule", { value: true });
var Dn = {};
Object.defineProperty(Dn, "__esModule", { value: true });
Dn.MSG_INTERNAL_RECEIVE_SIGN_OUT = Dn.MSG_INTERNAL_RECEIVE_PASSWORD = Dn.MSG_INTERNAL_REQUEST_PASSWORD = void 0;
Dn.MSG_INTERNAL_REQUEST_PASSWORD = "INTERNAL_REQUEST_PASSWORD";
Dn.MSG_INTERNAL_RECEIVE_PASSWORD = "INTERNAL_RECEIVE_PASSWORD";
Dn.MSG_INTERNAL_RECEIVE_SIGN_OUT = "INTERNAL_RECEIVE_SIGN_OUT";
var kp = {};
Object.defineProperty(kp, "__esModule", { value: true });
var Up = {};
(function(r) {
  var e = B && B.__spreadArray || function(d, h, f) {
    if (f || arguments.length === 2) for (var g = 0, p = h.length, b; g < p; g++)
      (b || !(g in h)) && (b || (b = Array.prototype.slice.call(h, 0, g)), b[g] = h[g]);
    return d.concat(b || Array.prototype.slice.call(h));
  }, t, n, s;
  Object.defineProperty(r, "__esModule", { value: true }), r.getNetworkByNetworkID = r.getNetwork = r.getDefaultNetwork = r.NETWORK = r.FAUCET_XAHAU_TESTNET = r.XAHAU_TESTNET_NODES = r.XAHAU_MAINNET_NODES = r.DEVNET_NODES = r.TESTNET_NODES = r.MAINNET_NODES = r.MAINNET_CLIO_NODES = r.XahauNetwork = r.XRPLNetwork = r.Chain = void 0;
  var i;
  (function(d) {
    d.XRPL = "XRPL", d.XAHAU = "XAHAU";
  })(i || (r.Chain = i = {}));
  var o;
  (function(d) {
    d.MAINNET = "Mainnet", d.TESTNET = "Testnet", d.DEVNET = "Devnet", d.CUSTOM = "Custom";
  })(o || (r.XRPLNetwork = o = {}));
  var a;
  (function(d) {
    d.XAHAU_MAINNET = "Mainnet", d.XAHAU_TESTNET = "Testnet", d.CUSTOM = "Custom";
  })(a || (r.XahauNetwork = a = {})), r.MAINNET_CLIO_NODES = ["wss://s1.ripple.com", "wss://s2.ripple.com"], r.MAINNET_NODES = e(["wss://xrplcluster.com"], r.MAINNET_CLIO_NODES, true), r.TESTNET_NODES = ["wss://s.altnet.rippletest.net:51233", "wss://testnet.xrpl-labs.com"], r.DEVNET_NODES = ["wss://s.devnet.rippletest.net:51233"], r.XAHAU_MAINNET_NODES = ["wss://xahau.network"], r.XAHAU_TESTNET_NODES = ["wss://xahau-test.net"], r.FAUCET_XAHAU_TESTNET = "https://xahau-test.net/accounts", r.NETWORK = (t = {}, t[i.XRPL] = (n = {}, n[o.MAINNET] = {
    chain: i.XRPL,
    name: o.MAINNET,
    server: r.MAINNET_NODES[0],
    nodes: r.MAINNET_NODES,
    description: "Main network using the production version of the XRP Ledger.",
    networkID: 0
  }, n[o.TESTNET] = {
    chain: i.XRPL,
    name: o.TESTNET,
    server: r.TESTNET_NODES[0],
    nodes: r.TESTNET_NODES,
    description: "Acts as a testing network, without impacting production users and risking real money.",
    networkID: 1
  }, n[o.DEVNET] = {
    chain: i.XRPL,
    name: o.DEVNET,
    server: r.DEVNET_NODES[0],
    nodes: r.DEVNET_NODES,
    description: "A preview of upcoming features, where unstable changes are tested out."
  }, n[o.CUSTOM] = {
    chain: i.XRPL,
    name: o.CUSTOM,
    server: "",
    description: "Custom network configuration provided by the user."
  }, n), t[i.XAHAU] = (s = {}, s[a.XAHAU_MAINNET] = {
    chain: i.XAHAU,
    name: a.XAHAU_MAINNET,
    server: r.XAHAU_MAINNET_NODES[0],
    nodes: r.XAHAU_MAINNET_NODES,
    description: "Mainnet for the Xahau blockchain.",
    networkID: 21337
  }, s[a.XAHAU_TESTNET] = {
    chain: i.XAHAU,
    name: a.XAHAU_TESTNET,
    server: r.XAHAU_TESTNET_NODES[0],
    nodes: r.XAHAU_TESTNET_NODES,
    description: "Testnet for the Xahau blockchain.",
    networkID: 21338
  }, s[a.CUSTOM] = {
    chain: i.XAHAU,
    name: a.CUSTOM,
    server: "",
    description: "Custom network configuration provided by the user."
  }, s), t);
  var u = function(d) {
    switch (d) {
      case i.XAHAU:
        return a.XAHAU_MAINNET;
      default:
        return o.MAINNET;
    }
  };
  r.getDefaultNetwork = u;
  function c(d, h) {
    if (d === i.XRPL && Object.values(o).includes(h) || d === i.XAHAU && Object.values(a).includes(h))
      return r.NETWORK[d][h];
    throw new Error("Network ".concat(h, " is not valid for chain ").concat(d));
  }
  r.getNetwork = c;
  var l = function(d) {
    switch (d) {
      case 0:
        return r.NETWORK[i.XRPL][o.MAINNET];
      case 1:
        return r.NETWORK[i.XRPL][o.TESTNET];
      case 21337:
        return r.NETWORK[i.XAHAU][a.XAHAU_MAINNET];
      case 21338:
        return r.NETWORK[i.XAHAU][a.XAHAU_TESTNET];
      default:
        throw new Error("Network ID ".concat(d, " is not valid"));
    }
  };
  r.getNetworkByNetworkID = l;
})(Up);
var da = {};
Object.defineProperty(da, "__esModule", { value: true });
da.GEM_WALLET = void 0;
da.GEM_WALLET = "gem-wallet";
var ha = {};
Object.defineProperty(ha, "__esModule", { value: true });
ha.DEFAULT_SUBMIT_TX_BULK_ON_ERROR = void 0;
ha.DEFAULT_SUBMIT_TX_BULK_ON_ERROR = "abort";
var Pp = {};
Object.defineProperty(Pp, "__esModule", { value: true });
var Bp = {};
Object.defineProperty(Bp, "__esModule", { value: true });
var Rp = {};
Object.defineProperty(Rp, "__esModule", { value: true });
(function(r) {
  var e = B && B.__createBinding || (Object.create ? function(n, s, i, o) {
    o === void 0 && (o = i);
    var a = Object.getOwnPropertyDescriptor(s, i);
    (!a || ("get" in a ? !s.__esModule : a.writable || a.configurable)) && (a = { enumerable: true, get: function() {
      return s[i];
    } }), Object.defineProperty(n, o, a);
  } : function(n, s, i, o) {
    o === void 0 && (o = i), n[o] = s[i];
  }), t = B && B.__exportStar || function(n, s) {
    for (var i in n) i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && e(s, n, i);
  };
  Object.defineProperty(r, "__esModule", { value: true }), t(la, r), t(zp, r), t(Dn, r), t(kp, r), t(Up, r), t(da, r), t(ha, r), t(Pp, r), t(Bp, r), t(Rp, r);
})(Ke);
var Xe = {};
Object.defineProperty(Xe, "__esModule", { value: true });
Xe.deserializeError = void 0;
var am = function(r) {
  var e = new Error(r.message);
  return e.stack = r.stack, e.name = r.name, e;
};
Xe.deserializeError = am;
var Ge = {};
var su = B && B.__assign || function() {
  return su = Object.assign || function(r) {
    for (var e, t = 1, n = arguments.length; t < n; t++) {
      e = arguments[t];
      for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && (r[s] = e[s]);
    }
    return r;
  }, su.apply(this, arguments);
};
Object.defineProperty(Ge, "__esModule", { value: true });
Ge.sendMessageToContentScript = void 0;
var cm = function(r) {
  var e = Date.now() + Math.random();
  return window.postMessage(su({ source: "GEM_WALLET_MSG_REQUEST", messageId: e }, r), window.location.origin), new Promise(function(t, n) {
    !window.gemWallet && r.type !== "REQUEST_IS_INSTALLED/V3" && n(new Error("Please check if GemWallet is installed - GemWallet needs to be installed: https://gemwallet.app"));
    var s = function(i) {
      var o, a;
      i.source === window && ((o = i == null ? void 0 : i.data) === null || o === void 0 ? void 0 : o.source) === "GEM_WALLET_MSG_RESPONSE" && ((a = i == null ? void 0 : i.data) === null || a === void 0 ? void 0 : a.messagedId) === e && (t(i.data), window.removeEventListener("message", s));
    };
    window.addEventListener("message", s, false);
  });
};
Ge.sendMessageToContentScript = cm;
var um = B && B.__awaiter || function(r, e, t, n) {
  function s(i) {
    return i instanceof t ? i : new t(function(o) {
      o(i);
    });
  }
  return new (t || (t = Promise))(function(i, o) {
    function a(l) {
      try {
        c(n.next(l));
      } catch (d) {
        o(d);
      }
    }
    function u(l) {
      try {
        c(n.throw(l));
      } catch (d) {
        o(d);
      }
    }
    function c(l) {
      l.done ? i(l.value) : s(l.value).then(a, u);
    }
    c((n = n.apply(r, e || [])).next());
  });
};
var lm = B && B.__generator || function(r, e) {
  var t = { label: 0, sent: function() {
    if (i[0] & 1) throw i[1];
    return i[1];
  }, trys: [], ops: [] }, n, s, i, o;
  return o = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function a(c) {
    return function(l) {
      return u([c, l]);
    };
  }
  function u(c) {
    if (n) throw new TypeError("Generator is already executing.");
    for (; o && (o = 0, c[0] && (t = 0)), t; ) try {
      if (n = 1, s && (i = c[0] & 2 ? s.return : c[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, c[1])).done) return i;
      switch (s = 0, i && (c = [c[0] & 2, i.value]), c[0]) {
        case 0:
        case 1:
          i = c;
          break;
        case 4:
          return t.label++, { value: c[1], done: false };
        case 5:
          t.label++, s = c[1], c = [0];
          continue;
        case 7:
          c = t.ops.pop(), t.trys.pop();
          continue;
        default:
          if (i = t.trys, !(i = i.length > 0 && i[i.length - 1]) && (c[0] === 6 || c[0] === 2)) {
            t = 0;
            continue;
          }
          if (c[0] === 3 && (!i || c[1] > i[0] && c[1] < i[3])) {
            t.label = c[1];
            break;
          }
          if (c[0] === 6 && t.label < i[1]) {
            t.label = i[1], i = c;
            break;
          }
          if (i && t.label < i[2]) {
            t.label = i[2], t.ops.push(c);
            break;
          }
          i[2] && t.ops.pop(), t.trys.pop();
          continue;
      }
      c = e.call(r, t);
    } catch (l) {
      c = [6, l], s = 0;
    } finally {
      n = i = 0;
    }
    if (c[0] & 5) throw c[1];
    return { value: c[0] ? c[1] : void 0, done: true };
  }
};
Object.defineProperty(ua, "__esModule", { value: true });
ua.acceptNFTOffer = void 0;
var dm = Ke;
var hm = Xe;
var fm = Ge;
var pm = function(r) {
  return um(void 0, void 0, void 0, function() {
    var e, t, n, s, i, o, a;
    return lm(this, function(u) {
      switch (u.label) {
        case 0:
          e = {
            type: "reject",
            result: void 0
          }, u.label = 1;
        case 1:
          return u.trys.push([1, 3, , 4]), t = {
            app: dm.GEM_WALLET,
            type: "REQUEST_ACCEPT_NFT_OFFER/V3",
            payload: r
          }, [4, (0, fm.sendMessageToContentScript)(t)];
        case 2:
          if (n = u.sent(), s = n.result, i = n.error, o = i ? (0, hm.deserializeError)(i) : void 0, o)
            throw o;
          return s && (e.type = "response", e.result = s), [3, 4];
        case 3:
          throw a = u.sent(), a;
        case 4:
          return [2, e];
      }
    });
  });
};
ua.acceptNFTOffer = pm;
(function(r) {
  var e = B && B.__createBinding || (Object.create ? function(n, s, i, o) {
    o === void 0 && (o = i);
    var a = Object.getOwnPropertyDescriptor(s, i);
    (!a || ("get" in a ? !s.__esModule : a.writable || a.configurable)) && (a = { enumerable: true, get: function() {
      return s[i];
    } }), Object.defineProperty(n, o, a);
  } : function(n, s, i, o) {
    o === void 0 && (o = i), n[o] = s[i];
  }), t = B && B.__exportStar || function(n, s) {
    for (var i in n) i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && e(s, n, i);
  };
  Object.defineProperty(r, "__esModule", { value: true }), t(ua, r);
})(Lp);
var $p = {};
var fa = {};
var gm = B && B.__awaiter || function(r, e, t, n) {
  function s(i) {
    return i instanceof t ? i : new t(function(o) {
      o(i);
    });
  }
  return new (t || (t = Promise))(function(i, o) {
    function a(l) {
      try {
        c(n.next(l));
      } catch (d) {
        o(d);
      }
    }
    function u(l) {
      try {
        c(n.throw(l));
      } catch (d) {
        o(d);
      }
    }
    function c(l) {
      l.done ? i(l.value) : s(l.value).then(a, u);
    }
    c((n = n.apply(r, e || [])).next());
  });
};
var ym = B && B.__generator || function(r, e) {
  var t = { label: 0, sent: function() {
    if (i[0] & 1) throw i[1];
    return i[1];
  }, trys: [], ops: [] }, n, s, i, o;
  return o = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function a(c) {
    return function(l) {
      return u([c, l]);
    };
  }
  function u(c) {
    if (n) throw new TypeError("Generator is already executing.");
    for (; o && (o = 0, c[0] && (t = 0)), t; ) try {
      if (n = 1, s && (i = c[0] & 2 ? s.return : c[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, c[1])).done) return i;
      switch (s = 0, i && (c = [c[0] & 2, i.value]), c[0]) {
        case 0:
        case 1:
          i = c;
          break;
        case 4:
          return t.label++, { value: c[1], done: false };
        case 5:
          t.label++, s = c[1], c = [0];
          continue;
        case 7:
          c = t.ops.pop(), t.trys.pop();
          continue;
        default:
          if (i = t.trys, !(i = i.length > 0 && i[i.length - 1]) && (c[0] === 6 || c[0] === 2)) {
            t = 0;
            continue;
          }
          if (c[0] === 3 && (!i || c[1] > i[0] && c[1] < i[3])) {
            t.label = c[1];
            break;
          }
          if (c[0] === 6 && t.label < i[1]) {
            t.label = i[1], i = c;
            break;
          }
          if (i && t.label < i[2]) {
            t.label = i[2], t.ops.push(c);
            break;
          }
          i[2] && t.ops.pop(), t.trys.pop();
          continue;
      }
      c = e.call(r, t);
    } catch (l) {
      c = [6, l], s = 0;
    } finally {
      n = i = 0;
    }
    if (c[0] & 5) throw c[1];
    return { value: c[0] ? c[1] : void 0, done: true };
  }
};
Object.defineProperty(fa, "__esModule", { value: true });
fa.burnNFT = void 0;
var wm = Ke;
var mm = Xe;
var bm = Ge;
var vm = function(r) {
  return gm(void 0, void 0, void 0, function() {
    var e, t, n, s, i, o, a;
    return ym(this, function(u) {
      switch (u.label) {
        case 0:
          e = {
            type: "reject",
            result: void 0
          }, u.label = 1;
        case 1:
          return u.trys.push([1, 3, , 4]), t = {
            app: wm.GEM_WALLET,
            type: "REQUEST_BURN_NFT/V3",
            payload: r
          }, [4, (0, bm.sendMessageToContentScript)(t)];
        case 2:
          if (n = u.sent(), s = n.result, i = n.error, o = i ? (0, mm.deserializeError)(i) : void 0, o)
            throw o;
          return s && (e.type = "response", e.result = s), [3, 4];
        case 3:
          throw a = u.sent(), a;
        case 4:
          return [2, e];
      }
    });
  });
};
fa.burnNFT = vm;
(function(r) {
  var e = B && B.__createBinding || (Object.create ? function(n, s, i, o) {
    o === void 0 && (o = i);
    var a = Object.getOwnPropertyDescriptor(s, i);
    (!a || ("get" in a ? !s.__esModule : a.writable || a.configurable)) && (a = { enumerable: true, get: function() {
      return s[i];
    } }), Object.defineProperty(n, o, a);
  } : function(n, s, i, o) {
    o === void 0 && (o = i), n[o] = s[i];
  }), t = B && B.__exportStar || function(n, s) {
    for (var i in n) i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && e(s, n, i);
  };
  Object.defineProperty(r, "__esModule", { value: true }), t(fa, r);
})($p);
var Fp = {};
var pa = {};
var Mm = B && B.__awaiter || function(r, e, t, n) {
  function s(i) {
    return i instanceof t ? i : new t(function(o) {
      o(i);
    });
  }
  return new (t || (t = Promise))(function(i, o) {
    function a(l) {
      try {
        c(n.next(l));
      } catch (d) {
        o(d);
      }
    }
    function u(l) {
      try {
        c(n.throw(l));
      } catch (d) {
        o(d);
      }
    }
    function c(l) {
      l.done ? i(l.value) : s(l.value).then(a, u);
    }
    c((n = n.apply(r, e || [])).next());
  });
};
var Em = B && B.__generator || function(r, e) {
  var t = { label: 0, sent: function() {
    if (i[0] & 1) throw i[1];
    return i[1];
  }, trys: [], ops: [] }, n, s, i, o;
  return o = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function a(c) {
    return function(l) {
      return u([c, l]);
    };
  }
  function u(c) {
    if (n) throw new TypeError("Generator is already executing.");
    for (; o && (o = 0, c[0] && (t = 0)), t; ) try {
      if (n = 1, s && (i = c[0] & 2 ? s.return : c[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, c[1])).done) return i;
      switch (s = 0, i && (c = [c[0] & 2, i.value]), c[0]) {
        case 0:
        case 1:
          i = c;
          break;
        case 4:
          return t.label++, { value: c[1], done: false };
        case 5:
          t.label++, s = c[1], c = [0];
          continue;
        case 7:
          c = t.ops.pop(), t.trys.pop();
          continue;
        default:
          if (i = t.trys, !(i = i.length > 0 && i[i.length - 1]) && (c[0] === 6 || c[0] === 2)) {
            t = 0;
            continue;
          }
          if (c[0] === 3 && (!i || c[1] > i[0] && c[1] < i[3])) {
            t.label = c[1];
            break;
          }
          if (c[0] === 6 && t.label < i[1]) {
            t.label = i[1], i = c;
            break;
          }
          if (i && t.label < i[2]) {
            t.label = i[2], t.ops.push(c);
            break;
          }
          i[2] && t.ops.pop(), t.trys.pop();
          continue;
      }
      c = e.call(r, t);
    } catch (l) {
      c = [6, l], s = 0;
    } finally {
      n = i = 0;
    }
    if (c[0] & 5) throw c[1];
    return { value: c[0] ? c[1] : void 0, done: true };
  }
};
Object.defineProperty(pa, "__esModule", { value: true });
pa.cancelNFTOffer = void 0;
var Nm = Ke;
var xm = Xe;
var Im = Ge;
var _m = function(r) {
  return Mm(void 0, void 0, void 0, function() {
    var e, t, n, s, i, o, a;
    return Em(this, function(u) {
      switch (u.label) {
        case 0:
          e = {
            type: "reject",
            result: void 0
          }, u.label = 1;
        case 1:
          return u.trys.push([1, 3, , 4]), t = {
            app: Nm.GEM_WALLET,
            type: "REQUEST_CANCEL_NFT_OFFER/V3",
            payload: r
          }, [4, (0, Im.sendMessageToContentScript)(t)];
        case 2:
          if (n = u.sent(), s = n.result, i = n.error, o = i ? (0, xm.deserializeError)(i) : void 0, o)
            throw o;
          return s && (e.type = "response", e.result = s), [3, 4];
        case 3:
          throw a = u.sent(), a;
        case 4:
          return [2, e];
      }
    });
  });
};
pa.cancelNFTOffer = _m;
(function(r) {
  var e = B && B.__createBinding || (Object.create ? function(n, s, i, o) {
    o === void 0 && (o = i);
    var a = Object.getOwnPropertyDescriptor(s, i);
    (!a || ("get" in a ? !s.__esModule : a.writable || a.configurable)) && (a = { enumerable: true, get: function() {
      return s[i];
    } }), Object.defineProperty(n, o, a);
  } : function(n, s, i, o) {
    o === void 0 && (o = i), n[o] = s[i];
  }), t = B && B.__exportStar || function(n, s) {
    for (var i in n) i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && e(s, n, i);
  };
  Object.defineProperty(r, "__esModule", { value: true }), t(pa, r);
})(Fp);
var Qp = {};
var ga = {};
var Dm = B && B.__awaiter || function(r, e, t, n) {
  function s(i) {
    return i instanceof t ? i : new t(function(o) {
      o(i);
    });
  }
  return new (t || (t = Promise))(function(i, o) {
    function a(l) {
      try {
        c(n.next(l));
      } catch (d) {
        o(d);
      }
    }
    function u(l) {
      try {
        c(n.throw(l));
      } catch (d) {
        o(d);
      }
    }
    function c(l) {
      l.done ? i(l.value) : s(l.value).then(a, u);
    }
    c((n = n.apply(r, e || [])).next());
  });
};
var Tm = B && B.__generator || function(r, e) {
  var t = { label: 0, sent: function() {
    if (i[0] & 1) throw i[1];
    return i[1];
  }, trys: [], ops: [] }, n, s, i, o;
  return o = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function a(c) {
    return function(l) {
      return u([c, l]);
    };
  }
  function u(c) {
    if (n) throw new TypeError("Generator is already executing.");
    for (; o && (o = 0, c[0] && (t = 0)), t; ) try {
      if (n = 1, s && (i = c[0] & 2 ? s.return : c[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, c[1])).done) return i;
      switch (s = 0, i && (c = [c[0] & 2, i.value]), c[0]) {
        case 0:
        case 1:
          i = c;
          break;
        case 4:
          return t.label++, { value: c[1], done: false };
        case 5:
          t.label++, s = c[1], c = [0];
          continue;
        case 7:
          c = t.ops.pop(), t.trys.pop();
          continue;
        default:
          if (i = t.trys, !(i = i.length > 0 && i[i.length - 1]) && (c[0] === 6 || c[0] === 2)) {
            t = 0;
            continue;
          }
          if (c[0] === 3 && (!i || c[1] > i[0] && c[1] < i[3])) {
            t.label = c[1];
            break;
          }
          if (c[0] === 6 && t.label < i[1]) {
            t.label = i[1], i = c;
            break;
          }
          if (i && t.label < i[2]) {
            t.label = i[2], t.ops.push(c);
            break;
          }
          i[2] && t.ops.pop(), t.trys.pop();
          continue;
      }
      c = e.call(r, t);
    } catch (l) {
      c = [6, l], s = 0;
    } finally {
      n = i = 0;
    }
    if (c[0] & 5) throw c[1];
    return { value: c[0] ? c[1] : void 0, done: true };
  }
};
Object.defineProperty(ga, "__esModule", { value: true });
ga.cancelOffer = void 0;
var Am = Ke;
var Om = Xe;
var Sm = Ge;
var jm = function(r) {
  return Dm(void 0, void 0, void 0, function() {
    var e, t, n, s, i, o, a;
    return Tm(this, function(u) {
      switch (u.label) {
        case 0:
          e = {
            type: "reject",
            result: void 0
          }, u.label = 1;
        case 1:
          return u.trys.push([1, 3, , 4]), t = {
            app: Am.GEM_WALLET,
            type: "REQUEST_CANCEL_OFFER/V3",
            payload: r
          }, [4, (0, Sm.sendMessageToContentScript)(t)];
        case 2:
          if (n = u.sent(), s = n.result, i = n.error, o = i ? (0, Om.deserializeError)(i) : void 0, o)
            throw o;
          return s && (e.type = "response", e.result = s), [3, 4];
        case 3:
          throw a = u.sent(), a;
        case 4:
          return [2, e];
      }
    });
  });
};
ga.cancelOffer = jm;
(function(r) {
  var e = B && B.__createBinding || (Object.create ? function(n, s, i, o) {
    o === void 0 && (o = i);
    var a = Object.getOwnPropertyDescriptor(s, i);
    (!a || ("get" in a ? !s.__esModule : a.writable || a.configurable)) && (a = { enumerable: true, get: function() {
      return s[i];
    } }), Object.defineProperty(n, o, a);
  } : function(n, s, i, o) {
    o === void 0 && (o = i), n[o] = s[i];
  }), t = B && B.__exportStar || function(n, s) {
    for (var i in n) i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && e(s, n, i);
  };
  Object.defineProperty(r, "__esModule", { value: true }), t(ga, r);
})(Qp);
var qp = {};
var ya = {};
var Cm = B && B.__awaiter || function(r, e, t, n) {
  function s(i) {
    return i instanceof t ? i : new t(function(o) {
      o(i);
    });
  }
  return new (t || (t = Promise))(function(i, o) {
    function a(l) {
      try {
        c(n.next(l));
      } catch (d) {
        o(d);
      }
    }
    function u(l) {
      try {
        c(n.throw(l));
      } catch (d) {
        o(d);
      }
    }
    function c(l) {
      l.done ? i(l.value) : s(l.value).then(a, u);
    }
    c((n = n.apply(r, e || [])).next());
  });
};
var Lm = B && B.__generator || function(r, e) {
  var t = { label: 0, sent: function() {
    if (i[0] & 1) throw i[1];
    return i[1];
  }, trys: [], ops: [] }, n, s, i, o;
  return o = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function a(c) {
    return function(l) {
      return u([c, l]);
    };
  }
  function u(c) {
    if (n) throw new TypeError("Generator is already executing.");
    for (; o && (o = 0, c[0] && (t = 0)), t; ) try {
      if (n = 1, s && (i = c[0] & 2 ? s.return : c[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, c[1])).done) return i;
      switch (s = 0, i && (c = [c[0] & 2, i.value]), c[0]) {
        case 0:
        case 1:
          i = c;
          break;
        case 4:
          return t.label++, { value: c[1], done: false };
        case 5:
          t.label++, s = c[1], c = [0];
          continue;
        case 7:
          c = t.ops.pop(), t.trys.pop();
          continue;
        default:
          if (i = t.trys, !(i = i.length > 0 && i[i.length - 1]) && (c[0] === 6 || c[0] === 2)) {
            t = 0;
            continue;
          }
          if (c[0] === 3 && (!i || c[1] > i[0] && c[1] < i[3])) {
            t.label = c[1];
            break;
          }
          if (c[0] === 6 && t.label < i[1]) {
            t.label = i[1], i = c;
            break;
          }
          if (i && t.label < i[2]) {
            t.label = i[2], t.ops.push(c);
            break;
          }
          i[2] && t.ops.pop(), t.trys.pop();
          continue;
      }
      c = e.call(r, t);
    } catch (l) {
      c = [6, l], s = 0;
    } finally {
      n = i = 0;
    }
    if (c[0] & 5) throw c[1];
    return { value: c[0] ? c[1] : void 0, done: true };
  }
};
Object.defineProperty(ya, "__esModule", { value: true });
ya.createNFTOffer = void 0;
var zm = Ke;
var km = Xe;
var Um = Ge;
var Pm = function(r) {
  return Cm(void 0, void 0, void 0, function() {
    var e, t, n, s, i, o, a;
    return Lm(this, function(u) {
      switch (u.label) {
        case 0:
          e = {
            type: "reject",
            result: void 0
          }, u.label = 1;
        case 1:
          return u.trys.push([1, 3, , 4]), t = {
            app: zm.GEM_WALLET,
            type: "REQUEST_CREATE_NFT_OFFER/V3",
            payload: r
          }, [4, (0, Um.sendMessageToContentScript)(t)];
        case 2:
          if (n = u.sent(), s = n.result, i = n.error, o = i ? (0, km.deserializeError)(i) : void 0, o)
            throw o;
          return s && (e.type = "response", e.result = s), [3, 4];
        case 3:
          throw a = u.sent(), a;
        case 4:
          return [2, e];
      }
    });
  });
};
ya.createNFTOffer = Pm;
(function(r) {
  var e = B && B.__createBinding || (Object.create ? function(n, s, i, o) {
    o === void 0 && (o = i);
    var a = Object.getOwnPropertyDescriptor(s, i);
    (!a || ("get" in a ? !s.__esModule : a.writable || a.configurable)) && (a = { enumerable: true, get: function() {
      return s[i];
    } }), Object.defineProperty(n, o, a);
  } : function(n, s, i, o) {
    o === void 0 && (o = i), n[o] = s[i];
  }), t = B && B.__exportStar || function(n, s) {
    for (var i in n) i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && e(s, n, i);
  };
  Object.defineProperty(r, "__esModule", { value: true }), t(ya, r);
})(qp);
var Yp = {};
var wa = {};
var Bm = B && B.__awaiter || function(r, e, t, n) {
  function s(i) {
    return i instanceof t ? i : new t(function(o) {
      o(i);
    });
  }
  return new (t || (t = Promise))(function(i, o) {
    function a(l) {
      try {
        c(n.next(l));
      } catch (d) {
        o(d);
      }
    }
    function u(l) {
      try {
        c(n.throw(l));
      } catch (d) {
        o(d);
      }
    }
    function c(l) {
      l.done ? i(l.value) : s(l.value).then(a, u);
    }
    c((n = n.apply(r, e || [])).next());
  });
};
var Rm = B && B.__generator || function(r, e) {
  var t = { label: 0, sent: function() {
    if (i[0] & 1) throw i[1];
    return i[1];
  }, trys: [], ops: [] }, n, s, i, o;
  return o = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function a(c) {
    return function(l) {
      return u([c, l]);
    };
  }
  function u(c) {
    if (n) throw new TypeError("Generator is already executing.");
    for (; o && (o = 0, c[0] && (t = 0)), t; ) try {
      if (n = 1, s && (i = c[0] & 2 ? s.return : c[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, c[1])).done) return i;
      switch (s = 0, i && (c = [c[0] & 2, i.value]), c[0]) {
        case 0:
        case 1:
          i = c;
          break;
        case 4:
          return t.label++, { value: c[1], done: false };
        case 5:
          t.label++, s = c[1], c = [0];
          continue;
        case 7:
          c = t.ops.pop(), t.trys.pop();
          continue;
        default:
          if (i = t.trys, !(i = i.length > 0 && i[i.length - 1]) && (c[0] === 6 || c[0] === 2)) {
            t = 0;
            continue;
          }
          if (c[0] === 3 && (!i || c[1] > i[0] && c[1] < i[3])) {
            t.label = c[1];
            break;
          }
          if (c[0] === 6 && t.label < i[1]) {
            t.label = i[1], i = c;
            break;
          }
          if (i && t.label < i[2]) {
            t.label = i[2], t.ops.push(c);
            break;
          }
          i[2] && t.ops.pop(), t.trys.pop();
          continue;
      }
      c = e.call(r, t);
    } catch (l) {
      c = [6, l], s = 0;
    } finally {
      n = i = 0;
    }
    if (c[0] & 5) throw c[1];
    return { value: c[0] ? c[1] : void 0, done: true };
  }
};
Object.defineProperty(wa, "__esModule", { value: true });
wa.createOffer = void 0;
var $m = Ke;
var Fm = Xe;
var Qm = Ge;
var qm = function(r) {
  return Bm(void 0, void 0, void 0, function() {
    var e, t, n, s, i, o, a;
    return Rm(this, function(u) {
      switch (u.label) {
        case 0:
          e = {
            type: "reject",
            result: void 0
          }, u.label = 1;
        case 1:
          return u.trys.push([1, 3, , 4]), t = {
            app: $m.GEM_WALLET,
            type: "REQUEST_CREATE_OFFER/V3",
            payload: r
          }, [4, (0, Qm.sendMessageToContentScript)(t)];
        case 2:
          if (n = u.sent(), s = n.result, i = n.error, o = i ? (0, Fm.deserializeError)(i) : void 0, o)
            throw o;
          return s && (e.type = "response", e.result = s), [3, 4];
        case 3:
          throw a = u.sent(), a;
        case 4:
          return [2, e];
      }
    });
  });
};
wa.createOffer = qm;
(function(r) {
  var e = B && B.__createBinding || (Object.create ? function(n, s, i, o) {
    o === void 0 && (o = i);
    var a = Object.getOwnPropertyDescriptor(s, i);
    (!a || ("get" in a ? !s.__esModule : a.writable || a.configurable)) && (a = { enumerable: true, get: function() {
      return s[i];
    } }), Object.defineProperty(n, o, a);
  } : function(n, s, i, o) {
    o === void 0 && (o = i), n[o] = s[i];
  }), t = B && B.__exportStar || function(n, s) {
    for (var i in n) i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && e(s, n, i);
  };
  Object.defineProperty(r, "__esModule", { value: true }), t(wa, r);
})(Yp);
var Vp = {};
var ma = {};
Object.defineProperty(ma, "__esModule", { value: true });
ma.on = void 0;
var Ym = Ke;
var Vm = function(r, e) {
  window.addEventListener("message", function(t) {
    t.origin === window.origin && (t.source !== window && t.data.app === Ym.GEM_WALLET || !t.data.source || t.data.source !== "GEM_WALLET_MSG_REQUEST" || t.data.type && t.data.type === r && e(t.data.payload.result));
  });
};
ma.on = Vm;
(function(r) {
  var e = B && B.__createBinding || (Object.create ? function(n, s, i, o) {
    o === void 0 && (o = i);
    var a = Object.getOwnPropertyDescriptor(s, i);
    (!a || ("get" in a ? !s.__esModule : a.writable || a.configurable)) && (a = { enumerable: true, get: function() {
      return s[i];
    } }), Object.defineProperty(n, o, a);
  } : function(n, s, i, o) {
    o === void 0 && (o = i), n[o] = s[i];
  }), t = B && B.__exportStar || function(n, s) {
    for (var i in n) i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && e(s, n, i);
  };
  Object.defineProperty(r, "__esModule", { value: true }), t(ma, r);
})(Vp);
var Hp = {};
var ba = {};
var ai = {};
Object.defineProperty(ai, "__esModule", { value: true });
ai.getFavicon = void 0;
var Hm = function() {
  var r, e = (r = document.querySelector("link[rel*='icon']")) === null || r === void 0 ? void 0 : r.getAttribute("href");
  if (e)
    try {
      new URL(e);
    } catch {
      e = window.location.origin + e;
    }
  return e;
};
ai.getFavicon = Hm;
var Gm = B && B.__awaiter || function(r, e, t, n) {
  function s(i) {
    return i instanceof t ? i : new t(function(o) {
      o(i);
    });
  }
  return new (t || (t = Promise))(function(i, o) {
    function a(l) {
      try {
        c(n.next(l));
      } catch (d) {
        o(d);
      }
    }
    function u(l) {
      try {
        c(n.throw(l));
      } catch (d) {
        o(d);
      }
    }
    function c(l) {
      l.done ? i(l.value) : s(l.value).then(a, u);
    }
    c((n = n.apply(r, e || [])).next());
  });
};
var Wm = B && B.__generator || function(r, e) {
  var t = { label: 0, sent: function() {
    if (i[0] & 1) throw i[1];
    return i[1];
  }, trys: [], ops: [] }, n, s, i, o;
  return o = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function a(c) {
    return function(l) {
      return u([c, l]);
    };
  }
  function u(c) {
    if (n) throw new TypeError("Generator is already executing.");
    for (; o && (o = 0, c[0] && (t = 0)), t; ) try {
      if (n = 1, s && (i = c[0] & 2 ? s.return : c[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, c[1])).done) return i;
      switch (s = 0, i && (c = [c[0] & 2, i.value]), c[0]) {
        case 0:
        case 1:
          i = c;
          break;
        case 4:
          return t.label++, { value: c[1], done: false };
        case 5:
          t.label++, s = c[1], c = [0];
          continue;
        case 7:
          c = t.ops.pop(), t.trys.pop();
          continue;
        default:
          if (i = t.trys, !(i = i.length > 0 && i[i.length - 1]) && (c[0] === 6 || c[0] === 2)) {
            t = 0;
            continue;
          }
          if (c[0] === 3 && (!i || c[1] > i[0] && c[1] < i[3])) {
            t.label = c[1];
            break;
          }
          if (c[0] === 6 && t.label < i[1]) {
            t.label = i[1], i = c;
            break;
          }
          if (i && t.label < i[2]) {
            t.label = i[2], t.ops.push(c);
            break;
          }
          i[2] && t.ops.pop(), t.trys.pop();
          continue;
      }
      c = e.call(r, t);
    } catch (l) {
      c = [6, l], s = 0;
    } finally {
      n = i = 0;
    }
    if (c[0] & 5) throw c[1];
    return { value: c[0] ? c[1] : void 0, done: true };
  }
};
Object.defineProperty(ba, "__esModule", { value: true });
ba.getAddress = void 0;
var Km = Ke;
var Xm = Xe;
var Zm = Ge;
var Jm = ai;
var eb = function() {
  return Gm(void 0, void 0, void 0, function() {
    var r, e, t, n, s, i, o, a;
    return Wm(this, function(u) {
      switch (u.label) {
        case 0:
          r = {
            type: "reject",
            result: void 0
          }, u.label = 1;
        case 1:
          return u.trys.push([1, 3, , 4]), e = (0, Jm.getFavicon)(), t = {
            app: Km.GEM_WALLET,
            type: "REQUEST_GET_ADDRESS/V3",
            payload: {
              url: window.location.origin,
              title: document.title,
              favicon: e
            }
          }, [4, (0, Zm.sendMessageToContentScript)(t)];
        case 2:
          if (n = u.sent(), s = n.result, i = n.error, o = i ? (0, Xm.deserializeError)(i) : void 0, o)
            throw o;
          return s && (r.type = "response", r.result = s), [3, 4];
        case 3:
          throw a = u.sent(), a;
        case 4:
          return [2, r];
      }
    });
  });
};
ba.getAddress = eb;
(function(r) {
  var e = B && B.__createBinding || (Object.create ? function(n, s, i, o) {
    o === void 0 && (o = i);
    var a = Object.getOwnPropertyDescriptor(s, i);
    (!a || ("get" in a ? !s.__esModule : a.writable || a.configurable)) && (a = { enumerable: true, get: function() {
      return s[i];
    } }), Object.defineProperty(n, o, a);
  } : function(n, s, i, o) {
    o === void 0 && (o = i), n[o] = s[i];
  }), t = B && B.__exportStar || function(n, s) {
    for (var i in n) i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && e(s, n, i);
  };
  Object.defineProperty(r, "__esModule", { value: true }), t(ba, r);
})(Hp);
var Gp = {};
var va = {};
var tb = B && B.__awaiter || function(r, e, t, n) {
  function s(i) {
    return i instanceof t ? i : new t(function(o) {
      o(i);
    });
  }
  return new (t || (t = Promise))(function(i, o) {
    function a(l) {
      try {
        c(n.next(l));
      } catch (d) {
        o(d);
      }
    }
    function u(l) {
      try {
        c(n.throw(l));
      } catch (d) {
        o(d);
      }
    }
    function c(l) {
      l.done ? i(l.value) : s(l.value).then(a, u);
    }
    c((n = n.apply(r, e || [])).next());
  });
};
var rb = B && B.__generator || function(r, e) {
  var t = { label: 0, sent: function() {
    if (i[0] & 1) throw i[1];
    return i[1];
  }, trys: [], ops: [] }, n, s, i, o;
  return o = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function a(c) {
    return function(l) {
      return u([c, l]);
    };
  }
  function u(c) {
    if (n) throw new TypeError("Generator is already executing.");
    for (; o && (o = 0, c[0] && (t = 0)), t; ) try {
      if (n = 1, s && (i = c[0] & 2 ? s.return : c[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, c[1])).done) return i;
      switch (s = 0, i && (c = [c[0] & 2, i.value]), c[0]) {
        case 0:
        case 1:
          i = c;
          break;
        case 4:
          return t.label++, { value: c[1], done: false };
        case 5:
          t.label++, s = c[1], c = [0];
          continue;
        case 7:
          c = t.ops.pop(), t.trys.pop();
          continue;
        default:
          if (i = t.trys, !(i = i.length > 0 && i[i.length - 1]) && (c[0] === 6 || c[0] === 2)) {
            t = 0;
            continue;
          }
          if (c[0] === 3 && (!i || c[1] > i[0] && c[1] < i[3])) {
            t.label = c[1];
            break;
          }
          if (c[0] === 6 && t.label < i[1]) {
            t.label = i[1], i = c;
            break;
          }
          if (i && t.label < i[2]) {
            t.label = i[2], t.ops.push(c);
            break;
          }
          i[2] && t.ops.pop(), t.trys.pop();
          continue;
      }
      c = e.call(r, t);
    } catch (l) {
      c = [6, l], s = 0;
    } finally {
      n = i = 0;
    }
    if (c[0] & 5) throw c[1];
    return { value: c[0] ? c[1] : void 0, done: true };
  }
};
Object.defineProperty(va, "__esModule", { value: true });
va.getNetwork = void 0;
var nb = Ke;
var ib = Xe;
var sb = Ge;
var ob = function() {
  return tb(void 0, void 0, void 0, function() {
    var r, e, t, n, s, i, o;
    return rb(this, function(a) {
      switch (a.label) {
        case 0:
          r = {
            type: "reject",
            result: void 0
          }, a.label = 1;
        case 1:
          return a.trys.push([1, 3, , 4]), e = {
            app: nb.GEM_WALLET,
            type: "REQUEST_GET_NETWORK/V3"
          }, [4, (0, sb.sendMessageToContentScript)(e)];
        case 2:
          if (t = a.sent(), n = t.result, s = t.error, i = s ? (0, ib.deserializeError)(s) : void 0, i)
            throw i;
          return n && (r.type = "response", r.result = n), [3, 4];
        case 3:
          throw o = a.sent(), o;
        case 4:
          return [2, r];
      }
    });
  });
};
va.getNetwork = ob;
(function(r) {
  var e = B && B.__createBinding || (Object.create ? function(n, s, i, o) {
    o === void 0 && (o = i);
    var a = Object.getOwnPropertyDescriptor(s, i);
    (!a || ("get" in a ? !s.__esModule : a.writable || a.configurable)) && (a = { enumerable: true, get: function() {
      return s[i];
    } }), Object.defineProperty(n, o, a);
  } : function(n, s, i, o) {
    o === void 0 && (o = i), n[o] = s[i];
  }), t = B && B.__exportStar || function(n, s) {
    for (var i in n) i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && e(s, n, i);
  };
  Object.defineProperty(r, "__esModule", { value: true }), t(va, r);
})(Gp);
var Wp = {};
var Ma = {};
var ab = B && B.__awaiter || function(r, e, t, n) {
  function s(i) {
    return i instanceof t ? i : new t(function(o) {
      o(i);
    });
  }
  return new (t || (t = Promise))(function(i, o) {
    function a(l) {
      try {
        c(n.next(l));
      } catch (d) {
        o(d);
      }
    }
    function u(l) {
      try {
        c(n.throw(l));
      } catch (d) {
        o(d);
      }
    }
    function c(l) {
      l.done ? i(l.value) : s(l.value).then(a, u);
    }
    c((n = n.apply(r, e || [])).next());
  });
};
var cb = B && B.__generator || function(r, e) {
  var t = { label: 0, sent: function() {
    if (i[0] & 1) throw i[1];
    return i[1];
  }, trys: [], ops: [] }, n, s, i, o;
  return o = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function a(c) {
    return function(l) {
      return u([c, l]);
    };
  }
  function u(c) {
    if (n) throw new TypeError("Generator is already executing.");
    for (; o && (o = 0, c[0] && (t = 0)), t; ) try {
      if (n = 1, s && (i = c[0] & 2 ? s.return : c[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, c[1])).done) return i;
      switch (s = 0, i && (c = [c[0] & 2, i.value]), c[0]) {
        case 0:
        case 1:
          i = c;
          break;
        case 4:
          return t.label++, { value: c[1], done: false };
        case 5:
          t.label++, s = c[1], c = [0];
          continue;
        case 7:
          c = t.ops.pop(), t.trys.pop();
          continue;
        default:
          if (i = t.trys, !(i = i.length > 0 && i[i.length - 1]) && (c[0] === 6 || c[0] === 2)) {
            t = 0;
            continue;
          }
          if (c[0] === 3 && (!i || c[1] > i[0] && c[1] < i[3])) {
            t.label = c[1];
            break;
          }
          if (c[0] === 6 && t.label < i[1]) {
            t.label = i[1], i = c;
            break;
          }
          if (i && t.label < i[2]) {
            t.label = i[2], t.ops.push(c);
            break;
          }
          i[2] && t.ops.pop(), t.trys.pop();
          continue;
      }
      c = e.call(r, t);
    } catch (l) {
      c = [6, l], s = 0;
    } finally {
      n = i = 0;
    }
    if (c[0] & 5) throw c[1];
    return { value: c[0] ? c[1] : void 0, done: true };
  }
};
Object.defineProperty(Ma, "__esModule", { value: true });
Ma.getNFT = void 0;
var ub = Ke;
var lb = Xe;
var db = Ge;
var hb = ai;
var fb = function(r) {
  return ab(void 0, void 0, void 0, function() {
    var e, t, n, s, i, o, a, u, c, l;
    return cb(this, function(d) {
      switch (d.label) {
        case 0:
          e = {
            type: "reject",
            result: void 0
          }, d.label = 1;
        case 1:
          return d.trys.push([1, 3, , 4]), t = (0, hb.getFavicon)(), n = {
            app: ub.GEM_WALLET,
            type: "REQUEST_GET_NFT/V3",
            payload: {
              url: window.location.origin,
              title: document.title,
              favicon: t,
              limit: (c = r == null ? void 0 : r.limit) !== null && c !== void 0 ? c : void 0,
              // Value from a previous paginated response. Resume retrieving data where that response left off.
              marker: (l = r == null ? void 0 : r.marker) !== null && l !== void 0 ? l : void 0
            }
          }, [4, (0, db.sendMessageToContentScript)(n)];
        case 2:
          if (s = d.sent(), i = s.result, o = s.error, a = o ? (0, lb.deserializeError)(o) : void 0, a)
            throw a;
          return i && (e.type = "response", e.result = i), [3, 4];
        case 3:
          throw u = d.sent(), u;
        case 4:
          return [2, e];
      }
    });
  });
};
Ma.getNFT = fb;
(function(r) {
  var e = B && B.__createBinding || (Object.create ? function(n, s, i, o) {
    o === void 0 && (o = i);
    var a = Object.getOwnPropertyDescriptor(s, i);
    (!a || ("get" in a ? !s.__esModule : a.writable || a.configurable)) && (a = { enumerable: true, get: function() {
      return s[i];
    } }), Object.defineProperty(n, o, a);
  } : function(n, s, i, o) {
    o === void 0 && (o = i), n[o] = s[i];
  }), t = B && B.__exportStar || function(n, s) {
    for (var i in n) i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && e(s, n, i);
  };
  Object.defineProperty(r, "__esModule", { value: true }), t(Ma, r);
})(Wp);
var Kp = {};
var Ea = {};
var pb = B && B.__awaiter || function(r, e, t, n) {
  function s(i) {
    return i instanceof t ? i : new t(function(o) {
      o(i);
    });
  }
  return new (t || (t = Promise))(function(i, o) {
    function a(l) {
      try {
        c(n.next(l));
      } catch (d) {
        o(d);
      }
    }
    function u(l) {
      try {
        c(n.throw(l));
      } catch (d) {
        o(d);
      }
    }
    function c(l) {
      l.done ? i(l.value) : s(l.value).then(a, u);
    }
    c((n = n.apply(r, e || [])).next());
  });
};
var gb = B && B.__generator || function(r, e) {
  var t = { label: 0, sent: function() {
    if (i[0] & 1) throw i[1];
    return i[1];
  }, trys: [], ops: [] }, n, s, i, o;
  return o = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function a(c) {
    return function(l) {
      return u([c, l]);
    };
  }
  function u(c) {
    if (n) throw new TypeError("Generator is already executing.");
    for (; o && (o = 0, c[0] && (t = 0)), t; ) try {
      if (n = 1, s && (i = c[0] & 2 ? s.return : c[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, c[1])).done) return i;
      switch (s = 0, i && (c = [c[0] & 2, i.value]), c[0]) {
        case 0:
        case 1:
          i = c;
          break;
        case 4:
          return t.label++, { value: c[1], done: false };
        case 5:
          t.label++, s = c[1], c = [0];
          continue;
        case 7:
          c = t.ops.pop(), t.trys.pop();
          continue;
        default:
          if (i = t.trys, !(i = i.length > 0 && i[i.length - 1]) && (c[0] === 6 || c[0] === 2)) {
            t = 0;
            continue;
          }
          if (c[0] === 3 && (!i || c[1] > i[0] && c[1] < i[3])) {
            t.label = c[1];
            break;
          }
          if (c[0] === 6 && t.label < i[1]) {
            t.label = i[1], i = c;
            break;
          }
          if (i && t.label < i[2]) {
            t.label = i[2], t.ops.push(c);
            break;
          }
          i[2] && t.ops.pop(), t.trys.pop();
          continue;
      }
      c = e.call(r, t);
    } catch (l) {
      c = [6, l], s = 0;
    } finally {
      n = i = 0;
    }
    if (c[0] & 5) throw c[1];
    return { value: c[0] ? c[1] : void 0, done: true };
  }
};
Object.defineProperty(Ea, "__esModule", { value: true });
Ea.getPublicKey = void 0;
var yb = Ke;
var wb = Xe;
var mb = Ge;
var bb = ai;
var vb = function() {
  return pb(void 0, void 0, void 0, function() {
    var r, e, t, n, s, i, o, a;
    return gb(this, function(u) {
      switch (u.label) {
        case 0:
          r = {
            type: "reject",
            result: void 0
          }, u.label = 1;
        case 1:
          return u.trys.push([1, 3, , 4]), e = (0, bb.getFavicon)(), t = {
            app: yb.GEM_WALLET,
            type: "REQUEST_GET_PUBLIC_KEY/V3",
            payload: {
              url: window.location.origin,
              title: document.title,
              favicon: e
            }
          }, [4, (0, mb.sendMessageToContentScript)(t)];
        case 2:
          if (n = u.sent(), s = n.result, i = n.error, o = i ? (0, wb.deserializeError)(i) : void 0, o)
            throw o;
          return s && (r.type = "response", r.result = s), [3, 4];
        case 3:
          throw a = u.sent(), a;
        case 4:
          return [2, r];
      }
    });
  });
};
Ea.getPublicKey = vb;
(function(r) {
  var e = B && B.__createBinding || (Object.create ? function(n, s, i, o) {
    o === void 0 && (o = i);
    var a = Object.getOwnPropertyDescriptor(s, i);
    (!a || ("get" in a ? !s.__esModule : a.writable || a.configurable)) && (a = { enumerable: true, get: function() {
      return s[i];
    } }), Object.defineProperty(n, o, a);
  } : function(n, s, i, o) {
    o === void 0 && (o = i), n[o] = s[i];
  }), t = B && B.__exportStar || function(n, s) {
    for (var i in n) i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && e(s, n, i);
  };
  Object.defineProperty(r, "__esModule", { value: true }), t(Ea, r);
})(Kp);
var Xp = {};
var Na = {};
var Mb = B && B.__awaiter || function(r, e, t, n) {
  function s(i) {
    return i instanceof t ? i : new t(function(o) {
      o(i);
    });
  }
  return new (t || (t = Promise))(function(i, o) {
    function a(l) {
      try {
        c(n.next(l));
      } catch (d) {
        o(d);
      }
    }
    function u(l) {
      try {
        c(n.throw(l));
      } catch (d) {
        o(d);
      }
    }
    function c(l) {
      l.done ? i(l.value) : s(l.value).then(a, u);
    }
    c((n = n.apply(r, e || [])).next());
  });
};
var Eb = B && B.__generator || function(r, e) {
  var t = { label: 0, sent: function() {
    if (i[0] & 1) throw i[1];
    return i[1];
  }, trys: [], ops: [] }, n, s, i, o;
  return o = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function a(c) {
    return function(l) {
      return u([c, l]);
    };
  }
  function u(c) {
    if (n) throw new TypeError("Generator is already executing.");
    for (; o && (o = 0, c[0] && (t = 0)), t; ) try {
      if (n = 1, s && (i = c[0] & 2 ? s.return : c[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, c[1])).done) return i;
      switch (s = 0, i && (c = [c[0] & 2, i.value]), c[0]) {
        case 0:
        case 1:
          i = c;
          break;
        case 4:
          return t.label++, { value: c[1], done: false };
        case 5:
          t.label++, s = c[1], c = [0];
          continue;
        case 7:
          c = t.ops.pop(), t.trys.pop();
          continue;
        default:
          if (i = t.trys, !(i = i.length > 0 && i[i.length - 1]) && (c[0] === 6 || c[0] === 2)) {
            t = 0;
            continue;
          }
          if (c[0] === 3 && (!i || c[1] > i[0] && c[1] < i[3])) {
            t.label = c[1];
            break;
          }
          if (c[0] === 6 && t.label < i[1]) {
            t.label = i[1], i = c;
            break;
          }
          if (i && t.label < i[2]) {
            t.label = i[2], t.ops.push(c);
            break;
          }
          i[2] && t.ops.pop(), t.trys.pop();
          continue;
      }
      c = e.call(r, t);
    } catch (l) {
      c = [6, l], s = 0;
    } finally {
      n = i = 0;
    }
    if (c[0] & 5) throw c[1];
    return { value: c[0] ? c[1] : void 0, done: true };
  }
};
Object.defineProperty(Na, "__esModule", { value: true });
Na.isInstalled = void 0;
var Nb = Ke;
var xb = Ge;
var Ib = function() {
  if (window.gemWallet)
    return Promise.resolve({ result: { isInstalled: true } });
  var r, e = new Promise(function(n) {
    r = setTimeout(function() {
      n({ result: { isInstalled: false } });
    }, 1e3);
  }), t = new Promise(function(n) {
    return Mb(void 0, void 0, void 0, function() {
      var s, i;
      return Eb(this, function(o) {
        switch (o.label) {
          case 0:
            return o.trys.push([0, 2, , 3]), s = {
              app: Nb.GEM_WALLET,
              type: "REQUEST_IS_INSTALLED/V3"
            }, [4, (0, xb.sendMessageToContentScript)(s)];
          case 1:
            return i = o.sent(), n({ result: { isInstalled: i.isInstalled || false } }), [3, 3];
          case 2:
            return o.sent(), n({ result: { isInstalled: false } }), [3, 3];
          case 3:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  });
  return Promise.race([e, t]).then(function(n) {
    return clearTimeout(r), n.result.isInstalled === true && (window.gemWallet = true), { result: { isInstalled: n.result.isInstalled } };
  }).catch(function() {
    return { result: { isInstalled: false } };
  });
};
Na.isInstalled = Ib;
(function(r) {
  var e = B && B.__createBinding || (Object.create ? function(n, s, i, o) {
    o === void 0 && (o = i);
    var a = Object.getOwnPropertyDescriptor(s, i);
    (!a || ("get" in a ? !s.__esModule : a.writable || a.configurable)) && (a = { enumerable: true, get: function() {
      return s[i];
    } }), Object.defineProperty(n, o, a);
  } : function(n, s, i, o) {
    o === void 0 && (o = i), n[o] = s[i];
  }), t = B && B.__exportStar || function(n, s) {
    for (var i in n) i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && e(s, n, i);
  };
  Object.defineProperty(r, "__esModule", { value: true }), t(Na, r);
})(Xp);
var Zp = {};
var xa = {};
var _b = B && B.__awaiter || function(r, e, t, n) {
  function s(i) {
    return i instanceof t ? i : new t(function(o) {
      o(i);
    });
  }
  return new (t || (t = Promise))(function(i, o) {
    function a(l) {
      try {
        c(n.next(l));
      } catch (d) {
        o(d);
      }
    }
    function u(l) {
      try {
        c(n.throw(l));
      } catch (d) {
        o(d);
      }
    }
    function c(l) {
      l.done ? i(l.value) : s(l.value).then(a, u);
    }
    c((n = n.apply(r, e || [])).next());
  });
};
var Db = B && B.__generator || function(r, e) {
  var t = { label: 0, sent: function() {
    if (i[0] & 1) throw i[1];
    return i[1];
  }, trys: [], ops: [] }, n, s, i, o;
  return o = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function a(c) {
    return function(l) {
      return u([c, l]);
    };
  }
  function u(c) {
    if (n) throw new TypeError("Generator is already executing.");
    for (; o && (o = 0, c[0] && (t = 0)), t; ) try {
      if (n = 1, s && (i = c[0] & 2 ? s.return : c[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, c[1])).done) return i;
      switch (s = 0, i && (c = [c[0] & 2, i.value]), c[0]) {
        case 0:
        case 1:
          i = c;
          break;
        case 4:
          return t.label++, { value: c[1], done: false };
        case 5:
          t.label++, s = c[1], c = [0];
          continue;
        case 7:
          c = t.ops.pop(), t.trys.pop();
          continue;
        default:
          if (i = t.trys, !(i = i.length > 0 && i[i.length - 1]) && (c[0] === 6 || c[0] === 2)) {
            t = 0;
            continue;
          }
          if (c[0] === 3 && (!i || c[1] > i[0] && c[1] < i[3])) {
            t.label = c[1];
            break;
          }
          if (c[0] === 6 && t.label < i[1]) {
            t.label = i[1], i = c;
            break;
          }
          if (i && t.label < i[2]) {
            t.label = i[2], t.ops.push(c);
            break;
          }
          i[2] && t.ops.pop(), t.trys.pop();
          continue;
      }
      c = e.call(r, t);
    } catch (l) {
      c = [6, l], s = 0;
    } finally {
      n = i = 0;
    }
    if (c[0] & 5) throw c[1];
    return { value: c[0] ? c[1] : void 0, done: true };
  }
};
Object.defineProperty(xa, "__esModule", { value: true });
xa.mintNFT = void 0;
var Tb = Ke;
var Ab = Xe;
var Ob = Ge;
var Sb = function(r) {
  return _b(void 0, void 0, void 0, function() {
    var e, t, n, s, i, o, a;
    return Db(this, function(u) {
      switch (u.label) {
        case 0:
          e = {
            type: "reject",
            result: void 0
          }, u.label = 1;
        case 1:
          return u.trys.push([1, 3, , 4]), t = {
            app: Tb.GEM_WALLET,
            type: "REQUEST_MINT_NFT/V3",
            payload: r
          }, [4, (0, Ob.sendMessageToContentScript)(t)];
        case 2:
          if (n = u.sent(), s = n.result, i = n.error, o = i ? (0, Ab.deserializeError)(i) : void 0, o)
            throw o;
          return s && (e.type = "response", e.result = s), [3, 4];
        case 3:
          throw a = u.sent(), a;
        case 4:
          return [2, e];
      }
    });
  });
};
xa.mintNFT = Sb;
(function(r) {
  var e = B && B.__createBinding || (Object.create ? function(n, s, i, o) {
    o === void 0 && (o = i);
    var a = Object.getOwnPropertyDescriptor(s, i);
    (!a || ("get" in a ? !s.__esModule : a.writable || a.configurable)) && (a = { enumerable: true, get: function() {
      return s[i];
    } }), Object.defineProperty(n, o, a);
  } : function(n, s, i, o) {
    o === void 0 && (o = i), n[o] = s[i];
  }), t = B && B.__exportStar || function(n, s) {
    for (var i in n) i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && e(s, n, i);
  };
  Object.defineProperty(r, "__esModule", { value: true }), t(xa, r);
})(Zp);
var Jp = {};
var Ia = {};
var jb = B && B.__awaiter || function(r, e, t, n) {
  function s(i) {
    return i instanceof t ? i : new t(function(o) {
      o(i);
    });
  }
  return new (t || (t = Promise))(function(i, o) {
    function a(l) {
      try {
        c(n.next(l));
      } catch (d) {
        o(d);
      }
    }
    function u(l) {
      try {
        c(n.throw(l));
      } catch (d) {
        o(d);
      }
    }
    function c(l) {
      l.done ? i(l.value) : s(l.value).then(a, u);
    }
    c((n = n.apply(r, e || [])).next());
  });
};
var Cb = B && B.__generator || function(r, e) {
  var t = { label: 0, sent: function() {
    if (i[0] & 1) throw i[1];
    return i[1];
  }, trys: [], ops: [] }, n, s, i, o;
  return o = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function a(c) {
    return function(l) {
      return u([c, l]);
    };
  }
  function u(c) {
    if (n) throw new TypeError("Generator is already executing.");
    for (; o && (o = 0, c[0] && (t = 0)), t; ) try {
      if (n = 1, s && (i = c[0] & 2 ? s.return : c[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, c[1])).done) return i;
      switch (s = 0, i && (c = [c[0] & 2, i.value]), c[0]) {
        case 0:
        case 1:
          i = c;
          break;
        case 4:
          return t.label++, { value: c[1], done: false };
        case 5:
          t.label++, s = c[1], c = [0];
          continue;
        case 7:
          c = t.ops.pop(), t.trys.pop();
          continue;
        default:
          if (i = t.trys, !(i = i.length > 0 && i[i.length - 1]) && (c[0] === 6 || c[0] === 2)) {
            t = 0;
            continue;
          }
          if (c[0] === 3 && (!i || c[1] > i[0] && c[1] < i[3])) {
            t.label = c[1];
            break;
          }
          if (c[0] === 6 && t.label < i[1]) {
            t.label = i[1], i = c;
            break;
          }
          if (i && t.label < i[2]) {
            t.label = i[2], t.ops.push(c);
            break;
          }
          i[2] && t.ops.pop(), t.trys.pop();
          continue;
      }
      c = e.call(r, t);
    } catch (l) {
      c = [6, l], s = 0;
    } finally {
      n = i = 0;
    }
    if (c[0] & 5) throw c[1];
    return { value: c[0] ? c[1] : void 0, done: true };
  }
};
Object.defineProperty(Ia, "__esModule", { value: true });
Ia.sendPayment = void 0;
var Lb = Ke;
var zb = Xe;
var kb = Ge;
var Ub = function(r) {
  return jb(void 0, void 0, void 0, function() {
    var e, t, n, s, i, o, a;
    return Cb(this, function(u) {
      switch (u.label) {
        case 0:
          e = {
            type: "reject",
            result: void 0
          }, u.label = 1;
        case 1:
          return u.trys.push([1, 3, , 4]), t = {
            app: Lb.GEM_WALLET,
            type: "REQUEST_SEND_PAYMENT/V3",
            payload: r
          }, [4, (0, kb.sendMessageToContentScript)(t)];
        case 2:
          if (n = u.sent(), s = n.result, i = n.error, o = i ? (0, zb.deserializeError)(i) : void 0, o)
            throw o;
          return s && (e.type = "response", e.result = s), [3, 4];
        case 3:
          throw a = u.sent(), a;
        case 4:
          return [2, e];
      }
    });
  });
};
Ia.sendPayment = Ub;
(function(r) {
  var e = B && B.__createBinding || (Object.create ? function(n, s, i, o) {
    o === void 0 && (o = i);
    var a = Object.getOwnPropertyDescriptor(s, i);
    (!a || ("get" in a ? !s.__esModule : a.writable || a.configurable)) && (a = { enumerable: true, get: function() {
      return s[i];
    } }), Object.defineProperty(n, o, a);
  } : function(n, s, i, o) {
    o === void 0 && (o = i), n[o] = s[i];
  }), t = B && B.__exportStar || function(n, s) {
    for (var i in n) i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && e(s, n, i);
  };
  Object.defineProperty(r, "__esModule", { value: true }), t(Ia, r);
})(Jp);
var eg = {};
var _a = {};
var Pb = B && B.__awaiter || function(r, e, t, n) {
  function s(i) {
    return i instanceof t ? i : new t(function(o) {
      o(i);
    });
  }
  return new (t || (t = Promise))(function(i, o) {
    function a(l) {
      try {
        c(n.next(l));
      } catch (d) {
        o(d);
      }
    }
    function u(l) {
      try {
        c(n.throw(l));
      } catch (d) {
        o(d);
      }
    }
    function c(l) {
      l.done ? i(l.value) : s(l.value).then(a, u);
    }
    c((n = n.apply(r, e || [])).next());
  });
};
var Bb = B && B.__generator || function(r, e) {
  var t = { label: 0, sent: function() {
    if (i[0] & 1) throw i[1];
    return i[1];
  }, trys: [], ops: [] }, n, s, i, o;
  return o = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function a(c) {
    return function(l) {
      return u([c, l]);
    };
  }
  function u(c) {
    if (n) throw new TypeError("Generator is already executing.");
    for (; o && (o = 0, c[0] && (t = 0)), t; ) try {
      if (n = 1, s && (i = c[0] & 2 ? s.return : c[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, c[1])).done) return i;
      switch (s = 0, i && (c = [c[0] & 2, i.value]), c[0]) {
        case 0:
        case 1:
          i = c;
          break;
        case 4:
          return t.label++, { value: c[1], done: false };
        case 5:
          t.label++, s = c[1], c = [0];
          continue;
        case 7:
          c = t.ops.pop(), t.trys.pop();
          continue;
        default:
          if (i = t.trys, !(i = i.length > 0 && i[i.length - 1]) && (c[0] === 6 || c[0] === 2)) {
            t = 0;
            continue;
          }
          if (c[0] === 3 && (!i || c[1] > i[0] && c[1] < i[3])) {
            t.label = c[1];
            break;
          }
          if (c[0] === 6 && t.label < i[1]) {
            t.label = i[1], i = c;
            break;
          }
          if (i && t.label < i[2]) {
            t.label = i[2], t.ops.push(c);
            break;
          }
          i[2] && t.ops.pop(), t.trys.pop();
          continue;
      }
      c = e.call(r, t);
    } catch (l) {
      c = [6, l], s = 0;
    } finally {
      n = i = 0;
    }
    if (c[0] & 5) throw c[1];
    return { value: c[0] ? c[1] : void 0, done: true };
  }
};
Object.defineProperty(_a, "__esModule", { value: true });
_a.setAccount = void 0;
var Rb = Ke;
var $b = Xe;
var Fb = Ge;
var Qb = function(r) {
  return Pb(void 0, void 0, void 0, function() {
    var e, t, n, s, i, o, a;
    return Bb(this, function(u) {
      switch (u.label) {
        case 0:
          e = {
            type: "reject",
            result: void 0
          }, u.label = 1;
        case 1:
          return u.trys.push([1, 3, , 4]), t = {
            app: Rb.GEM_WALLET,
            type: "REQUEST_SET_ACCOUNT/V3",
            payload: r
          }, [4, (0, Fb.sendMessageToContentScript)(t)];
        case 2:
          if (n = u.sent(), s = n.result, i = n.error, o = i ? (0, $b.deserializeError)(i) : void 0, o)
            throw o;
          return s && (e.type = "response", e.result = s), [3, 4];
        case 3:
          throw a = u.sent(), a;
        case 4:
          return [2, e];
      }
    });
  });
};
_a.setAccount = Qb;
(function(r) {
  var e = B && B.__createBinding || (Object.create ? function(n, s, i, o) {
    o === void 0 && (o = i);
    var a = Object.getOwnPropertyDescriptor(s, i);
    (!a || ("get" in a ? !s.__esModule : a.writable || a.configurable)) && (a = { enumerable: true, get: function() {
      return s[i];
    } }), Object.defineProperty(n, o, a);
  } : function(n, s, i, o) {
    o === void 0 && (o = i), n[o] = s[i];
  }), t = B && B.__exportStar || function(n, s) {
    for (var i in n) i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && e(s, n, i);
  };
  Object.defineProperty(r, "__esModule", { value: true }), t(_a, r);
})(eg);
var tg = {};
var Da = {};
var qb = B && B.__awaiter || function(r, e, t, n) {
  function s(i) {
    return i instanceof t ? i : new t(function(o) {
      o(i);
    });
  }
  return new (t || (t = Promise))(function(i, o) {
    function a(l) {
      try {
        c(n.next(l));
      } catch (d) {
        o(d);
      }
    }
    function u(l) {
      try {
        c(n.throw(l));
      } catch (d) {
        o(d);
      }
    }
    function c(l) {
      l.done ? i(l.value) : s(l.value).then(a, u);
    }
    c((n = n.apply(r, e || [])).next());
  });
};
var Yb = B && B.__generator || function(r, e) {
  var t = { label: 0, sent: function() {
    if (i[0] & 1) throw i[1];
    return i[1];
  }, trys: [], ops: [] }, n, s, i, o;
  return o = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function a(c) {
    return function(l) {
      return u([c, l]);
    };
  }
  function u(c) {
    if (n) throw new TypeError("Generator is already executing.");
    for (; o && (o = 0, c[0] && (t = 0)), t; ) try {
      if (n = 1, s && (i = c[0] & 2 ? s.return : c[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, c[1])).done) return i;
      switch (s = 0, i && (c = [c[0] & 2, i.value]), c[0]) {
        case 0:
        case 1:
          i = c;
          break;
        case 4:
          return t.label++, { value: c[1], done: false };
        case 5:
          t.label++, s = c[1], c = [0];
          continue;
        case 7:
          c = t.ops.pop(), t.trys.pop();
          continue;
        default:
          if (i = t.trys, !(i = i.length > 0 && i[i.length - 1]) && (c[0] === 6 || c[0] === 2)) {
            t = 0;
            continue;
          }
          if (c[0] === 3 && (!i || c[1] > i[0] && c[1] < i[3])) {
            t.label = c[1];
            break;
          }
          if (c[0] === 6 && t.label < i[1]) {
            t.label = i[1], i = c;
            break;
          }
          if (i && t.label < i[2]) {
            t.label = i[2], t.ops.push(c);
            break;
          }
          i[2] && t.ops.pop(), t.trys.pop();
          continue;
      }
      c = e.call(r, t);
    } catch (l) {
      c = [6, l], s = 0;
    } finally {
      n = i = 0;
    }
    if (c[0] & 5) throw c[1];
    return { value: c[0] ? c[1] : void 0, done: true };
  }
};
Object.defineProperty(Da, "__esModule", { value: true });
Da.setHook = void 0;
var Vb = Ke;
var Hb = Xe;
var Gb = Ge;
var Wb = function(r) {
  return qb(void 0, void 0, void 0, function() {
    var e, t, n, s, i, o, a;
    return Yb(this, function(u) {
      switch (u.label) {
        case 0:
          e = {
            type: "reject",
            result: void 0
          }, u.label = 1;
        case 1:
          return u.trys.push([1, 3, , 4]), t = {
            app: Vb.GEM_WALLET,
            type: "REQUEST_SET_HOOK/V3",
            payload: r
          }, [4, (0, Gb.sendMessageToContentScript)(t)];
        case 2:
          if (n = u.sent(), s = n.result, i = n.error, o = i ? (0, Hb.deserializeError)(i) : void 0, o)
            throw o;
          return s && (e.type = "response", e.result = s), [3, 4];
        case 3:
          throw a = u.sent(), a;
        case 4:
          return [2, e];
      }
    });
  });
};
Da.setHook = Wb;
(function(r) {
  var e = B && B.__createBinding || (Object.create ? function(n, s, i, o) {
    o === void 0 && (o = i);
    var a = Object.getOwnPropertyDescriptor(s, i);
    (!a || ("get" in a ? !s.__esModule : a.writable || a.configurable)) && (a = { enumerable: true, get: function() {
      return s[i];
    } }), Object.defineProperty(n, o, a);
  } : function(n, s, i, o) {
    o === void 0 && (o = i), n[o] = s[i];
  }), t = B && B.__exportStar || function(n, s) {
    for (var i in n) i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && e(s, n, i);
  };
  Object.defineProperty(r, "__esModule", { value: true }), t(Da, r);
})(tg);
var rg = {};
var Ta = {};
var Kb = B && B.__awaiter || function(r, e, t, n) {
  function s(i) {
    return i instanceof t ? i : new t(function(o) {
      o(i);
    });
  }
  return new (t || (t = Promise))(function(i, o) {
    function a(l) {
      try {
        c(n.next(l));
      } catch (d) {
        o(d);
      }
    }
    function u(l) {
      try {
        c(n.throw(l));
      } catch (d) {
        o(d);
      }
    }
    function c(l) {
      l.done ? i(l.value) : s(l.value).then(a, u);
    }
    c((n = n.apply(r, e || [])).next());
  });
};
var Xb = B && B.__generator || function(r, e) {
  var t = { label: 0, sent: function() {
    if (i[0] & 1) throw i[1];
    return i[1];
  }, trys: [], ops: [] }, n, s, i, o;
  return o = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function a(c) {
    return function(l) {
      return u([c, l]);
    };
  }
  function u(c) {
    if (n) throw new TypeError("Generator is already executing.");
    for (; o && (o = 0, c[0] && (t = 0)), t; ) try {
      if (n = 1, s && (i = c[0] & 2 ? s.return : c[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, c[1])).done) return i;
      switch (s = 0, i && (c = [c[0] & 2, i.value]), c[0]) {
        case 0:
        case 1:
          i = c;
          break;
        case 4:
          return t.label++, { value: c[1], done: false };
        case 5:
          t.label++, s = c[1], c = [0];
          continue;
        case 7:
          c = t.ops.pop(), t.trys.pop();
          continue;
        default:
          if (i = t.trys, !(i = i.length > 0 && i[i.length - 1]) && (c[0] === 6 || c[0] === 2)) {
            t = 0;
            continue;
          }
          if (c[0] === 3 && (!i || c[1] > i[0] && c[1] < i[3])) {
            t.label = c[1];
            break;
          }
          if (c[0] === 6 && t.label < i[1]) {
            t.label = i[1], i = c;
            break;
          }
          if (i && t.label < i[2]) {
            t.label = i[2], t.ops.push(c);
            break;
          }
          i[2] && t.ops.pop(), t.trys.pop();
          continue;
      }
      c = e.call(r, t);
    } catch (l) {
      c = [6, l], s = 0;
    } finally {
      n = i = 0;
    }
    if (c[0] & 5) throw c[1];
    return { value: c[0] ? c[1] : void 0, done: true };
  }
};
Object.defineProperty(Ta, "__esModule", { value: true });
Ta.setRegularKey = void 0;
var Zb = Ke;
var Jb = Xe;
var ev = Ge;
var tv = function(r) {
  return Kb(void 0, void 0, void 0, function() {
    var e, t, n, s, i, o, a;
    return Xb(this, function(u) {
      switch (u.label) {
        case 0:
          e = {
            type: "reject",
            result: void 0
          }, u.label = 1;
        case 1:
          return u.trys.push([1, 3, , 4]), t = {
            app: Zb.GEM_WALLET,
            type: "REQUEST_SET_REGULAR_KEY/V3",
            payload: r
          }, [4, (0, ev.sendMessageToContentScript)(t)];
        case 2:
          if (n = u.sent(), s = n.result, i = n.error, o = i ? (0, Jb.deserializeError)(i) : void 0, o)
            throw o;
          return s && (e.type = "response", e.result = s), [3, 4];
        case 3:
          throw a = u.sent(), a;
        case 4:
          return [2, e];
      }
    });
  });
};
Ta.setRegularKey = tv;
(function(r) {
  var e = B && B.__createBinding || (Object.create ? function(n, s, i, o) {
    o === void 0 && (o = i);
    var a = Object.getOwnPropertyDescriptor(s, i);
    (!a || ("get" in a ? !s.__esModule : a.writable || a.configurable)) && (a = { enumerable: true, get: function() {
      return s[i];
    } }), Object.defineProperty(n, o, a);
  } : function(n, s, i, o) {
    o === void 0 && (o = i), n[o] = s[i];
  }), t = B && B.__exportStar || function(n, s) {
    for (var i in n) i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && e(s, n, i);
  };
  Object.defineProperty(r, "__esModule", { value: true }), t(Ta, r);
})(rg);
var ng = {};
var Aa = {};
var rv = B && B.__awaiter || function(r, e, t, n) {
  function s(i) {
    return i instanceof t ? i : new t(function(o) {
      o(i);
    });
  }
  return new (t || (t = Promise))(function(i, o) {
    function a(l) {
      try {
        c(n.next(l));
      } catch (d) {
        o(d);
      }
    }
    function u(l) {
      try {
        c(n.throw(l));
      } catch (d) {
        o(d);
      }
    }
    function c(l) {
      l.done ? i(l.value) : s(l.value).then(a, u);
    }
    c((n = n.apply(r, e || [])).next());
  });
};
var nv = B && B.__generator || function(r, e) {
  var t = { label: 0, sent: function() {
    if (i[0] & 1) throw i[1];
    return i[1];
  }, trys: [], ops: [] }, n, s, i, o;
  return o = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function a(c) {
    return function(l) {
      return u([c, l]);
    };
  }
  function u(c) {
    if (n) throw new TypeError("Generator is already executing.");
    for (; o && (o = 0, c[0] && (t = 0)), t; ) try {
      if (n = 1, s && (i = c[0] & 2 ? s.return : c[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, c[1])).done) return i;
      switch (s = 0, i && (c = [c[0] & 2, i.value]), c[0]) {
        case 0:
        case 1:
          i = c;
          break;
        case 4:
          return t.label++, { value: c[1], done: false };
        case 5:
          t.label++, s = c[1], c = [0];
          continue;
        case 7:
          c = t.ops.pop(), t.trys.pop();
          continue;
        default:
          if (i = t.trys, !(i = i.length > 0 && i[i.length - 1]) && (c[0] === 6 || c[0] === 2)) {
            t = 0;
            continue;
          }
          if (c[0] === 3 && (!i || c[1] > i[0] && c[1] < i[3])) {
            t.label = c[1];
            break;
          }
          if (c[0] === 6 && t.label < i[1]) {
            t.label = i[1], i = c;
            break;
          }
          if (i && t.label < i[2]) {
            t.label = i[2], t.ops.push(c);
            break;
          }
          i[2] && t.ops.pop(), t.trys.pop();
          continue;
      }
      c = e.call(r, t);
    } catch (l) {
      c = [6, l], s = 0;
    } finally {
      n = i = 0;
    }
    if (c[0] & 5) throw c[1];
    return { value: c[0] ? c[1] : void 0, done: true };
  }
};
Object.defineProperty(Aa, "__esModule", { value: true });
Aa.setTrustline = void 0;
var iv = Ke;
var sv = Xe;
var ov = Ge;
var av = function(r) {
  return rv(void 0, void 0, void 0, function() {
    var e, t, n, s, i, o, a;
    return nv(this, function(u) {
      switch (u.label) {
        case 0:
          e = {
            type: "reject",
            result: void 0
          }, u.label = 1;
        case 1:
          return u.trys.push([1, 3, , 4]), t = {
            app: iv.GEM_WALLET,
            type: "REQUEST_SET_TRUSTLINE/V3",
            payload: r
          }, [4, (0, ov.sendMessageToContentScript)(t)];
        case 2:
          if (n = u.sent(), s = n.result, i = n.error, o = i ? (0, sv.deserializeError)(i) : void 0, o)
            throw o;
          return s && (e.type = "response", e.result = s), [3, 4];
        case 3:
          throw a = u.sent(), a;
        case 4:
          return [2, e];
      }
    });
  });
};
Aa.setTrustline = av;
(function(r) {
  var e = B && B.__createBinding || (Object.create ? function(n, s, i, o) {
    o === void 0 && (o = i);
    var a = Object.getOwnPropertyDescriptor(s, i);
    (!a || ("get" in a ? !s.__esModule : a.writable || a.configurable)) && (a = { enumerable: true, get: function() {
      return s[i];
    } }), Object.defineProperty(n, o, a);
  } : function(n, s, i, o) {
    o === void 0 && (o = i), n[o] = s[i];
  }), t = B && B.__exportStar || function(n, s) {
    for (var i in n) i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && e(s, n, i);
  };
  Object.defineProperty(r, "__esModule", { value: true }), t(Aa, r);
})(ng);
var ig = {};
var Oa = {};
var cv = B && B.__awaiter || function(r, e, t, n) {
  function s(i) {
    return i instanceof t ? i : new t(function(o) {
      o(i);
    });
  }
  return new (t || (t = Promise))(function(i, o) {
    function a(l) {
      try {
        c(n.next(l));
      } catch (d) {
        o(d);
      }
    }
    function u(l) {
      try {
        c(n.throw(l));
      } catch (d) {
        o(d);
      }
    }
    function c(l) {
      l.done ? i(l.value) : s(l.value).then(a, u);
    }
    c((n = n.apply(r, e || [])).next());
  });
};
var uv = B && B.__generator || function(r, e) {
  var t = { label: 0, sent: function() {
    if (i[0] & 1) throw i[1];
    return i[1];
  }, trys: [], ops: [] }, n, s, i, o;
  return o = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function a(c) {
    return function(l) {
      return u([c, l]);
    };
  }
  function u(c) {
    if (n) throw new TypeError("Generator is already executing.");
    for (; o && (o = 0, c[0] && (t = 0)), t; ) try {
      if (n = 1, s && (i = c[0] & 2 ? s.return : c[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, c[1])).done) return i;
      switch (s = 0, i && (c = [c[0] & 2, i.value]), c[0]) {
        case 0:
        case 1:
          i = c;
          break;
        case 4:
          return t.label++, { value: c[1], done: false };
        case 5:
          t.label++, s = c[1], c = [0];
          continue;
        case 7:
          c = t.ops.pop(), t.trys.pop();
          continue;
        default:
          if (i = t.trys, !(i = i.length > 0 && i[i.length - 1]) && (c[0] === 6 || c[0] === 2)) {
            t = 0;
            continue;
          }
          if (c[0] === 3 && (!i || c[1] > i[0] && c[1] < i[3])) {
            t.label = c[1];
            break;
          }
          if (c[0] === 6 && t.label < i[1]) {
            t.label = i[1], i = c;
            break;
          }
          if (i && t.label < i[2]) {
            t.label = i[2], t.ops.push(c);
            break;
          }
          i[2] && t.ops.pop(), t.trys.pop();
          continue;
      }
      c = e.call(r, t);
    } catch (l) {
      c = [6, l], s = 0;
    } finally {
      n = i = 0;
    }
    if (c[0] & 5) throw c[1];
    return { value: c[0] ? c[1] : void 0, done: true };
  }
};
Object.defineProperty(Oa, "__esModule", { value: true });
Oa.signMessage = void 0;
var lv = Ke;
var dv = Xe;
var hv = Ge;
var fv = ai;
var pv = function(r, e) {
  return cv(void 0, void 0, void 0, function() {
    var t, n, s, i, o, a, u, c;
    return uv(this, function(l) {
      switch (l.label) {
        case 0:
          t = {
            type: "reject",
            result: void 0
          }, l.label = 1;
        case 1:
          return l.trys.push([1, 3, , 4]), n = (0, fv.getFavicon)(), s = {
            app: lv.GEM_WALLET,
            type: "REQUEST_SIGN_MESSAGE/V3",
            payload: {
              url: window.location.origin,
              title: document.title,
              favicon: n,
              message: r,
              isHex: e
            }
          }, [4, (0, hv.sendMessageToContentScript)(s)];
        case 2:
          if (i = l.sent(), o = i.result, a = i.error, u = a ? (0, dv.deserializeError)(a) : void 0, u)
            throw u;
          return o && (t.type = "response", t.result = o), [3, 4];
        case 3:
          throw c = l.sent(), c;
        case 4:
          return [2, t];
      }
    });
  });
};
Oa.signMessage = pv;
(function(r) {
  var e = B && B.__createBinding || (Object.create ? function(n, s, i, o) {
    o === void 0 && (o = i);
    var a = Object.getOwnPropertyDescriptor(s, i);
    (!a || ("get" in a ? !s.__esModule : a.writable || a.configurable)) && (a = { enumerable: true, get: function() {
      return s[i];
    } }), Object.defineProperty(n, o, a);
  } : function(n, s, i, o) {
    o === void 0 && (o = i), n[o] = s[i];
  }), t = B && B.__exportStar || function(n, s) {
    for (var i in n) i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && e(s, n, i);
  };
  Object.defineProperty(r, "__esModule", { value: true }), t(Oa, r);
})(ig);
var sg = {};
var Sa = {};
var gv = B && B.__awaiter || function(r, e, t, n) {
  function s(i) {
    return i instanceof t ? i : new t(function(o) {
      o(i);
    });
  }
  return new (t || (t = Promise))(function(i, o) {
    function a(l) {
      try {
        c(n.next(l));
      } catch (d) {
        o(d);
      }
    }
    function u(l) {
      try {
        c(n.throw(l));
      } catch (d) {
        o(d);
      }
    }
    function c(l) {
      l.done ? i(l.value) : s(l.value).then(a, u);
    }
    c((n = n.apply(r, e || [])).next());
  });
};
var yv = B && B.__generator || function(r, e) {
  var t = { label: 0, sent: function() {
    if (i[0] & 1) throw i[1];
    return i[1];
  }, trys: [], ops: [] }, n, s, i, o;
  return o = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function a(c) {
    return function(l) {
      return u([c, l]);
    };
  }
  function u(c) {
    if (n) throw new TypeError("Generator is already executing.");
    for (; o && (o = 0, c[0] && (t = 0)), t; ) try {
      if (n = 1, s && (i = c[0] & 2 ? s.return : c[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, c[1])).done) return i;
      switch (s = 0, i && (c = [c[0] & 2, i.value]), c[0]) {
        case 0:
        case 1:
          i = c;
          break;
        case 4:
          return t.label++, { value: c[1], done: false };
        case 5:
          t.label++, s = c[1], c = [0];
          continue;
        case 7:
          c = t.ops.pop(), t.trys.pop();
          continue;
        default:
          if (i = t.trys, !(i = i.length > 0 && i[i.length - 1]) && (c[0] === 6 || c[0] === 2)) {
            t = 0;
            continue;
          }
          if (c[0] === 3 && (!i || c[1] > i[0] && c[1] < i[3])) {
            t.label = c[1];
            break;
          }
          if (c[0] === 6 && t.label < i[1]) {
            t.label = i[1], i = c;
            break;
          }
          if (i && t.label < i[2]) {
            t.label = i[2], t.ops.push(c);
            break;
          }
          i[2] && t.ops.pop(), t.trys.pop();
          continue;
      }
      c = e.call(r, t);
    } catch (l) {
      c = [6, l], s = 0;
    } finally {
      n = i = 0;
    }
    if (c[0] & 5) throw c[1];
    return { value: c[0] ? c[1] : void 0, done: true };
  }
};
Object.defineProperty(Sa, "__esModule", { value: true });
Sa.signTransaction = void 0;
var wv = Ke;
var mv = Xe;
var bv = Ge;
var vv = function(r) {
  return gv(void 0, void 0, void 0, function() {
    var e, t, n, s, i, o, a;
    return yv(this, function(u) {
      switch (u.label) {
        case 0:
          e = {
            type: "reject",
            result: void 0
          }, u.label = 1;
        case 1:
          return u.trys.push([1, 3, , 4]), t = {
            app: wv.GEM_WALLET,
            type: "REQUEST_SIGN_TRANSACTION/V3",
            payload: r
          }, [4, (0, bv.sendMessageToContentScript)(t)];
        case 2:
          if (n = u.sent(), s = n.result, i = n.error, o = i ? (0, mv.deserializeError)(i) : void 0, o)
            throw o;
          return s && (e.type = "response", e.result = s), [3, 4];
        case 3:
          throw a = u.sent(), a;
        case 4:
          return [2, e];
      }
    });
  });
};
Sa.signTransaction = vv;
(function(r) {
  var e = B && B.__createBinding || (Object.create ? function(n, s, i, o) {
    o === void 0 && (o = i);
    var a = Object.getOwnPropertyDescriptor(s, i);
    (!a || ("get" in a ? !s.__esModule : a.writable || a.configurable)) && (a = { enumerable: true, get: function() {
      return s[i];
    } }), Object.defineProperty(n, o, a);
  } : function(n, s, i, o) {
    o === void 0 && (o = i), n[o] = s[i];
  }), t = B && B.__exportStar || function(n, s) {
    for (var i in n) i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && e(s, n, i);
  };
  Object.defineProperty(r, "__esModule", { value: true }), t(Sa, r);
})(sg);
var og = {};
var ja = {};
var Mv = B && B.__awaiter || function(r, e, t, n) {
  function s(i) {
    return i instanceof t ? i : new t(function(o) {
      o(i);
    });
  }
  return new (t || (t = Promise))(function(i, o) {
    function a(l) {
      try {
        c(n.next(l));
      } catch (d) {
        o(d);
      }
    }
    function u(l) {
      try {
        c(n.throw(l));
      } catch (d) {
        o(d);
      }
    }
    function c(l) {
      l.done ? i(l.value) : s(l.value).then(a, u);
    }
    c((n = n.apply(r, e || [])).next());
  });
};
var Ev = B && B.__generator || function(r, e) {
  var t = { label: 0, sent: function() {
    if (i[0] & 1) throw i[1];
    return i[1];
  }, trys: [], ops: [] }, n, s, i, o;
  return o = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function a(c) {
    return function(l) {
      return u([c, l]);
    };
  }
  function u(c) {
    if (n) throw new TypeError("Generator is already executing.");
    for (; o && (o = 0, c[0] && (t = 0)), t; ) try {
      if (n = 1, s && (i = c[0] & 2 ? s.return : c[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, c[1])).done) return i;
      switch (s = 0, i && (c = [c[0] & 2, i.value]), c[0]) {
        case 0:
        case 1:
          i = c;
          break;
        case 4:
          return t.label++, { value: c[1], done: false };
        case 5:
          t.label++, s = c[1], c = [0];
          continue;
        case 7:
          c = t.ops.pop(), t.trys.pop();
          continue;
        default:
          if (i = t.trys, !(i = i.length > 0 && i[i.length - 1]) && (c[0] === 6 || c[0] === 2)) {
            t = 0;
            continue;
          }
          if (c[0] === 3 && (!i || c[1] > i[0] && c[1] < i[3])) {
            t.label = c[1];
            break;
          }
          if (c[0] === 6 && t.label < i[1]) {
            t.label = i[1], i = c;
            break;
          }
          if (i && t.label < i[2]) {
            t.label = i[2], t.ops.push(c);
            break;
          }
          i[2] && t.ops.pop(), t.trys.pop();
          continue;
      }
      c = e.call(r, t);
    } catch (l) {
      c = [6, l], s = 0;
    } finally {
      n = i = 0;
    }
    if (c[0] & 5) throw c[1];
    return { value: c[0] ? c[1] : void 0, done: true };
  }
};
Object.defineProperty(ja, "__esModule", { value: true });
ja.submitTransaction = void 0;
var Nv = Ke;
var xv = Xe;
var Iv = Ge;
var _v = function(r) {
  return Mv(void 0, void 0, void 0, function() {
    var e, t, n, s, i, o, a;
    return Ev(this, function(u) {
      switch (u.label) {
        case 0:
          e = {
            type: "reject",
            result: void 0
          }, u.label = 1;
        case 1:
          return u.trys.push([1, 3, , 4]), t = {
            app: Nv.GEM_WALLET,
            type: "REQUEST_SUBMIT_TRANSACTION/V3",
            payload: r
          }, [4, (0, Iv.sendMessageToContentScript)(t)];
        case 2:
          if (n = u.sent(), s = n.result, i = n.error, o = i ? (0, xv.deserializeError)(i) : void 0, o)
            throw o;
          return s && (e.type = "response", e.result = s), [3, 4];
        case 3:
          throw a = u.sent(), a;
        case 4:
          return [2, e];
      }
    });
  });
};
ja.submitTransaction = _v;
(function(r) {
  var e = B && B.__createBinding || (Object.create ? function(n, s, i, o) {
    o === void 0 && (o = i);
    var a = Object.getOwnPropertyDescriptor(s, i);
    (!a || ("get" in a ? !s.__esModule : a.writable || a.configurable)) && (a = { enumerable: true, get: function() {
      return s[i];
    } }), Object.defineProperty(n, o, a);
  } : function(n, s, i, o) {
    o === void 0 && (o = i), n[o] = s[i];
  }), t = B && B.__exportStar || function(n, s) {
    for (var i in n) i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && e(s, n, i);
  };
  Object.defineProperty(r, "__esModule", { value: true }), t(ja, r);
})(og);
var ag = {};
var Ca = {};
var Lo = B && B.__assign || function() {
  return Lo = Object.assign || function(r) {
    for (var e, t = 1, n = arguments.length; t < n; t++) {
      e = arguments[t];
      for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && (r[s] = e[s]);
    }
    return r;
  }, Lo.apply(this, arguments);
};
var Dv = B && B.__awaiter || function(r, e, t, n) {
  function s(i) {
    return i instanceof t ? i : new t(function(o) {
      o(i);
    });
  }
  return new (t || (t = Promise))(function(i, o) {
    function a(l) {
      try {
        c(n.next(l));
      } catch (d) {
        o(d);
      }
    }
    function u(l) {
      try {
        c(n.throw(l));
      } catch (d) {
        o(d);
      }
    }
    function c(l) {
      l.done ? i(l.value) : s(l.value).then(a, u);
    }
    c((n = n.apply(r, e || [])).next());
  });
};
var Tv = B && B.__generator || function(r, e) {
  var t = { label: 0, sent: function() {
    if (i[0] & 1) throw i[1];
    return i[1];
  }, trys: [], ops: [] }, n, s, i, o;
  return o = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function a(c) {
    return function(l) {
      return u([c, l]);
    };
  }
  function u(c) {
    if (n) throw new TypeError("Generator is already executing.");
    for (; o && (o = 0, c[0] && (t = 0)), t; ) try {
      if (n = 1, s && (i = c[0] & 2 ? s.return : c[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, c[1])).done) return i;
      switch (s = 0, i && (c = [c[0] & 2, i.value]), c[0]) {
        case 0:
        case 1:
          i = c;
          break;
        case 4:
          return t.label++, { value: c[1], done: false };
        case 5:
          t.label++, s = c[1], c = [0];
          continue;
        case 7:
          c = t.ops.pop(), t.trys.pop();
          continue;
        default:
          if (i = t.trys, !(i = i.length > 0 && i[i.length - 1]) && (c[0] === 6 || c[0] === 2)) {
            t = 0;
            continue;
          }
          if (c[0] === 3 && (!i || c[1] > i[0] && c[1] < i[3])) {
            t.label = c[1];
            break;
          }
          if (c[0] === 6 && t.label < i[1]) {
            t.label = i[1], i = c;
            break;
          }
          if (i && t.label < i[2]) {
            t.label = i[2], t.ops.push(c);
            break;
          }
          i[2] && t.ops.pop(), t.trys.pop();
          continue;
      }
      c = e.call(r, t);
    } catch (l) {
      c = [6, l], s = 0;
    } finally {
      n = i = 0;
    }
    if (c[0] & 5) throw c[1];
    return { value: c[0] ? c[1] : void 0, done: true };
  }
};
Object.defineProperty(Ca, "__esModule", { value: true });
Ca.submitBulkTransactions = void 0;
var wd = Ke;
var Av = Xe;
var Ov = Ge;
var md = 50;
var Sv = function(r) {
  return Dv(void 0, void 0, void 0, function() {
    var e, t, n, s, i, o, a;
    return Tv(this, function(u) {
      switch (u.label) {
        case 0:
          if (e = {
            type: "reject",
            result: void 0
          }, !r.transactions)
            throw new Error(wd.API_ERROR_BAD_REQUEST);
          if (r.transactions.length === 0 || r.transactions.length > md)
            throw new Error("Invalid number of transactions (must be between 1 and ".concat(md, ")"));
          u.label = 1;
        case 1:
          return u.trys.push([1, 3, , 4]), t = {
            app: wd.GEM_WALLET,
            type: "REQUEST_SUBMIT_BULK_TRANSACTIONS/V3",
            payload: Lo(Lo({}, r), {
              // Add an index to each transaction so that we can process them in order
              transactions: r.transactions.reduce(function(c, l, d) {
                return c[d] = l, c;
              }, {})
            })
          }, [4, (0, Ov.sendMessageToContentScript)(t)];
        case 2:
          if (n = u.sent(), s = n.result, i = n.error, o = i ? (0, Av.deserializeError)(i) : void 0, o)
            throw o;
          return s && (e.type = "response", e.result = s), [3, 4];
        case 3:
          throw a = u.sent(), a;
        case 4:
          return [2, e];
      }
    });
  });
};
Ca.submitBulkTransactions = Sv;
(function(r) {
  var e = B && B.__createBinding || (Object.create ? function(n, s, i, o) {
    o === void 0 && (o = i);
    var a = Object.getOwnPropertyDescriptor(s, i);
    (!a || ("get" in a ? !s.__esModule : a.writable || a.configurable)) && (a = { enumerable: true, get: function() {
      return s[i];
    } }), Object.defineProperty(n, o, a);
  } : function(n, s, i, o) {
    o === void 0 && (o = i), n[o] = s[i];
  }), t = B && B.__exportStar || function(n, s) {
    for (var i in n) i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && e(s, n, i);
  };
  Object.defineProperty(r, "__esModule", { value: true }), t(Ca, r);
})(ag);
(function(r) {
  var e = B && B.__createBinding || (Object.create ? function(n, s, i, o) {
    o === void 0 && (o = i);
    var a = Object.getOwnPropertyDescriptor(s, i);
    (!a || ("get" in a ? !s.__esModule : a.writable || a.configurable)) && (a = { enumerable: true, get: function() {
      return s[i];
    } }), Object.defineProperty(n, o, a);
  } : function(n, s, i, o) {
    o === void 0 && (o = i), n[o] = s[i];
  }), t = B && B.__exportStar || function(n, s) {
    for (var i in n) i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && e(s, n, i);
  };
  Object.defineProperty(r, "__esModule", { value: true }), t(Lp, r), t($p, r), t(Fp, r), t(Qp, r), t(qp, r), t(Yp, r), t(Vp, r), t(Hp, r), t(Gp, r), t(Wp, r), t(Kp, r), t(Xp, r), t(Zp, r), t(Jp, r), t(eg, r), t(tg, r), t(rg, r), t(ng, r), t(ig, r), t(sg, r), t(og, r), t(ag, r);
})(xi);
var jv = class {
  constructor(e = {}) {
    this.id = "gemwallet", this.name = "GemWallet", this.icon = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAiIGhlaWdodD0iNDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwQThFQSIgZD0iTTIwIDM5LjkxMS41OTMgMTcuNDIyaDM4LjgxNHoiLz48cGF0aCBmaWxsPSIjMzNEM0Y0IiBkPSJNMzMuMTg1IDUuMzMzSDYuODE1TC41OTMgMTcuNDIzaDM4LjgxNHoiLz48cGF0aCBmaWxsPSIjNDBFRUZGIiBkPSJtMjAgMzkuOTExLTcuMDM3LTIyLjQ4OWgxNC4wNzR6TTE0LjIyMiAxNC40IDguNjY3IDUuMzMzSDIwem0xMS4yNTkgMEwyMCA1LjMzM2gxMS4zMzN6Ii8+PHBhdGggZmlsbD0iI0ZGRiIgZD0iTTYuMjk2IDYuNDg5IDMuNDA3IDUuMzMzbDIuODktMS4xNTVMNy4yNTguNzFsLjk2MyAzLjQ2NyAyLjg5IDEuMTU1LTIuODkgMS4xNTYtLjk2MyAzLjQ2N3ptMjcuNDA4IDExLjI4OS0xLjg1Mi0uNzExIDEuODUyLS44LjY2Ni0yLjIyMy41OTMgMi4yMjMgMS44NTIuOC0xLjg1Mi43MUwzNC4zNyAyMHoiLz48cGF0aCBkPSJNMjEuODUyIDUuMzMzIDYuMjk2IDI0LjA5bC0xLjMzMy0xLjUxMSAxNC4zNy0xNy4yNDV6bTguNzQxIDBMMTAuNzQgMjkuMTU2IDcuNjMgMjUuNiAyNC40NDQgNS4zMzN6IiBvcGFjaXR5PSIuMiIgZmlsbD0iI0ZGRiIvPjwvZz48L3N2Zz4=", this.url = "https://gemwallet.app", this.currentAccount = null;
  }
  /**
   * Check if GemWallet is installed
   */
  async isAvailable() {
    var e;
    try {
      return ((e = (await xi.isInstalled()).result) == null ? void 0 : e.isInstalled) || false;
    } catch {
      return false;
    }
  }
  /**
   * Connect to GemWallet
   */
  async connect(e) {
    try {
      if (!await this.isAvailable())
        throw me.notInstalled(this.name);
      const n = this.resolveNetwork(e == null ? void 0 : e.network), s = await xi.getPublicKey();
      if (!s.result || !s.result.address)
        throw new Error("Failed to get address from GemWallet");
      const { address: i, publicKey: o } = s.result;
      return this.currentAccount = {
        address: i,
        publicKey: o,
        network: n
      }, this.currentAccount;
    } catch (t) {
      throw me.connectionFailed(this.name, t);
    }
  }
  /**
   * Disconnect from GemWallet
   */
  async disconnect() {
    this.currentAccount = null;
  }
  /**
   * Get current account
   */
  async getAccount() {
    return this.currentAccount;
  }
  /**
   * Get current network
   */
  async getNetwork() {
    if (!this.currentAccount)
      throw me.notConnected();
    return this.currentAccount.network;
  }
  /**
   * Sign and optionally submit a transaction
   * @param transaction - The transaction to sign
   * @param submit - Whether to submit to the ledger (default: true)
   */
  async signAndSubmit(e, t = true) {
    if (!this.currentAccount)
      throw me.notConnected();
    try {
      const n = {
        ...e,
        Account: e.Account || this.currentAccount.address
      };
      if (t) {
        const s = await xi.submitTransaction({
          transaction: n
        });
        if (!s.result || !s.result.hash)
          throw new Error("Failed to submit transaction with GemWallet");
        const { hash: i } = s.result;
        return {
          hash: i
        };
      } else {
        const s = await xi.signTransaction({
          transaction: n
        });
        if (!s.result)
          throw new Error("Failed to sign transaction with GemWallet");
        const { signature: i } = s.result;
        return {
          hash: "",
          // GemWallet doesn't return hash for sign-only
          signature: i
        };
      }
    } catch (n) {
      throw n instanceof Error && n.message.toLowerCase().includes("reject") ? me.signRejected() : me.signFailed(n);
    }
  }
  /**
   * Sign a message
   */
  async signMessage(e) {
    if (!this.currentAccount)
      throw me.notConnected();
    try {
      const t = typeof e == "string" ? e : new TextDecoder().decode(e), n = await xi.signMessage(t);
      if (!n.result || !n.result.signedMessage)
        throw new Error("Failed to sign message with GemWallet");
      const { signedMessage: s } = n.result;
      return {
        message: t,
        signature: s,
        publicKey: this.currentAccount.publicKey || ""
      };
    } catch (t) {
      throw me.signFailed(t);
    }
  }
  /**
   * Resolve network configuration
   */
  resolveNetwork(e) {
    if (!e)
      return Ci.mainnet;
    if (typeof e == "string") {
      const t = Ci[e];
      if (!t)
        throw me.unknown(`Unknown network: ${e}`);
      return t;
    }
    return e;
  }
};
var ce = {};
var ou = function(r, e) {
  return ou = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, n) {
    t.__proto__ = n;
  } || function(t, n) {
    for (var s in n) n.hasOwnProperty(s) && (t[s] = n[s]);
  }, ou(r, e);
};
function Cv(r, e) {
  ou(r, e);
  function t() {
    this.constructor = r;
  }
  r.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
var au = function() {
  return au = Object.assign || function(e) {
    for (var t, n = 1, s = arguments.length; n < s; n++) {
      t = arguments[n];
      for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
    }
    return e;
  }, au.apply(this, arguments);
};
function Lv(r, e) {
  var t = {};
  for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && e.indexOf(n) < 0 && (t[n] = r[n]);
  if (r != null && typeof Object.getOwnPropertySymbols == "function")
    for (var s = 0, n = Object.getOwnPropertySymbols(r); s < n.length; s++)
      e.indexOf(n[s]) < 0 && Object.prototype.propertyIsEnumerable.call(r, n[s]) && (t[n[s]] = r[n[s]]);
  return t;
}
function zv(r, e, t, n) {
  var s = arguments.length, i = s < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") i = Reflect.decorate(r, e, t, n);
  else for (var a = r.length - 1; a >= 0; a--) (o = r[a]) && (i = (s < 3 ? o(i) : s > 3 ? o(e, t, i) : o(e, t)) || i);
  return s > 3 && i && Object.defineProperty(e, t, i), i;
}
function kv(r, e) {
  return function(t, n) {
    e(t, n, r);
  };
}
function Uv(r, e) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function") return Reflect.metadata(r, e);
}
function Pv(r, e, t, n) {
  function s(i) {
    return i instanceof t ? i : new t(function(o) {
      o(i);
    });
  }
  return new (t || (t = Promise))(function(i, o) {
    function a(l) {
      try {
        c(n.next(l));
      } catch (d) {
        o(d);
      }
    }
    function u(l) {
      try {
        c(n.throw(l));
      } catch (d) {
        o(d);
      }
    }
    function c(l) {
      l.done ? i(l.value) : s(l.value).then(a, u);
    }
    c((n = n.apply(r, e || [])).next());
  });
}
function Bv(r, e) {
  var t = { label: 0, sent: function() {
    if (i[0] & 1) throw i[1];
    return i[1];
  }, trys: [], ops: [] }, n, s, i, o;
  return o = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function a(c) {
    return function(l) {
      return u([c, l]);
    };
  }
  function u(c) {
    if (n) throw new TypeError("Generator is already executing.");
    for (; t; ) try {
      if (n = 1, s && (i = c[0] & 2 ? s.return : c[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, c[1])).done) return i;
      switch (s = 0, i && (c = [c[0] & 2, i.value]), c[0]) {
        case 0:
        case 1:
          i = c;
          break;
        case 4:
          return t.label++, { value: c[1], done: false };
        case 5:
          t.label++, s = c[1], c = [0];
          continue;
        case 7:
          c = t.ops.pop(), t.trys.pop();
          continue;
        default:
          if (i = t.trys, !(i = i.length > 0 && i[i.length - 1]) && (c[0] === 6 || c[0] === 2)) {
            t = 0;
            continue;
          }
          if (c[0] === 3 && (!i || c[1] > i[0] && c[1] < i[3])) {
            t.label = c[1];
            break;
          }
          if (c[0] === 6 && t.label < i[1]) {
            t.label = i[1], i = c;
            break;
          }
          if (i && t.label < i[2]) {
            t.label = i[2], t.ops.push(c);
            break;
          }
          i[2] && t.ops.pop(), t.trys.pop();
          continue;
      }
      c = e.call(r, t);
    } catch (l) {
      c = [6, l], s = 0;
    } finally {
      n = i = 0;
    }
    if (c[0] & 5) throw c[1];
    return { value: c[0] ? c[1] : void 0, done: true };
  }
}
function Rv(r, e, t, n) {
  n === void 0 && (n = t), r[n] = e[t];
}
function $v(r, e) {
  for (var t in r) t !== "default" && !e.hasOwnProperty(t) && (e[t] = r[t]);
}
function cu(r) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && r[e], n = 0;
  if (t) return t.call(r);
  if (r && typeof r.length == "number") return {
    next: function() {
      return r && n >= r.length && (r = void 0), { value: r && r[n++], done: !r };
    }
  };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function cg(r, e) {
  var t = typeof Symbol == "function" && r[Symbol.iterator];
  if (!t) return r;
  var n = t.call(r), s, i = [], o;
  try {
    for (; (e === void 0 || e-- > 0) && !(s = n.next()).done; ) i.push(s.value);
  } catch (a) {
    o = { error: a };
  } finally {
    try {
      s && !s.done && (t = n.return) && t.call(n);
    } finally {
      if (o) throw o.error;
    }
  }
  return i;
}
function Fv() {
  for (var r = [], e = 0; e < arguments.length; e++)
    r = r.concat(cg(arguments[e]));
  return r;
}
function Qv() {
  for (var r = 0, e = 0, t = arguments.length; e < t; e++) r += arguments[e].length;
  for (var n = Array(r), s = 0, e = 0; e < t; e++)
    for (var i = arguments[e], o = 0, a = i.length; o < a; o++, s++)
      n[s] = i[o];
  return n;
}
function xs(r) {
  return this instanceof xs ? (this.v = r, this) : new xs(r);
}
function qv(r, e, t) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var n = t.apply(r, e || []), s, i = [];
  return s = {}, o("next"), o("throw"), o("return"), s[Symbol.asyncIterator] = function() {
    return this;
  }, s;
  function o(h) {
    n[h] && (s[h] = function(f) {
      return new Promise(function(g, p) {
        i.push([h, f, g, p]) > 1 || a(h, f);
      });
    });
  }
  function a(h, f) {
    try {
      u(n[h](f));
    } catch (g) {
      d(i[0][3], g);
    }
  }
  function u(h) {
    h.value instanceof xs ? Promise.resolve(h.value.v).then(c, l) : d(i[0][2], h);
  }
  function c(h) {
    a("next", h);
  }
  function l(h) {
    a("throw", h);
  }
  function d(h, f) {
    h(f), i.shift(), i.length && a(i[0][0], i[0][1]);
  }
}
function Yv(r) {
  var e, t;
  return e = {}, n("next"), n("throw", function(s) {
    throw s;
  }), n("return"), e[Symbol.iterator] = function() {
    return this;
  }, e;
  function n(s, i) {
    e[s] = r[s] ? function(o) {
      return (t = !t) ? { value: xs(r[s](o)), done: s === "return" } : i ? i(o) : o;
    } : i;
  }
}
function Vv(r) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var e = r[Symbol.asyncIterator], t;
  return e ? e.call(r) : (r = typeof cu == "function" ? cu(r) : r[Symbol.iterator](), t = {}, n("next"), n("throw"), n("return"), t[Symbol.asyncIterator] = function() {
    return this;
  }, t);
  function n(i) {
    t[i] = r[i] && function(o) {
      return new Promise(function(a, u) {
        o = r[i](o), s(a, u, o.done, o.value);
      });
    };
  }
  function s(i, o, a, u) {
    Promise.resolve(u).then(function(c) {
      i({ value: c, done: a });
    }, o);
  }
}
function Hv(r, e) {
  return Object.defineProperty ? Object.defineProperty(r, "raw", { value: e }) : r.raw = e, r;
}
function Gv(r) {
  if (r && r.__esModule) return r;
  var e = {};
  if (r != null) for (var t in r) Object.hasOwnProperty.call(r, t) && (e[t] = r[t]);
  return e.default = r, e;
}
function Wv(r) {
  return r && r.__esModule ? r : { default: r };
}
function Kv(r, e) {
  if (!e.has(r))
    throw new TypeError("attempted to get private field on non-instance");
  return e.get(r);
}
function Xv(r, e, t) {
  if (!e.has(r))
    throw new TypeError("attempted to set private field on non-instance");
  return e.set(r, t), t;
}
var Zv = Object.freeze(Object.defineProperty({
  __proto__: null,
  get __assign() {
    return au;
  },
  __asyncDelegator: Yv,
  __asyncGenerator: qv,
  __asyncValues: Vv,
  __await: xs,
  __awaiter: Pv,
  __classPrivateFieldGet: Kv,
  __classPrivateFieldSet: Xv,
  __createBinding: Rv,
  __decorate: zv,
  __exportStar: $v,
  __extends: Cv,
  __generator: Bv,
  __importDefault: Wv,
  __importStar: Gv,
  __makeTemplateObject: Hv,
  __metadata: Uv,
  __param: kv,
  __read: cg,
  __rest: Lv,
  __spread: Fv,
  __spreadArrays: Qv,
  __values: cu
}, Symbol.toStringTag, { value: "Module" }));
var Ls = dp(Zv);
var uc = {};
var Zi = {};
var bd;
function Jv() {
  if (bd) return Zi;
  bd = 1, Object.defineProperty(Zi, "__esModule", { value: true }), Zi.delay = void 0;
  function r(e) {
    return new Promise((t) => {
      setTimeout(() => {
        t(true);
      }, e);
    });
  }
  return Zi.delay = r, Zi;
}
var Un = {};
var lc = {};
var Pn = {};
var vd;
function eM() {
  return vd || (vd = 1, Object.defineProperty(Pn, "__esModule", { value: true }), Pn.ONE_THOUSAND = Pn.ONE_HUNDRED = void 0, Pn.ONE_HUNDRED = 100, Pn.ONE_THOUSAND = 1e3), Pn;
}
var dc = {};
var Md;
function tM() {
  return Md || (Md = 1, function(r) {
    Object.defineProperty(r, "__esModule", { value: true }), r.ONE_YEAR = r.FOUR_WEEKS = r.THREE_WEEKS = r.TWO_WEEKS = r.ONE_WEEK = r.THIRTY_DAYS = r.SEVEN_DAYS = r.FIVE_DAYS = r.THREE_DAYS = r.ONE_DAY = r.TWENTY_FOUR_HOURS = r.TWELVE_HOURS = r.SIX_HOURS = r.THREE_HOURS = r.ONE_HOUR = r.SIXTY_MINUTES = r.THIRTY_MINUTES = r.TEN_MINUTES = r.FIVE_MINUTES = r.ONE_MINUTE = r.SIXTY_SECONDS = r.THIRTY_SECONDS = r.TEN_SECONDS = r.FIVE_SECONDS = r.ONE_SECOND = void 0, r.ONE_SECOND = 1, r.FIVE_SECONDS = 5, r.TEN_SECONDS = 10, r.THIRTY_SECONDS = 30, r.SIXTY_SECONDS = 60, r.ONE_MINUTE = r.SIXTY_SECONDS, r.FIVE_MINUTES = r.ONE_MINUTE * 5, r.TEN_MINUTES = r.ONE_MINUTE * 10, r.THIRTY_MINUTES = r.ONE_MINUTE * 30, r.SIXTY_MINUTES = r.ONE_MINUTE * 60, r.ONE_HOUR = r.SIXTY_MINUTES, r.THREE_HOURS = r.ONE_HOUR * 3, r.SIX_HOURS = r.ONE_HOUR * 6, r.TWELVE_HOURS = r.ONE_HOUR * 12, r.TWENTY_FOUR_HOURS = r.ONE_HOUR * 24, r.ONE_DAY = r.TWENTY_FOUR_HOURS, r.THREE_DAYS = r.ONE_DAY * 3, r.FIVE_DAYS = r.ONE_DAY * 5, r.SEVEN_DAYS = r.ONE_DAY * 7, r.THIRTY_DAYS = r.ONE_DAY * 30, r.ONE_WEEK = r.SEVEN_DAYS, r.TWO_WEEKS = r.ONE_WEEK * 2, r.THREE_WEEKS = r.ONE_WEEK * 3, r.FOUR_WEEKS = r.ONE_WEEK * 4, r.ONE_YEAR = r.ONE_DAY * 365;
  }(dc)), dc;
}
var Ed;
function ug() {
  return Ed || (Ed = 1, function(r) {
    Object.defineProperty(r, "__esModule", { value: true });
    const e = Ls;
    e.__exportStar(eM(), r), e.__exportStar(tM(), r);
  }(lc)), lc;
}
var Nd;
function rM() {
  if (Nd) return Un;
  Nd = 1, Object.defineProperty(Un, "__esModule", { value: true }), Un.fromMiliseconds = Un.toMiliseconds = void 0;
  const r = ug();
  function e(n) {
    return n * r.ONE_THOUSAND;
  }
  Un.toMiliseconds = e;
  function t(n) {
    return Math.floor(n / r.ONE_THOUSAND);
  }
  return Un.fromMiliseconds = t, Un;
}
var xd;
function nM() {
  return xd || (xd = 1, function(r) {
    Object.defineProperty(r, "__esModule", { value: true });
    const e = Ls;
    e.__exportStar(Jv(), r), e.__exportStar(rM(), r);
  }(uc)), uc;
}
var yi = {};
var Id;
function iM() {
  if (Id) return yi;
  Id = 1, Object.defineProperty(yi, "__esModule", { value: true }), yi.Watch = void 0;
  class r {
    constructor() {
      this.timestamps = /* @__PURE__ */ new Map();
    }
    start(t) {
      if (this.timestamps.has(t))
        throw new Error(`Watch already started for label: ${t}`);
      this.timestamps.set(t, { started: Date.now() });
    }
    stop(t) {
      const n = this.get(t);
      if (typeof n.elapsed < "u")
        throw new Error(`Watch already stopped for label: ${t}`);
      const s = Date.now() - n.started;
      this.timestamps.set(t, { started: n.started, elapsed: s });
    }
    get(t) {
      const n = this.timestamps.get(t);
      if (typeof n > "u")
        throw new Error(`No timestamp found for label: ${t}`);
      return n;
    }
    elapsed(t) {
      const n = this.get(t);
      return n.elapsed || Date.now() - n.started;
    }
  }
  return yi.Watch = r, yi.default = r, yi;
}
var hc = {};
var Ji = {};
var _d;
function sM() {
  if (_d) return Ji;
  _d = 1, Object.defineProperty(Ji, "__esModule", { value: true }), Ji.IWatch = void 0;
  class r {
  }
  return Ji.IWatch = r, Ji;
}
var Dd;
function oM() {
  return Dd || (Dd = 1, function(r) {
    Object.defineProperty(r, "__esModule", { value: true }), Ls.__exportStar(sM(), r);
  }(hc)), hc;
}
(function(r) {
  Object.defineProperty(r, "__esModule", { value: true });
  const e = Ls;
  e.__exportStar(nM(), r), e.__exportStar(iM(), r), e.__exportStar(oM(), r), e.__exportStar(ug(), r);
})(ce);
var ci = class {
};
var aM = class extends ci {
  constructor(e) {
    super();
  }
};
var Td = ce.FIVE_SECONDS;
var ui = { pulse: "heartbeat_pulse" };
var cM = class lg extends aM {
  constructor(e) {
    super(e), this.events = new Gt.EventEmitter(), this.interval = Td, this.interval = (e == null ? void 0 : e.interval) || Td;
  }
  static async init(e) {
    const t = new lg(e);
    return await t.init(), t;
  }
  async init() {
    await this.initialize();
  }
  stop() {
    clearInterval(this.intervalRef);
  }
  on(e, t) {
    this.events.on(e, t);
  }
  once(e, t) {
    this.events.once(e, t);
  }
  off(e, t) {
    this.events.off(e, t);
  }
  removeListener(e, t) {
    this.events.removeListener(e, t);
  }
  async initialize() {
    this.intervalRef = setInterval(() => this.pulse(), ce.toMiliseconds(this.interval));
  }
  pulse() {
    this.events.emit(ui.pulse);
  }
};
var uM = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/;
var lM = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
var dM = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
function hM(r, e) {
  if (r === "__proto__" || r === "constructor" && e && typeof e == "object" && "prototype" in e) {
    fM(r);
    return;
  }
  return e;
}
function fM(r) {
  console.warn(`[destr] Dropping "${r}" key to prevent prototype pollution.`);
}
function eo(r, e = {}) {
  if (typeof r != "string")
    return r;
  if (r[0] === '"' && r[r.length - 1] === '"' && r.indexOf("\\") === -1)
    return r.slice(1, -1);
  const t = r.trim();
  if (t.length <= 9)
    switch (t.toLowerCase()) {
      case "true":
        return true;
      case "false":
        return false;
      case "undefined":
        return;
      case "null":
        return null;
      case "nan":
        return Number.NaN;
      case "infinity":
        return Number.POSITIVE_INFINITY;
      case "-infinity":
        return Number.NEGATIVE_INFINITY;
    }
  if (!dM.test(r)) {
    if (e.strict)
      throw new SyntaxError("[destr] Invalid JSON");
    return r;
  }
  try {
    if (uM.test(r) || lM.test(r)) {
      if (e.strict)
        throw new Error("[destr] Possible prototype pollution");
      return JSON.parse(r, hM);
    }
    return JSON.parse(r);
  } catch (n) {
    if (e.strict)
      throw n;
    return r;
  }
}
function pM(r) {
  return !r || typeof r.then != "function" ? Promise.resolve(r) : r;
}
function ft(r, ...e) {
  try {
    return pM(r(...e));
  } catch (t) {
    return Promise.reject(t);
  }
}
function gM(r) {
  const e = typeof r;
  return r === null || e !== "object" && e !== "function";
}
function yM(r) {
  const e = Object.getPrototypeOf(r);
  return !e || e.isPrototypeOf(Object);
}
function No(r) {
  if (gM(r))
    return String(r);
  if (yM(r) || Array.isArray(r))
    return JSON.stringify(r);
  if (typeof r.toJSON == "function")
    return No(r.toJSON());
  throw new Error("[unstorage] Cannot stringify value!");
}
var uu = "base64:";
function wM(r) {
  return typeof r == "string" ? r : uu + vM(r);
}
function mM(r) {
  return typeof r != "string" || !r.startsWith(uu) ? r : bM(r.slice(uu.length));
}
function bM(r) {
  return globalThis.Buffer ? Buffer.from(r, "base64") : Uint8Array.from(
    globalThis.atob(r),
    (e) => e.codePointAt(0)
  );
}
function vM(r) {
  return globalThis.Buffer ? Buffer.from(r).toString("base64") : globalThis.btoa(String.fromCodePoint(...r));
}
function Rt(r) {
  var e;
  return r && ((e = r.split("?")[0]) == null ? void 0 : e.replace(/[/\\]/g, ":").replace(/:+/g, ":").replace(/^:|:$/g, "")) || "";
}
function MM(...r) {
  return Rt(r.join(":"));
}
function to(r) {
  return r = Rt(r), r ? r + ":" : "";
}
function EM(r, e) {
  if (e === void 0)
    return true;
  let t = 0, n = r.indexOf(":");
  for (; n > -1; )
    t++, n = r.indexOf(":", n + 1);
  return t <= e;
}
function NM(r, e) {
  return e ? r.startsWith(e) && r[r.length - 1] !== "$" : r[r.length - 1] !== "$";
}
var xM = "memory";
var IM = () => {
  const r = /* @__PURE__ */ new Map();
  return {
    name: xM,
    getInstance: () => r,
    hasItem(e) {
      return r.has(e);
    },
    getItem(e) {
      return r.get(e) ?? null;
    },
    getItemRaw(e) {
      return r.get(e) ?? null;
    },
    setItem(e, t) {
      r.set(e, t);
    },
    setItemRaw(e, t) {
      r.set(e, t);
    },
    removeItem(e) {
      r.delete(e);
    },
    getKeys() {
      return [...r.keys()];
    },
    clear() {
      r.clear();
    },
    dispose() {
      r.clear();
    }
  };
};
function _M(r = {}) {
  const e = {
    mounts: { "": r.driver || IM() },
    mountpoints: [""],
    watching: false,
    watchListeners: [],
    unwatch: {}
  }, t = (c) => {
    for (const l of e.mountpoints)
      if (c.startsWith(l))
        return {
          base: l,
          relativeKey: c.slice(l.length),
          driver: e.mounts[l]
        };
    return {
      base: "",
      relativeKey: c,
      driver: e.mounts[""]
    };
  }, n = (c, l) => e.mountpoints.filter(
    (d) => d.startsWith(c) || l && c.startsWith(d)
  ).map((d) => ({
    relativeBase: c.length > d.length ? c.slice(d.length) : void 0,
    mountpoint: d,
    driver: e.mounts[d]
  })), s = (c, l) => {
    if (e.watching) {
      l = Rt(l);
      for (const d of e.watchListeners)
        d(c, l);
    }
  }, i = async () => {
    if (!e.watching) {
      e.watching = true;
      for (const c in e.mounts)
        e.unwatch[c] = await Ad(
          e.mounts[c],
          s,
          c
        );
    }
  }, o = async () => {
    if (e.watching) {
      for (const c in e.unwatch)
        await e.unwatch[c]();
      e.unwatch = {}, e.watching = false;
    }
  }, a = (c, l, d) => {
    const h = /* @__PURE__ */ new Map(), f = (g) => {
      let p = h.get(g.base);
      return p || (p = {
        driver: g.driver,
        base: g.base,
        items: []
      }, h.set(g.base, p)), p;
    };
    for (const g of c) {
      const p = typeof g == "string", b = Rt(p ? g : g.key), _ = p ? void 0 : g.value, D = p || !g.options ? l : { ...l, ...g.options }, v = t(b);
      f(v).items.push({
        key: b,
        value: _,
        relativeKey: v.relativeKey,
        options: D
      });
    }
    return Promise.all([...h.values()].map((g) => d(g))).then(
      (g) => g.flat()
    );
  }, u = {
    // Item
    hasItem(c, l = {}) {
      c = Rt(c);
      const { relativeKey: d, driver: h } = t(c);
      return ft(h.hasItem, d, l);
    },
    getItem(c, l = {}) {
      c = Rt(c);
      const { relativeKey: d, driver: h } = t(c);
      return ft(h.getItem, d, l).then(
        (f) => eo(f)
      );
    },
    getItems(c, l = {}) {
      return a(c, l, (d) => d.driver.getItems ? ft(
        d.driver.getItems,
        d.items.map((h) => ({
          key: h.relativeKey,
          options: h.options
        })),
        l
      ).then(
        (h) => h.map((f) => ({
          key: MM(d.base, f.key),
          value: eo(f.value)
        }))
      ) : Promise.all(
        d.items.map((h) => ft(
          d.driver.getItem,
          h.relativeKey,
          h.options
        ).then((f) => ({
          key: h.key,
          value: eo(f)
        })))
      ));
    },
    getItemRaw(c, l = {}) {
      c = Rt(c);
      const { relativeKey: d, driver: h } = t(c);
      return h.getItemRaw ? ft(h.getItemRaw, d, l) : ft(h.getItem, d, l).then(
        (f) => mM(f)
      );
    },
    async setItem(c, l, d = {}) {
      if (l === void 0)
        return u.removeItem(c);
      c = Rt(c);
      const { relativeKey: h, driver: f } = t(c);
      f.setItem && (await ft(f.setItem, h, No(l), d), f.watch || s("update", c));
    },
    async setItems(c, l) {
      await a(c, l, async (d) => {
        if (d.driver.setItems)
          return ft(
            d.driver.setItems,
            d.items.map((h) => ({
              key: h.relativeKey,
              value: No(h.value),
              options: h.options
            })),
            l
          );
        d.driver.setItem && await Promise.all(
          d.items.map((h) => ft(
            d.driver.setItem,
            h.relativeKey,
            No(h.value),
            h.options
          ))
        );
      });
    },
    async setItemRaw(c, l, d = {}) {
      if (l === void 0)
        return u.removeItem(c, d);
      c = Rt(c);
      const { relativeKey: h, driver: f } = t(c);
      if (f.setItemRaw)
        await ft(f.setItemRaw, h, l, d);
      else if (f.setItem)
        await ft(f.setItem, h, wM(l), d);
      else
        return;
      f.watch || s("update", c);
    },
    async removeItem(c, l = {}) {
      typeof l == "boolean" && (l = { removeMeta: l }), c = Rt(c);
      const { relativeKey: d, driver: h } = t(c);
      h.removeItem && (await ft(h.removeItem, d, l), (l.removeMeta || l.removeMata) && await ft(h.removeItem, d + "$", l), h.watch || s("remove", c));
    },
    // Meta
    async getMeta(c, l = {}) {
      typeof l == "boolean" && (l = { nativeOnly: l }), c = Rt(c);
      const { relativeKey: d, driver: h } = t(c), f = /* @__PURE__ */ Object.create(null);
      if (h.getMeta && Object.assign(f, await ft(h.getMeta, d, l)), !l.nativeOnly) {
        const g = await ft(
          h.getItem,
          d + "$",
          l
        ).then((p) => eo(p));
        g && typeof g == "object" && (typeof g.atime == "string" && (g.atime = new Date(g.atime)), typeof g.mtime == "string" && (g.mtime = new Date(g.mtime)), Object.assign(f, g));
      }
      return f;
    },
    setMeta(c, l, d = {}) {
      return this.setItem(c + "$", l, d);
    },
    removeMeta(c, l = {}) {
      return this.removeItem(c + "$", l);
    },
    // Keys
    async getKeys(c, l = {}) {
      var b;
      c = to(c);
      const d = n(c, true);
      let h = [];
      const f = [];
      let g = true;
      for (const _ of d) {
        (b = _.driver.flags) != null && b.maxDepth || (g = false);
        const D = await ft(
          _.driver.getKeys,
          _.relativeBase,
          l
        );
        for (const v of D) {
          const E = _.mountpoint + Rt(v);
          h.some((A) => E.startsWith(A)) || f.push(E);
        }
        h = [
          _.mountpoint,
          ...h.filter((v) => !v.startsWith(_.mountpoint))
        ];
      }
      const p = l.maxDepth !== void 0 && !g;
      return f.filter(
        (_) => (!p || EM(_, l.maxDepth)) && NM(_, c)
      );
    },
    // Utils
    async clear(c, l = {}) {
      c = to(c), await Promise.all(
        n(c, false).map(async (d) => {
          if (d.driver.clear)
            return ft(d.driver.clear, d.relativeBase, l);
          if (d.driver.removeItem) {
            const h = await d.driver.getKeys(d.relativeBase || "", l);
            return Promise.all(
              h.map((f) => d.driver.removeItem(f, l))
            );
          }
        })
      );
    },
    async dispose() {
      await Promise.all(
        Object.values(e.mounts).map((c) => Od(c))
      );
    },
    async watch(c) {
      return await i(), e.watchListeners.push(c), async () => {
        e.watchListeners = e.watchListeners.filter(
          (l) => l !== c
        ), e.watchListeners.length === 0 && await o();
      };
    },
    async unwatch() {
      e.watchListeners = [], await o();
    },
    // Mount
    mount(c, l) {
      if (c = to(c), c && e.mounts[c])
        throw new Error(`already mounted at ${c}`);
      return c && (e.mountpoints.push(c), e.mountpoints.sort((d, h) => h.length - d.length)), e.mounts[c] = l, e.watching && Promise.resolve(Ad(l, s, c)).then((d) => {
        e.unwatch[c] = d;
      }).catch(console.error), u;
    },
    async unmount(c, l = true) {
      var d, h;
      c = to(c), !(!c || !e.mounts[c]) && (e.watching && c in e.unwatch && ((h = (d = e.unwatch)[c]) == null || h.call(d), delete e.unwatch[c]), l && await Od(e.mounts[c]), e.mountpoints = e.mountpoints.filter((f) => f !== c), delete e.mounts[c]);
    },
    getMount(c = "") {
      c = Rt(c) + ":";
      const l = t(c);
      return {
        driver: l.driver,
        base: l.base
      };
    },
    getMounts(c = "", l = {}) {
      return c = Rt(c), n(c, l.parents).map((h) => ({
        driver: h.driver,
        base: h.mountpoint
      }));
    },
    // Aliases
    keys: (c, l = {}) => u.getKeys(c, l),
    get: (c, l = {}) => u.getItem(c, l),
    set: (c, l, d = {}) => u.setItem(c, l, d),
    has: (c, l = {}) => u.hasItem(c, l),
    del: (c, l = {}) => u.removeItem(c, l),
    remove: (c, l = {}) => u.removeItem(c, l)
  };
  return u;
}
function Ad(r, e, t) {
  return r.watch ? r.watch((n, s) => e(n, t + s)) : () => {
  };
}
async function Od(r) {
  typeof r.dispose == "function" && await ft(r.dispose);
}
function li(r) {
  return new Promise((e, t) => {
    r.oncomplete = r.onsuccess = () => e(r.result), r.onabort = r.onerror = () => t(r.error);
  });
}
function dg(r, e) {
  let t;
  const n = () => {
    if (t)
      return t;
    const s = indexedDB.open(r);
    return s.onupgradeneeded = () => s.result.createObjectStore(e), t = li(s), t.then((i) => {
      i.onclose = () => t = void 0;
    }, () => {
    }), t;
  };
  return (s, i) => n().then((o) => i(o.transaction(e, s).objectStore(e)));
}
var fc;
function zs() {
  return fc || (fc = dg("keyval-store", "keyval")), fc;
}
function Sd(r, e = zs()) {
  return e("readonly", (t) => li(t.get(r)));
}
function DM(r, e, t = zs()) {
  return t("readwrite", (n) => (n.put(e, r), li(n.transaction)));
}
function TM(r, e = zs()) {
  return e("readwrite", (t) => (t.delete(r), li(t.transaction)));
}
function AM(r = zs()) {
  return r("readwrite", (e) => (e.clear(), li(e.transaction)));
}
function OM(r, e) {
  return r.openCursor().onsuccess = function() {
    this.result && (e(this.result), this.result.continue());
  }, li(r.transaction);
}
function SM(r = zs()) {
  return r("readonly", (e) => {
    if (e.getAllKeys)
      return li(e.getAllKeys());
    const t = [];
    return OM(e, (n) => t.push(n.key)).then(() => t);
  });
}
var jM = (r) => JSON.stringify(r, (e, t) => typeof t == "bigint" ? t.toString() + "n" : t);
var CM = (r) => {
  const e = /([\[:])?(\d{17,}|(?:[9](?:[1-9]07199254740991|0[1-9]7199254740991|00[8-9]199254740991|007[2-9]99254740991|007199[3-9]54740991|0071992[6-9]4740991|00719925[5-9]740991|007199254[8-9]40991|0071992547[5-9]0991|00719925474[1-9]991|00719925474099[2-9])))([,\}\]])/g, t = r.replace(e, '$1"$2n"$3');
  return JSON.parse(t, (n, s) => typeof s == "string" && s.match(/^\d+n$/) ? BigInt(s.substring(0, s.length - 1)) : s);
};
function zi(r) {
  if (typeof r != "string")
    throw new Error(`Cannot safe json parse value of type ${typeof r}`);
  try {
    return CM(r);
  } catch {
    return r;
  }
}
function ti(r) {
  return typeof r == "string" ? r : jM(r) || "";
}
var LM = "idb-keyval";
var zM = (r = {}) => {
  const e = r.base && r.base.length > 0 ? `${r.base}:` : "", t = (s) => e + s;
  let n;
  return r.dbName && r.storeName && (n = dg(r.dbName, r.storeName)), { name: LM, options: r, async hasItem(s) {
    return !(typeof await Sd(t(s), n) > "u");
  }, async getItem(s) {
    return await Sd(t(s), n) ?? null;
  }, setItem(s, i) {
    return DM(t(s), i, n);
  }, removeItem(s) {
    return TM(t(s), n);
  }, getKeys() {
    return SM(n);
  }, clear() {
    return AM(n);
  } };
};
var kM = "WALLET_CONNECT_V2_INDEXED_DB";
var UM = "keyvaluestorage";
var PM = class {
  constructor() {
    this.indexedDb = _M({ driver: zM({ dbName: kM, storeName: UM }) });
  }
  async getKeys() {
    return this.indexedDb.getKeys();
  }
  async getEntries() {
    return (await this.indexedDb.getItems(await this.indexedDb.getKeys())).map((e) => [e.key, e.value]);
  }
  async getItem(e) {
    const t = await this.indexedDb.getItem(e);
    if (t !== null) return t;
  }
  async setItem(e, t) {
    await this.indexedDb.setItem(e, ti(t));
  }
  async removeItem(e) {
    await this.indexedDb.removeItem(e);
  }
};
var pc = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
var xo = { exports: {} };
(function() {
  let r;
  function e() {
  }
  r = e, r.prototype.getItem = function(t) {
    return this.hasOwnProperty(t) ? String(this[t]) : null;
  }, r.prototype.setItem = function(t, n) {
    this[t] = String(n);
  }, r.prototype.removeItem = function(t) {
    delete this[t];
  }, r.prototype.clear = function() {
    const t = this;
    Object.keys(t).forEach(function(n) {
      t[n] = void 0, delete t[n];
    });
  }, r.prototype.key = function(t) {
    return t = t || 0, Object.keys(this)[t];
  }, r.prototype.__defineGetter__("length", function() {
    return Object.keys(this).length;
  }), typeof pc < "u" && pc.localStorage ? xo.exports = pc.localStorage : typeof window < "u" && window.localStorage ? xo.exports = window.localStorage : xo.exports = new e();
})();
function BM(r) {
  var e;
  return [r[0], zi((e = r[1]) != null ? e : "")];
}
var RM = class {
  constructor() {
    this.localStorage = xo.exports;
  }
  async getKeys() {
    return Object.keys(this.localStorage);
  }
  async getEntries() {
    return Object.entries(this.localStorage).map(BM);
  }
  async getItem(e) {
    const t = this.localStorage.getItem(e);
    if (t !== null) return zi(t);
  }
  async setItem(e, t) {
    this.localStorage.setItem(e, ti(t));
  }
  async removeItem(e) {
    this.localStorage.removeItem(e);
  }
};
var $M = "wc_storage_version";
var jd = 1;
var FM = async (r, e, t) => {
  const n = $M, s = await e.getItem(n);
  if (s && s >= jd) {
    t(e);
    return;
  }
  const i = await r.getKeys();
  if (!i.length) {
    t(e);
    return;
  }
  const o = [];
  for (; i.length; ) {
    const a = i.shift();
    if (!a) continue;
    const u = a.toLowerCase();
    if (u.includes("wc@") || u.includes("walletconnect") || u.includes("wc_") || u.includes("wallet_connect")) {
      const c = await r.getItem(a);
      await e.setItem(a, c), o.push(a);
    }
  }
  await e.setItem(n, jd), t(e), QM(r, o);
};
var QM = async (r, e) => {
  e.length && e.forEach(async (t) => {
    await r.removeItem(t);
  });
};
var qM = class {
  constructor() {
    this.initialized = false, this.setInitialized = (t) => {
      this.storage = t, this.initialized = true;
    };
    const e = new RM();
    this.storage = e;
    try {
      const t = new PM();
      FM(e, t, this.setInitialized);
    } catch {
      this.initialized = true;
    }
  }
  async getKeys() {
    return await this.initialize(), this.storage.getKeys();
  }
  async getEntries() {
    return await this.initialize(), this.storage.getEntries();
  }
  async getItem(e) {
    return await this.initialize(), this.storage.getItem(e);
  }
  async setItem(e, t) {
    return await this.initialize(), this.storage.setItem(e, t);
  }
  async removeItem(e) {
    return await this.initialize(), this.storage.removeItem(e);
  }
  async initialize() {
    this.initialized || await new Promise((e) => {
      const t = setInterval(() => {
        this.initialized && (clearInterval(t), e());
      }, 20);
    });
  }
};
var La = { exports: {} };
function YM(r) {
  try {
    return JSON.stringify(r);
  } catch {
    return '"[Circular]"';
  }
}
var VM = HM;
function HM(r, e, t) {
  var n = t && t.stringify || YM, s = 1;
  if (typeof r == "object" && r !== null) {
    var i = e.length + s;
    if (i === 1) return r;
    var o = new Array(i);
    o[0] = n(r);
    for (var a = 1; a < i; a++)
      o[a] = n(e[a]);
    return o.join(" ");
  }
  if (typeof r != "string")
    return r;
  var u = e.length;
  if (u === 0) return r;
  for (var c = "", l = 1 - s, d = -1, h = r && r.length || 0, f = 0; f < h; ) {
    if (r.charCodeAt(f) === 37 && f + 1 < h) {
      switch (d = d > -1 ? d : 0, r.charCodeAt(f + 1)) {
        case 100:
        case 102:
          if (l >= u || e[l] == null) break;
          d < f && (c += r.slice(d, f)), c += Number(e[l]), d = f + 2, f++;
          break;
        case 105:
          if (l >= u || e[l] == null) break;
          d < f && (c += r.slice(d, f)), c += Math.floor(Number(e[l])), d = f + 2, f++;
          break;
        case 79:
        case 111:
        case 106:
          if (l >= u || e[l] === void 0) break;
          d < f && (c += r.slice(d, f));
          var g = typeof e[l];
          if (g === "string") {
            c += "'" + e[l] + "'", d = f + 2, f++;
            break;
          }
          if (g === "function") {
            c += e[l].name || "<anonymous>", d = f + 2, f++;
            break;
          }
          c += n(e[l]), d = f + 2, f++;
          break;
        case 115:
          if (l >= u)
            break;
          d < f && (c += r.slice(d, f)), c += String(e[l]), d = f + 2, f++;
          break;
        case 37:
          d < f && (c += r.slice(d, f)), c += "%", d = f + 2, f++, l--;
          break;
      }
      ++l;
    }
    ++f;
  }
  return d === -1 ? r : (d < h && (c += r.slice(d)), c);
}
var Cd = VM;
La.exports = Jr;
var Is = cE().console || {};
var GM = {
  mapHttpRequest: ro,
  mapHttpResponse: ro,
  wrapRequestSerializer: gc,
  wrapResponseSerializer: gc,
  wrapErrorSerializer: gc,
  req: ro,
  res: ro,
  err: zd,
  errWithCause: zd
};
function In(r, e) {
  return r === "silent" ? 1 / 0 : e.levels.values[r];
}
var ol = Symbol("pino.logFuncs");
var lu = Symbol("pino.hierarchy");
var WM = {
  error: "log",
  fatal: "error",
  warn: "error",
  info: "log",
  debug: "log",
  trace: "log"
};
function Ld(r, e) {
  const t = {
    logger: e,
    parent: r[lu]
  };
  e[lu] = t;
}
function KM(r, e, t) {
  const n = {};
  e.forEach((s) => {
    n[s] = t[s] ? t[s] : Is[s] || Is[WM[s] || "log"] || Ai;
  }), r[ol] = n;
}
function XM(r, e) {
  return Array.isArray(r) ? r.filter(function(n) {
    return n !== "!stdSerializers.err";
  }) : r === true ? Object.keys(e) : false;
}
function Jr(r) {
  r = r || {}, r.browser = r.browser || {};
  const e = r.browser.transmit;
  if (e && typeof e.send != "function")
    throw Error("pino: transmit option must have a send function");
  const t = r.browser.write || Is;
  r.browser.write && (r.browser.asObject = true);
  const n = r.serializers || {}, s = XM(r.browser.serialize, n);
  let i = r.browser.serialize;
  Array.isArray(r.browser.serialize) && r.browser.serialize.indexOf("!stdSerializers.err") > -1 && (i = false);
  const o = Object.keys(r.customLevels || {}), a = ["error", "fatal", "warn", "info", "debug", "trace"].concat(o);
  typeof t == "function" && a.forEach(function(p) {
    t[p] = t;
  }), (r.enabled === false || r.browser.disabled) && (r.level = "silent");
  const u = r.level || "info", c = Object.create(t);
  c.log || (c.log = Ai), KM(c, a, t), Ld({}, c), Object.defineProperty(c, "levelVal", {
    get: d
  }), Object.defineProperty(c, "level", {
    get: h,
    set: f
  });
  const l = {
    transmit: e,
    serialize: s,
    asObject: r.browser.asObject,
    asObjectBindingsOnly: r.browser.asObjectBindingsOnly,
    formatters: r.browser.formatters,
    levels: a,
    timestamp: sE(r),
    messageKey: r.messageKey || "msg",
    onChild: r.onChild || Ai
  };
  c.levels = ZM(r), c.level = u, c.isLevelEnabled = function(p) {
    return this.levels.values[p] ? this.levels.values[p] >= this.levels.values[this.level] : false;
  }, c.setMaxListeners = c.getMaxListeners = c.emit = c.addListener = c.on = c.prependListener = c.once = c.prependOnceListener = c.removeListener = c.removeAllListeners = c.listeners = c.listenerCount = c.eventNames = c.write = c.flush = Ai, c.serializers = n, c._serialize = s, c._stdErrSerialize = i, c.child = function(...p) {
    return g.call(this, l, ...p);
  }, e && (c._logEvent = du());
  function d() {
    return In(this.level, this);
  }
  function h() {
    return this._level;
  }
  function f(p) {
    if (p !== "silent" && !this.levels.values[p])
      throw Error("unknown level " + p);
    this._level = p, Bn(this, l, c, "error"), Bn(this, l, c, "fatal"), Bn(this, l, c, "warn"), Bn(this, l, c, "info"), Bn(this, l, c, "debug"), Bn(this, l, c, "trace"), o.forEach((b) => {
      Bn(this, l, c, b);
    });
  }
  function g(p, b, _) {
    if (!b)
      throw new Error("missing bindings for child Pino");
    _ = _ || {}, s && b.serializers && (_.serializers = b.serializers);
    const D = _.serializers;
    if (s && D) {
      var v = Object.assign({}, n, D), E = r.browser.serialize === true ? Object.keys(v) : s;
      delete b.serializers, al([b], E, v, this._stdErrSerialize);
    }
    function A(U) {
      this._childLevel = (U._childLevel | 0) + 1, this.bindings = b, v && (this.serializers = v, this._serialize = E), e && (this._logEvent = du(
        [].concat(U._logEvent.bindings, b)
      ));
    }
    A.prototype = this;
    const k = new A(this);
    return Ld(this, k), k.child = function(...U) {
      return g.call(this, p, ...U);
    }, k.level = _.level || this.level, p.onChild(k), k;
  }
  return c;
}
function ZM(r) {
  const e = r.customLevels || {}, t = Object.assign({}, Jr.levels.values, e), n = Object.assign({}, Jr.levels.labels, JM(e));
  return {
    values: t,
    labels: n
  };
}
function JM(r) {
  const e = {};
  return Object.keys(r).forEach(function(t) {
    e[r[t]] = t;
  }), e;
}
Jr.levels = {
  values: {
    fatal: 60,
    error: 50,
    warn: 40,
    info: 30,
    debug: 20,
    trace: 10
  },
  labels: {
    10: "trace",
    20: "debug",
    30: "info",
    40: "warn",
    50: "error",
    60: "fatal"
  }
};
Jr.stdSerializers = GM;
Jr.stdTimeFunctions = Object.assign({}, { nullTime: hg, epochTime: fg, unixTime: oE, isoTime: aE });
function eE(r) {
  const e = [];
  r.bindings && e.push(r.bindings);
  let t = r[lu];
  for (; t.parent; )
    t = t.parent, t.logger.bindings && e.push(t.logger.bindings);
  return e.reverse();
}
function Bn(r, e, t, n) {
  if (Object.defineProperty(r, n, {
    value: In(r.level, t) > In(n, t) ? Ai : t[ol][n],
    writable: true,
    enumerable: true,
    configurable: true
  }), r[n] === Ai) {
    if (!e.transmit) return;
    const i = e.transmit.level || r.level, o = In(i, t);
    if (In(n, t) < o) return;
  }
  r[n] = rE(r, e, t, n);
  const s = eE(r);
  s.length !== 0 && (r[n] = tE(s, r[n]));
}
function tE(r, e) {
  return function() {
    return e.apply(this, [...r, ...arguments]);
  };
}
function rE(r, e, t, n) {
  return /* @__PURE__ */ function(s) {
    return function() {
      const o = e.timestamp(), a = new Array(arguments.length), u = Object.getPrototypeOf && Object.getPrototypeOf(this) === Is ? Is : this;
      for (var c = 0; c < a.length; c++) a[c] = arguments[c];
      var l = false;
      if (e.serialize && (al(a, this._serialize, this.serializers, this._stdErrSerialize), l = true), e.asObject || e.formatters ? s.call(u, ...nE(this, n, a, o, e)) : s.apply(u, a), e.transmit) {
        const d = e.transmit.level || r._level, h = In(d, t), f = In(n, t);
        if (f < h) return;
        iE(this, {
          ts: o,
          methodLevel: n,
          methodValue: f,
          transmitValue: t.levels.values[e.transmit.level || r._level],
          send: e.transmit.send,
          val: In(r._level, t)
        }, a, l);
      }
    };
  }(r[ol][n]);
}
function nE(r, e, t, n, s) {
  const {
    level: i,
    log: o = (d) => d
  } = s.formatters || {}, a = t.slice();
  let u = a[0];
  const c = {};
  let l = (r._childLevel | 0) + 1;
  if (l < 1 && (l = 1), n && (c.time = n), i) {
    const d = i(e, r.levels.values[e]);
    Object.assign(c, d);
  } else
    c.level = r.levels.values[e];
  if (s.asObjectBindingsOnly) {
    if (u !== null && typeof u == "object")
      for (; l-- && typeof a[0] == "object"; )
        Object.assign(c, a.shift());
    return [o(c), ...a];
  } else {
    if (u !== null && typeof u == "object") {
      for (; l-- && typeof a[0] == "object"; )
        Object.assign(c, a.shift());
      u = a.length ? Cd(a.shift(), a) : void 0;
    } else typeof u == "string" && (u = Cd(a.shift(), a));
    return u !== void 0 && (c[s.messageKey] = u), [o(c)];
  }
}
function al(r, e, t, n) {
  for (const s in r)
    if (n && r[s] instanceof Error)
      r[s] = Jr.stdSerializers.err(r[s]);
    else if (typeof r[s] == "object" && !Array.isArray(r[s]) && e)
      for (const i in r[s])
        e.indexOf(i) > -1 && i in t && (r[s][i] = t[i](r[s][i]));
}
function iE(r, e, t, n = false) {
  const s = e.send, i = e.ts, o = e.methodLevel, a = e.methodValue, u = e.val, c = r._logEvent.bindings;
  n || al(
    t,
    r._serialize || Object.keys(r.serializers),
    r.serializers,
    r._stdErrSerialize === void 0 ? true : r._stdErrSerialize
  ), r._logEvent.ts = i, r._logEvent.messages = t.filter(function(l) {
    return c.indexOf(l) === -1;
  }), r._logEvent.level.label = o, r._logEvent.level.value = a, s(o, r._logEvent, u), r._logEvent = du(c);
}
function du(r) {
  return {
    ts: 0,
    messages: [],
    bindings: r || [],
    level: { label: "", value: 0 }
  };
}
function zd(r) {
  const e = {
    type: r.constructor.name,
    msg: r.message,
    stack: r.stack
  };
  for (const t in r)
    e[t] === void 0 && (e[t] = r[t]);
  return e;
}
function sE(r) {
  return typeof r.timestamp == "function" ? r.timestamp : r.timestamp === false ? hg : fg;
}
function ro() {
  return {};
}
function gc(r) {
  return r;
}
function Ai() {
}
function hg() {
  return false;
}
function fg() {
  return Date.now();
}
function oE() {
  return Math.round(Date.now() / 1e3);
}
function aE() {
  return new Date(Date.now()).toISOString();
}
function cE() {
  function r(e) {
    return typeof e < "u" && e;
  }
  try {
    return typeof globalThis < "u" || Object.defineProperty(Object.prototype, "globalThis", {
      get: function() {
        return delete Object.prototype.globalThis, this.globalThis = this;
      },
      configurable: true
    }), globalThis;
  } catch {
    return r(self) || r(window) || r(this) || {};
  }
}
La.exports.default = Jr;
La.exports.pino = Jr;
var Ii = La.exports;
var pg = Cs(Ii);
var uE = { level: "info" };
var za = "custom_context";
var cl = 1e3 * 1024;
var lE = Object.defineProperty;
var dE = (r, e, t) => e in r ? lE(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;
var Mn = (r, e, t) => dE(r, typeof e != "symbol" ? e + "" : e, t);
var hE = class {
  constructor(e) {
    Mn(this, "nodeValue"), Mn(this, "sizeInBytes"), Mn(this, "next"), this.nodeValue = e, this.sizeInBytes = new TextEncoder().encode(this.nodeValue).length, this.next = null;
  }
  get value() {
    return this.nodeValue;
  }
  get size() {
    return this.sizeInBytes;
  }
};
var kd = class {
  constructor(e) {
    Mn(this, "lengthInNodes"), Mn(this, "sizeInBytes"), Mn(this, "head"), Mn(this, "tail"), Mn(this, "maxSizeInBytes"), this.head = null, this.tail = null, this.lengthInNodes = 0, this.maxSizeInBytes = e, this.sizeInBytes = 0;
  }
  append(e) {
    const t = new hE(e);
    if (t.size > this.maxSizeInBytes) throw new Error(`[LinkedList] Value too big to insert into list: ${e} with size ${t.size}`);
    for (; this.size + t.size > this.maxSizeInBytes; ) this.shift();
    this.head ? (this.tail && (this.tail.next = t), this.tail = t) : (this.head = t, this.tail = t), this.lengthInNodes++, this.sizeInBytes += t.size;
  }
  shift() {
    if (!this.head) return;
    const e = this.head;
    this.head = this.head.next, this.head || (this.tail = null), this.lengthInNodes--, this.sizeInBytes -= e.size;
  }
  toArray() {
    const e = [];
    let t = this.head;
    for (; t !== null; ) e.push(t.value), t = t.next;
    return e;
  }
  get length() {
    return this.lengthInNodes;
  }
  get size() {
    return this.sizeInBytes;
  }
  toOrderedArray() {
    return Array.from(this);
  }
  [Symbol.iterator]() {
    let e = this.head;
    return { next: () => {
      if (!e) return { done: true, value: null };
      const t = e.value;
      return e = e.next, { done: false, value: t };
    } };
  }
};
var fE = Object.defineProperty;
var pE = (r, e, t) => e in r ? fE(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;
var no = (r, e, t) => pE(r, typeof e != "symbol" ? e + "" : e, t);
var gg = class {
  constructor(e, t = cl) {
    no(this, "logs"), no(this, "level"), no(this, "levelValue"), no(this, "MAX_LOG_SIZE_IN_BYTES"), this.level = e ?? "error", this.levelValue = Ii.levels.values[this.level], this.MAX_LOG_SIZE_IN_BYTES = t, this.logs = new kd(this.MAX_LOG_SIZE_IN_BYTES);
  }
  forwardToConsole(e, t) {
    t === Ii.levels.values.error ? console.error(e) : t === Ii.levels.values.warn ? console.warn(e) : t === Ii.levels.values.debug ? console.debug(e) : t === Ii.levels.values.trace ? console.trace(e) : console.log(e);
  }
  appendToLogs(e) {
    this.logs.append(ti({ timestamp: (/* @__PURE__ */ new Date()).toISOString(), log: e }));
    const t = typeof e == "string" ? JSON.parse(e).level : e.level;
    t >= this.levelValue && this.forwardToConsole(e, t);
  }
  getLogs() {
    return this.logs;
  }
  clearLogs() {
    this.logs = new kd(this.MAX_LOG_SIZE_IN_BYTES);
  }
  getLogArray() {
    return Array.from(this.logs);
  }
  logsToBlob(e) {
    const t = this.getLogArray();
    return t.push(ti({ extraMetadata: e })), new Blob(t, { type: "application/json" });
  }
};
var gE = Object.defineProperty;
var yE = (r, e, t) => e in r ? gE(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;
var wE = (r, e, t) => yE(r, e + "", t);
var mE = class {
  constructor(e, t = cl) {
    wE(this, "baseChunkLogger"), this.baseChunkLogger = new gg(e, t);
  }
  write(e) {
    this.baseChunkLogger.appendToLogs(e);
  }
  getLogs() {
    return this.baseChunkLogger.getLogs();
  }
  clearLogs() {
    this.baseChunkLogger.clearLogs();
  }
  getLogArray() {
    return this.baseChunkLogger.getLogArray();
  }
  logsToBlob(e) {
    return this.baseChunkLogger.logsToBlob(e);
  }
  downloadLogsBlobInBrowser(e) {
    const t = URL.createObjectURL(this.logsToBlob(e)), n = document.createElement("a");
    n.href = t, n.download = `walletconnect-logs-${(/* @__PURE__ */ new Date()).toISOString()}.txt`, document.body.appendChild(n), n.click(), document.body.removeChild(n), URL.revokeObjectURL(t);
  }
};
var bE = Object.defineProperty;
var vE = (r, e, t) => e in r ? bE(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;
var ME = (r, e, t) => vE(r, e + "", t);
var EE = class {
  constructor(e, t = cl) {
    ME(this, "baseChunkLogger"), this.baseChunkLogger = new gg(e, t);
  }
  write(e) {
    this.baseChunkLogger.appendToLogs(e);
  }
  getLogs() {
    return this.baseChunkLogger.getLogs();
  }
  clearLogs() {
    this.baseChunkLogger.clearLogs();
  }
  getLogArray() {
    return this.baseChunkLogger.getLogArray();
  }
  logsToBlob(e) {
    return this.baseChunkLogger.logsToBlob(e);
  }
};
var NE = Object.defineProperty;
var xE = Object.defineProperties;
var IE = Object.getOwnPropertyDescriptors;
var Ud = Object.getOwnPropertySymbols;
var _E = Object.prototype.hasOwnProperty;
var DE = Object.prototype.propertyIsEnumerable;
var Pd = (r, e, t) => e in r ? NE(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;
var zo = (r, e) => {
  for (var t in e || (e = {})) _E.call(e, t) && Pd(r, t, e[t]);
  if (Ud) for (var t of Ud(e)) DE.call(e, t) && Pd(r, t, e[t]);
  return r;
};
var ko = (r, e) => xE(r, IE(e));
function TE(r) {
  return ko(zo({}, r), { level: (r == null ? void 0 : r.level) || uE.level });
}
function AE(r, e, t = za) {
  return r[t] = e, r;
}
function Wt(r, e = za) {
  return r[e] || "";
}
function OE(r, e, t = za) {
  const n = Wt(r, t);
  return n.trim() ? `${n}/${e}` : e;
}
function tr(r, e, t = za) {
  const n = OE(r, e, t), s = r.child({ context: n });
  return AE(s, n, t);
}
function SE(r) {
  var e, t;
  const n = new mE((e = r.opts) == null ? void 0 : e.level, r.maxSizeInBytes);
  return { logger: pg(ko(zo({}, r.opts), { level: "trace", browser: ko(zo({}, (t = r.opts) == null ? void 0 : t.browser), { write: (s) => n.write(s) }) })), chunkLoggerController: n };
}
function jE(r) {
  var e;
  const t = new EE((e = r.opts) == null ? void 0 : e.level, r.maxSizeInBytes);
  return { logger: pg(ko(zo({}, r.opts), { level: "trace" }), t), chunkLoggerController: t };
}
function yg(r) {
  return typeof r.loggerOverride < "u" && typeof r.loggerOverride != "string" ? { logger: r.loggerOverride, chunkLoggerController: null } : typeof window < "u" ? SE(r) : jE(r);
}
var CE = Object.defineProperty;
var LE = (r, e, t) => e in r ? CE(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;
var Bd = (r, e, t) => LE(r, typeof e != "symbol" ? e + "" : e, t);
var zE = class extends ci {
  constructor(e) {
    super(), this.opts = e, Bd(this, "protocol", "wc"), Bd(this, "version", 2);
  }
};
var kE = Object.defineProperty;
var UE = (r, e, t) => e in r ? kE(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;
var PE = (r, e, t) => UE(r, e + "", t);
var BE = class extends ci {
  constructor(e, t) {
    super(), this.core = e, this.logger = t, PE(this, "records", /* @__PURE__ */ new Map());
  }
};
var RE = class {
  constructor(e, t) {
    this.logger = e, this.core = t;
  }
};
var $E = class extends ci {
  constructor(e, t) {
    super(), this.relayer = e, this.logger = t;
  }
};
var FE = class extends ci {
  constructor(e) {
    super();
  }
};
var QE = class {
  constructor(e, t, n, s) {
    this.core = e, this.logger = t, this.name = n;
  }
};
var qE = class extends ci {
  constructor(e, t) {
    super(), this.relayer = e, this.logger = t;
  }
};
var YE = class extends ci {
  constructor(e, t) {
    super(), this.core = e, this.logger = t;
  }
};
var VE = class {
  constructor(e, t, n) {
    this.core = e, this.logger = t, this.store = n;
  }
};
var HE = class {
  constructor(e, t) {
    this.projectId = e, this.logger = t;
  }
};
var GE = class {
  constructor(e, t, n) {
    this.core = e, this.logger = t, this.telemetryEnabled = n;
  }
};
var WE = Object.defineProperty;
var KE = (r, e, t) => e in r ? WE(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;
var Rd = (r, e, t) => KE(r, typeof e != "symbol" ? e + "" : e, t);
var XE = class {
  constructor(e) {
    this.opts = e, Rd(this, "protocol", "wc"), Rd(this, "version", 2);
  }
};
var ZE = class {
  constructor(e) {
    this.client = e;
  }
};
function JE(r) {
  return r instanceof Uint8Array || ArrayBuffer.isView(r) && r.constructor.name === "Uint8Array";
}
function wg(r, ...e) {
  if (!JE(r)) throw new Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(r.length)) throw new Error("Uint8Array expected of length " + e + ", got length=" + r.length);
}
function $d(r, e = true) {
  if (r.destroyed) throw new Error("Hash instance has been destroyed");
  if (e && r.finished) throw new Error("Hash#digest() has already been called");
}
function e2(r, e) {
  wg(r);
  const t = e.outputLen;
  if (r.length < t) throw new Error("digestInto() expects output buffer of length at least " + t);
}
var wi = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
var yc = (r) => new DataView(r.buffer, r.byteOffset, r.byteLength);
function t2(r) {
  if (typeof r != "string") throw new Error("utf8ToBytes expected string, got " + typeof r);
  return new Uint8Array(new TextEncoder().encode(r));
}
function mg(r) {
  return typeof r == "string" && (r = t2(r)), wg(r), r;
}
var r2 = class {
  clone() {
    return this._cloneInto();
  }
};
function n2(r) {
  const e = (n) => r().update(mg(n)).digest(), t = r();
  return e.outputLen = t.outputLen, e.blockLen = t.blockLen, e.create = () => r(), e;
}
function bg(r = 32) {
  if (wi && typeof wi.getRandomValues == "function") return wi.getRandomValues(new Uint8Array(r));
  if (wi && typeof wi.randomBytes == "function") return wi.randomBytes(r);
  throw new Error("crypto.getRandomValues must be defined");
}
function i2(r, e, t, n) {
  if (typeof r.setBigUint64 == "function") return r.setBigUint64(e, t, n);
  const s = BigInt(32), i = BigInt(4294967295), o = Number(t >> s & i), a = Number(t & i), u = n ? 4 : 0, c = n ? 0 : 4;
  r.setUint32(e + u, o, n), r.setUint32(e + c, a, n);
}
var s2 = class extends r2 {
  constructor(e, t, n, s) {
    super(), this.blockLen = e, this.outputLen = t, this.padOffset = n, this.isLE = s, this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.buffer = new Uint8Array(e), this.view = yc(this.buffer);
  }
  update(e) {
    $d(this);
    const { view: t, buffer: n, blockLen: s } = this;
    e = mg(e);
    const i = e.length;
    for (let o = 0; o < i; ) {
      const a = Math.min(s - this.pos, i - o);
      if (a === s) {
        const u = yc(e);
        for (; s <= i - o; o += s) this.process(u, o);
        continue;
      }
      n.set(e.subarray(o, o + a), this.pos), this.pos += a, o += a, this.pos === s && (this.process(t, 0), this.pos = 0);
    }
    return this.length += e.length, this.roundClean(), this;
  }
  digestInto(e) {
    $d(this), e2(e, this), this.finished = true;
    const { buffer: t, view: n, blockLen: s, isLE: i } = this;
    let { pos: o } = this;
    t[o++] = 128, this.buffer.subarray(o).fill(0), this.padOffset > s - o && (this.process(n, 0), o = 0);
    for (let d = o; d < s; d++) t[d] = 0;
    i2(n, s - 8, BigInt(this.length * 8), i), this.process(n, 0);
    const a = yc(e), u = this.outputLen;
    if (u % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
    const c = u / 4, l = this.get();
    if (c > l.length) throw new Error("_sha2: outputLen bigger than state");
    for (let d = 0; d < c; d++) a.setUint32(4 * d, l[d], i);
  }
  digest() {
    const { buffer: e, outputLen: t } = this;
    this.digestInto(e);
    const n = e.slice(0, t);
    return this.destroy(), n;
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get());
    const { blockLen: t, buffer: n, length: s, finished: i, destroyed: o, pos: a } = this;
    return e.length = s, e.pos = a, e.finished = i, e.destroyed = o, s % t && e.buffer.set(n), e;
  }
};
var io = BigInt(2 ** 32 - 1);
var hu = BigInt(32);
function vg(r, e = false) {
  return e ? { h: Number(r & io), l: Number(r >> hu & io) } : { h: Number(r >> hu & io) | 0, l: Number(r & io) | 0 };
}
function o2(r, e = false) {
  let t = new Uint32Array(r.length), n = new Uint32Array(r.length);
  for (let s = 0; s < r.length; s++) {
    const { h: i, l: o } = vg(r[s], e);
    [t[s], n[s]] = [i, o];
  }
  return [t, n];
}
var a2 = (r, e) => BigInt(r >>> 0) << hu | BigInt(e >>> 0);
var c2 = (r, e, t) => r >>> t;
var u2 = (r, e, t) => r << 32 - t | e >>> t;
var l2 = (r, e, t) => r >>> t | e << 32 - t;
var d2 = (r, e, t) => r << 32 - t | e >>> t;
var h2 = (r, e, t) => r << 64 - t | e >>> t - 32;
var f2 = (r, e, t) => r >>> t - 32 | e << 64 - t;
var p2 = (r, e) => e;
var g2 = (r, e) => r;
var y2 = (r, e, t) => r << t | e >>> 32 - t;
var w2 = (r, e, t) => e << t | r >>> 32 - t;
var m2 = (r, e, t) => e << t - 32 | r >>> 64 - t;
var b2 = (r, e, t) => r << t - 32 | e >>> 64 - t;
function v2(r, e, t, n) {
  const s = (e >>> 0) + (n >>> 0);
  return { h: r + t + (s / 2 ** 32 | 0) | 0, l: s | 0 };
}
var M2 = (r, e, t) => (r >>> 0) + (e >>> 0) + (t >>> 0);
var E2 = (r, e, t, n) => e + t + n + (r / 2 ** 32 | 0) | 0;
var N2 = (r, e, t, n) => (r >>> 0) + (e >>> 0) + (t >>> 0) + (n >>> 0);
var x2 = (r, e, t, n, s) => e + t + n + s + (r / 2 ** 32 | 0) | 0;
var I2 = (r, e, t, n, s) => (r >>> 0) + (e >>> 0) + (t >>> 0) + (n >>> 0) + (s >>> 0);
var _2 = (r, e, t, n, s, i) => e + t + n + s + i + (r / 2 ** 32 | 0) | 0;
var Ne = { fromBig: vg, split: o2, toBig: a2, shrSH: c2, shrSL: u2, rotrSH: l2, rotrSL: d2, rotrBH: h2, rotrBL: f2, rotr32H: p2, rotr32L: g2, rotlSH: y2, rotlSL: w2, rotlBH: m2, rotlBL: b2, add: v2, add3L: M2, add3H: E2, add4L: N2, add4H: x2, add5H: _2, add5L: I2 };
var [D2, T2] = Ne.split(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map((r) => BigInt(r)));
var rn = new Uint32Array(80);
var nn = new Uint32Array(80);
var A2 = class extends s2 {
  constructor() {
    super(128, 64, 16, false), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
  }
  get() {
    const { Ah: e, Al: t, Bh: n, Bl: s, Ch: i, Cl: o, Dh: a, Dl: u, Eh: c, El: l, Fh: d, Fl: h, Gh: f, Gl: g, Hh: p, Hl: b } = this;
    return [e, t, n, s, i, o, a, u, c, l, d, h, f, g, p, b];
  }
  set(e, t, n, s, i, o, a, u, c, l, d, h, f, g, p, b) {
    this.Ah = e | 0, this.Al = t | 0, this.Bh = n | 0, this.Bl = s | 0, this.Ch = i | 0, this.Cl = o | 0, this.Dh = a | 0, this.Dl = u | 0, this.Eh = c | 0, this.El = l | 0, this.Fh = d | 0, this.Fl = h | 0, this.Gh = f | 0, this.Gl = g | 0, this.Hh = p | 0, this.Hl = b | 0;
  }
  process(e, t) {
    for (let v = 0; v < 16; v++, t += 4) rn[v] = e.getUint32(t), nn[v] = e.getUint32(t += 4);
    for (let v = 16; v < 80; v++) {
      const E = rn[v - 15] | 0, A = nn[v - 15] | 0, k = Ne.rotrSH(E, A, 1) ^ Ne.rotrSH(E, A, 8) ^ Ne.shrSH(E, A, 7), U = Ne.rotrSL(E, A, 1) ^ Ne.rotrSL(E, A, 8) ^ Ne.shrSL(E, A, 7), P = rn[v - 2] | 0, $ = nn[v - 2] | 0, ee = Ne.rotrSH(P, $, 19) ^ Ne.rotrBH(P, $, 61) ^ Ne.shrSH(P, $, 6), G = Ne.rotrSL(P, $, 19) ^ Ne.rotrBL(P, $, 61) ^ Ne.shrSL(P, $, 6), H = Ne.add4L(U, G, nn[v - 7], nn[v - 16]), R = Ne.add4H(H, k, ee, rn[v - 7], rn[v - 16]);
      rn[v] = R | 0, nn[v] = H | 0;
    }
    let { Ah: n, Al: s, Bh: i, Bl: o, Ch: a, Cl: u, Dh: c, Dl: l, Eh: d, El: h, Fh: f, Fl: g, Gh: p, Gl: b, Hh: _, Hl: D } = this;
    for (let v = 0; v < 80; v++) {
      const E = Ne.rotrSH(d, h, 14) ^ Ne.rotrSH(d, h, 18) ^ Ne.rotrBH(d, h, 41), A = Ne.rotrSL(d, h, 14) ^ Ne.rotrSL(d, h, 18) ^ Ne.rotrBL(d, h, 41), k = d & f ^ ~d & p, U = h & g ^ ~h & b, P = Ne.add5L(D, A, U, T2[v], nn[v]), $ = Ne.add5H(P, _, E, k, D2[v], rn[v]), ee = P | 0, G = Ne.rotrSH(n, s, 28) ^ Ne.rotrBH(n, s, 34) ^ Ne.rotrBH(n, s, 39), H = Ne.rotrSL(n, s, 28) ^ Ne.rotrBL(n, s, 34) ^ Ne.rotrBL(n, s, 39), R = n & i ^ n & a ^ i & a, z = s & o ^ s & u ^ o & u;
      _ = p | 0, D = b | 0, p = f | 0, b = g | 0, f = d | 0, g = h | 0, { h: d, l: h } = Ne.add(c | 0, l | 0, $ | 0, ee | 0), c = a | 0, l = u | 0, a = i | 0, u = o | 0, i = n | 0, o = s | 0;
      const j = Ne.add3L(ee, H, z);
      n = Ne.add3H(j, $, G, R), s = j | 0;
    }
    ({ h: n, l: s } = Ne.add(this.Ah | 0, this.Al | 0, n | 0, s | 0)), { h: i, l: o } = Ne.add(this.Bh | 0, this.Bl | 0, i | 0, o | 0), { h: a, l: u } = Ne.add(this.Ch | 0, this.Cl | 0, a | 0, u | 0), { h: c, l } = Ne.add(this.Dh | 0, this.Dl | 0, c | 0, l | 0), { h: d, l: h } = Ne.add(this.Eh | 0, this.El | 0, d | 0, h | 0), { h: f, l: g } = Ne.add(this.Fh | 0, this.Fl | 0, f | 0, g | 0), { h: p, l: b } = Ne.add(this.Gh | 0, this.Gl | 0, p | 0, b | 0), { h: _, l: D } = Ne.add(this.Hh | 0, this.Hl | 0, _ | 0, D | 0), this.set(n, s, i, o, a, u, c, l, d, h, f, g, p, b, _, D);
  }
  roundClean() {
    rn.fill(0), nn.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var O2 = n2(() => new A2());
var ul = BigInt(0);
var Mg = BigInt(1);
var S2 = BigInt(2);
function ll(r) {
  return r instanceof Uint8Array || ArrayBuffer.isView(r) && r.constructor.name === "Uint8Array";
}
function dl(r) {
  if (!ll(r)) throw new Error("Uint8Array expected");
}
function wc(r, e) {
  if (typeof e != "boolean") throw new Error(r + " boolean expected, got " + e);
}
var j2 = Array.from({ length: 256 }, (r, e) => e.toString(16).padStart(2, "0"));
function hl(r) {
  dl(r);
  let e = "";
  for (let t = 0; t < r.length; t++) e += j2[r[t]];
  return e;
}
function Eg(r) {
  if (typeof r != "string") throw new Error("hex string expected, got " + typeof r);
  return r === "" ? ul : BigInt("0x" + r);
}
var zr = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function Fd(r) {
  if (r >= zr._0 && r <= zr._9) return r - zr._0;
  if (r >= zr.A && r <= zr.F) return r - (zr.A - 10);
  if (r >= zr.a && r <= zr.f) return r - (zr.a - 10);
}
function Ng(r) {
  if (typeof r != "string") throw new Error("hex string expected, got " + typeof r);
  const e = r.length, t = e / 2;
  if (e % 2) throw new Error("hex string expected, got unpadded hex of length " + e);
  const n = new Uint8Array(t);
  for (let s = 0, i = 0; s < t; s++, i += 2) {
    const o = Fd(r.charCodeAt(i)), a = Fd(r.charCodeAt(i + 1));
    if (o === void 0 || a === void 0) {
      const u = r[i] + r[i + 1];
      throw new Error('hex string expected, got non-hex character "' + u + '" at index ' + i);
    }
    n[s] = o * 16 + a;
  }
  return n;
}
function C2(r) {
  return Eg(hl(r));
}
function Io(r) {
  return dl(r), Eg(hl(Uint8Array.from(r).reverse()));
}
function xg(r, e) {
  return Ng(r.toString(16).padStart(e * 2, "0"));
}
function fu(r, e) {
  return xg(r, e).reverse();
}
function kr(r, e, t) {
  let n;
  if (typeof e == "string") try {
    n = Ng(e);
  } catch (i) {
    throw new Error(r + " must be hex string or Uint8Array, cause: " + i);
  }
  else if (ll(e)) n = Uint8Array.from(e);
  else throw new Error(r + " must be hex string or Uint8Array");
  const s = n.length;
  if (typeof t == "number" && s !== t) throw new Error(r + " of length " + t + " expected, got " + s);
  return n;
}
function Qd(...r) {
  let e = 0;
  for (let n = 0; n < r.length; n++) {
    const s = r[n];
    dl(s), e += s.length;
  }
  const t = new Uint8Array(e);
  for (let n = 0, s = 0; n < r.length; n++) {
    const i = r[n];
    t.set(i, s), s += i.length;
  }
  return t;
}
var mc = (r) => typeof r == "bigint" && ul <= r;
function L2(r, e, t) {
  return mc(r) && mc(e) && mc(t) && e <= r && r < t;
}
function es(r, e, t, n) {
  if (!L2(e, t, n)) throw new Error("expected valid " + r + ": " + t + " <= n < " + n + ", got " + e);
}
function z2(r) {
  let e;
  for (e = 0; r > ul; r >>= Mg, e += 1) ;
  return e;
}
var k2 = (r) => (S2 << BigInt(r - 1)) - Mg;
var U2 = { bigint: (r) => typeof r == "bigint", function: (r) => typeof r == "function", boolean: (r) => typeof r == "boolean", string: (r) => typeof r == "string", stringOrUint8Array: (r) => typeof r == "string" || ll(r), isSafeInteger: (r) => Number.isSafeInteger(r), array: (r) => Array.isArray(r), field: (r, e) => e.Fp.isValid(r), hash: (r) => typeof r == "function" && Number.isSafeInteger(r.outputLen) };
function fl(r, e, t = {}) {
  const n = (s, i, o) => {
    const a = U2[i];
    if (typeof a != "function") throw new Error("invalid validator function");
    const u = r[s];
    if (!(o && u === void 0) && !a(u, r)) throw new Error("param " + String(s) + " is invalid. Expected " + i + ", got " + u);
  };
  for (const [s, i] of Object.entries(e)) n(s, i, false);
  for (const [s, i] of Object.entries(t)) n(s, i, true);
  return r;
}
function qd(r) {
  const e = /* @__PURE__ */ new WeakMap();
  return (t, ...n) => {
    const s = e.get(t);
    if (s !== void 0) return s;
    const i = r(t, ...n);
    return e.set(t, i), i;
  };
}
var gt = BigInt(0);
var rt = BigInt(1);
var Yn = BigInt(2);
var P2 = BigInt(3);
var pu = BigInt(4);
var Yd = BigInt(5);
var Vd = BigInt(8);
function ct(r, e) {
  const t = r % e;
  return t >= gt ? t : e + t;
}
function B2(r, e, t) {
  if (e < gt) throw new Error("invalid exponent, negatives unsupported");
  if (t <= gt) throw new Error("invalid modulus");
  if (t === rt) return gt;
  let n = rt;
  for (; e > gt; ) e & rt && (n = n * r % t), r = r * r % t, e >>= rt;
  return n;
}
function Nr(r, e, t) {
  let n = r;
  for (; e-- > gt; ) n *= n, n %= t;
  return n;
}
function Hd(r, e) {
  if (r === gt) throw new Error("invert: expected non-zero number");
  if (e <= gt) throw new Error("invert: expected positive modulus, got " + e);
  let t = ct(r, e), n = e, s = gt, i = rt;
  for (; t !== gt; ) {
    const o = n / t, a = n % t, u = s - i * o;
    n = t, t = a, s = i, i = u;
  }
  if (n !== rt) throw new Error("invert: does not exist");
  return ct(s, e);
}
function R2(r) {
  const e = (r - rt) / Yn;
  let t, n, s;
  for (t = r - rt, n = 0; t % Yn === gt; t /= Yn, n++) ;
  for (s = Yn; s < r && B2(s, e, r) !== r - rt; s++) if (s > 1e3) throw new Error("Cannot find square root: likely non-prime P");
  if (n === 1) {
    const o = (r + rt) / pu;
    return function(a, u) {
      const c = a.pow(u, o);
      if (!a.eql(a.sqr(c), u)) throw new Error("Cannot find square root");
      return c;
    };
  }
  const i = (t + rt) / Yn;
  return function(o, a) {
    if (o.pow(a, e) === o.neg(o.ONE)) throw new Error("Cannot find square root");
    let u = n, c = o.pow(o.mul(o.ONE, s), t), l = o.pow(a, i), d = o.pow(a, t);
    for (; !o.eql(d, o.ONE); ) {
      if (o.eql(d, o.ZERO)) return o.ZERO;
      let h = 1;
      for (let g = o.sqr(d); h < u && !o.eql(g, o.ONE); h++) g = o.sqr(g);
      const f = o.pow(c, rt << BigInt(u - h - 1));
      c = o.sqr(f), l = o.mul(l, f), d = o.mul(d, c), u = h;
    }
    return l;
  };
}
function $2(r) {
  if (r % pu === P2) {
    const e = (r + rt) / pu;
    return function(t, n) {
      const s = t.pow(n, e);
      if (!t.eql(t.sqr(s), n)) throw new Error("Cannot find square root");
      return s;
    };
  }
  if (r % Vd === Yd) {
    const e = (r - Yd) / Vd;
    return function(t, n) {
      const s = t.mul(n, Yn), i = t.pow(s, e), o = t.mul(n, i), a = t.mul(t.mul(o, Yn), i), u = t.mul(o, t.sub(a, t.ONE));
      if (!t.eql(t.sqr(u), n)) throw new Error("Cannot find square root");
      return u;
    };
  }
  return R2(r);
}
var F2 = (r, e) => (ct(r, e) & rt) === rt;
var Q2 = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];
function q2(r) {
  const e = { ORDER: "bigint", MASK: "bigint", BYTES: "isSafeInteger", BITS: "isSafeInteger" }, t = Q2.reduce((n, s) => (n[s] = "function", n), e);
  return fl(r, t);
}
function Y2(r, e, t) {
  if (t < gt) throw new Error("invalid exponent, negatives unsupported");
  if (t === gt) return r.ONE;
  if (t === rt) return e;
  let n = r.ONE, s = e;
  for (; t > gt; ) t & rt && (n = r.mul(n, s)), s = r.sqr(s), t >>= rt;
  return n;
}
function V2(r, e) {
  const t = new Array(e.length), n = e.reduce((i, o, a) => r.is0(o) ? i : (t[a] = i, r.mul(i, o)), r.ONE), s = r.inv(n);
  return e.reduceRight((i, o, a) => r.is0(o) ? i : (t[a] = r.mul(i, t[a]), r.mul(i, o)), s), t;
}
function Ig(r, e) {
  const t = e !== void 0 ? e : r.toString(2).length, n = Math.ceil(t / 8);
  return { nBitLength: t, nByteLength: n };
}
function _g(r, e, t = false, n = {}) {
  if (r <= gt) throw new Error("invalid field: expected ORDER > 0, got " + r);
  const { nBitLength: s, nByteLength: i } = Ig(r, e);
  if (i > 2048) throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let o;
  const a = Object.freeze({ ORDER: r, isLE: t, BITS: s, BYTES: i, MASK: k2(s), ZERO: gt, ONE: rt, create: (u) => ct(u, r), isValid: (u) => {
    if (typeof u != "bigint") throw new Error("invalid field element: expected bigint, got " + typeof u);
    return gt <= u && u < r;
  }, is0: (u) => u === gt, isOdd: (u) => (u & rt) === rt, neg: (u) => ct(-u, r), eql: (u, c) => u === c, sqr: (u) => ct(u * u, r), add: (u, c) => ct(u + c, r), sub: (u, c) => ct(u - c, r), mul: (u, c) => ct(u * c, r), pow: (u, c) => Y2(a, u, c), div: (u, c) => ct(u * Hd(c, r), r), sqrN: (u) => u * u, addN: (u, c) => u + c, subN: (u, c) => u - c, mulN: (u, c) => u * c, inv: (u) => Hd(u, r), sqrt: n.sqrt || ((u) => (o || (o = $2(r)), o(a, u))), invertBatch: (u) => V2(a, u), cmov: (u, c, l) => l ? c : u, toBytes: (u) => t ? fu(u, i) : xg(u, i), fromBytes: (u) => {
    if (u.length !== i) throw new Error("Field.fromBytes: expected " + i + " bytes, got " + u.length);
    return t ? Io(u) : C2(u);
  } });
  return Object.freeze(a);
}
var Gd = BigInt(0);
var so = BigInt(1);
function bc(r, e) {
  const t = e.negate();
  return r ? t : e;
}
function Dg(r, e) {
  if (!Number.isSafeInteger(r) || r <= 0 || r > e) throw new Error("invalid window size, expected [1.." + e + "], got W=" + r);
}
function vc(r, e) {
  Dg(r, e);
  const t = Math.ceil(e / r) + 1, n = 2 ** (r - 1);
  return { windows: t, windowSize: n };
}
function H2(r, e) {
  if (!Array.isArray(r)) throw new Error("array expected");
  r.forEach((t, n) => {
    if (!(t instanceof e)) throw new Error("invalid point at index " + n);
  });
}
function G2(r, e) {
  if (!Array.isArray(r)) throw new Error("array of scalars expected");
  r.forEach((t, n) => {
    if (!e.isValid(t)) throw new Error("invalid scalar at index " + n);
  });
}
var Mc = /* @__PURE__ */ new WeakMap();
var Tg = /* @__PURE__ */ new WeakMap();
function Ec(r) {
  return Tg.get(r) || 1;
}
function W2(r, e) {
  return { constTimeNegate: bc, hasPrecomputes(t) {
    return Ec(t) !== 1;
  }, unsafeLadder(t, n, s = r.ZERO) {
    let i = t;
    for (; n > Gd; ) n & so && (s = s.add(i)), i = i.double(), n >>= so;
    return s;
  }, precomputeWindow(t, n) {
    const { windows: s, windowSize: i } = vc(n, e), o = [];
    let a = t, u = a;
    for (let c = 0; c < s; c++) {
      u = a, o.push(u);
      for (let l = 1; l < i; l++) u = u.add(a), o.push(u);
      a = u.double();
    }
    return o;
  }, wNAF(t, n, s) {
    const { windows: i, windowSize: o } = vc(t, e);
    let a = r.ZERO, u = r.BASE;
    const c = BigInt(2 ** t - 1), l = 2 ** t, d = BigInt(t);
    for (let h = 0; h < i; h++) {
      const f = h * o;
      let g = Number(s & c);
      s >>= d, g > o && (g -= l, s += so);
      const p = f, b = f + Math.abs(g) - 1, _ = h % 2 !== 0, D = g < 0;
      g === 0 ? u = u.add(bc(_, n[p])) : a = a.add(bc(D, n[b]));
    }
    return { p: a, f: u };
  }, wNAFUnsafe(t, n, s, i = r.ZERO) {
    const { windows: o, windowSize: a } = vc(t, e), u = BigInt(2 ** t - 1), c = 2 ** t, l = BigInt(t);
    for (let d = 0; d < o; d++) {
      const h = d * a;
      if (s === Gd) break;
      let f = Number(s & u);
      if (s >>= l, f > a && (f -= c, s += so), f === 0) continue;
      let g = n[h + Math.abs(f) - 1];
      f < 0 && (g = g.negate()), i = i.add(g);
    }
    return i;
  }, getPrecomputes(t, n, s) {
    let i = Mc.get(n);
    return i || (i = this.precomputeWindow(n, t), t !== 1 && Mc.set(n, s(i))), i;
  }, wNAFCached(t, n, s) {
    const i = Ec(t);
    return this.wNAF(i, this.getPrecomputes(i, t, s), n);
  }, wNAFCachedUnsafe(t, n, s, i) {
    const o = Ec(t);
    return o === 1 ? this.unsafeLadder(t, n, i) : this.wNAFUnsafe(o, this.getPrecomputes(o, t, s), n, i);
  }, setWindowSize(t, n) {
    Dg(n, e), Tg.set(t, n), Mc.delete(t);
  } };
}
function K2(r, e, t, n) {
  if (H2(t, r), G2(n, e), t.length !== n.length) throw new Error("arrays of points and scalars must have equal length");
  const s = r.ZERO, i = z2(BigInt(t.length)), o = i > 12 ? i - 3 : i > 4 ? i - 2 : i ? 2 : 1, a = (1 << o) - 1, u = new Array(a + 1).fill(s), c = Math.floor((e.BITS - 1) / o) * o;
  let l = s;
  for (let d = c; d >= 0; d -= o) {
    u.fill(s);
    for (let f = 0; f < n.length; f++) {
      const g = n[f], p = Number(g >> BigInt(d) & BigInt(a));
      u[p] = u[p].add(t[f]);
    }
    let h = s;
    for (let f = u.length - 1, g = s; f > 0; f--) g = g.add(u[f]), h = h.add(g);
    if (l = l.add(h), d !== 0) for (let f = 0; f < o; f++) l = l.double();
  }
  return l;
}
function X2(r) {
  return q2(r.Fp), fl(r, { n: "bigint", h: "bigint", Gx: "field", Gy: "field" }, { nBitLength: "isSafeInteger", nByteLength: "isSafeInteger" }), Object.freeze({ ...Ig(r.n, r.nBitLength), ...r, p: r.Fp.ORDER });
}
var pr = BigInt(0);
var Ut = BigInt(1);
var oo = BigInt(2);
var Z2 = BigInt(8);
var J2 = { zip215: true };
function eN(r) {
  const e = X2(r);
  return fl(r, { hash: "function", a: "bigint", d: "bigint", randomBytes: "function" }, { adjustScalarBytes: "function", domain: "function", uvRatio: "function", mapToCurve: "function" }), Object.freeze({ ...e });
}
function tN(r) {
  const e = eN(r), { Fp: t, n, prehash: s, hash: i, randomBytes: o, nByteLength: a, h: u } = e, c = oo << BigInt(a * 8) - Ut, l = t.create, d = _g(e.n, e.nBitLength), h = e.uvRatio || ((j, I) => {
    try {
      return { isValid: true, value: t.sqrt(j * t.inv(I)) };
    } catch {
      return { isValid: false, value: pr };
    }
  }), f = e.adjustScalarBytes || ((j) => j), g = e.domain || ((j, I, y) => {
    if (wc("phflag", y), I.length || y) throw new Error("Contexts/pre-hash are not supported");
    return j;
  });
  function p(j, I) {
    es("coordinate " + j, I, pr, c);
  }
  function b(j) {
    if (!(j instanceof v)) throw new Error("ExtendedPoint expected");
  }
  const _ = qd((j, I) => {
    const { ex: y, ey: m, ez: N } = j, T = j.is0();
    I == null && (I = T ? Z2 : t.inv(N));
    const x = l(y * I), L = l(m * I), V = l(N * I);
    if (T) return { x: pr, y: Ut };
    if (V !== Ut) throw new Error("invZ was invalid");
    return { x, y: L };
  }), D = qd((j) => {
    const { a: I, d: y } = e;
    if (j.is0()) throw new Error("bad point: ZERO");
    const { ex: m, ey: N, ez: T, et: x } = j, L = l(m * m), V = l(N * N), q = l(T * T), K = l(q * q), Z = l(L * I), re = l(q * l(Z + V)), ne = l(K + l(y * l(L * V)));
    if (re !== ne) throw new Error("bad point: equation left != right (1)");
    const se = l(m * N), ue = l(T * x);
    if (se !== ue) throw new Error("bad point: equation left != right (2)");
    return true;
  });
  class v {
    constructor(I, y, m, N) {
      this.ex = I, this.ey = y, this.ez = m, this.et = N, p("x", I), p("y", y), p("z", m), p("t", N), Object.freeze(this);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static fromAffine(I) {
      if (I instanceof v) throw new Error("extended point not allowed");
      const { x: y, y: m } = I || {};
      return p("x", y), p("y", m), new v(y, m, Ut, l(y * m));
    }
    static normalizeZ(I) {
      const y = t.invertBatch(I.map((m) => m.ez));
      return I.map((m, N) => m.toAffine(y[N])).map(v.fromAffine);
    }
    static msm(I, y) {
      return K2(v, d, I, y);
    }
    _setWindowSize(I) {
      k.setWindowSize(this, I);
    }
    assertValidity() {
      D(this);
    }
    equals(I) {
      b(I);
      const { ex: y, ey: m, ez: N } = this, { ex: T, ey: x, ez: L } = I, V = l(y * L), q = l(T * N), K = l(m * L), Z = l(x * N);
      return V === q && K === Z;
    }
    is0() {
      return this.equals(v.ZERO);
    }
    negate() {
      return new v(l(-this.ex), this.ey, this.ez, l(-this.et));
    }
    double() {
      const { a: I } = e, { ex: y, ey: m, ez: N } = this, T = l(y * y), x = l(m * m), L = l(oo * l(N * N)), V = l(I * T), q = y + m, K = l(l(q * q) - T - x), Z = V + x, re = Z - L, ne = V - x, se = l(K * re), ue = l(Z * ne), he = l(K * ne), Q = l(re * Z);
      return new v(se, ue, Q, he);
    }
    add(I) {
      b(I);
      const { a: y, d: m } = e, { ex: N, ey: T, ez: x, et: L } = this, { ex: V, ey: q, ez: K, et: Z } = I;
      if (y === BigInt(-1)) {
        const we = l((T - N) * (q + V)), Ie = l((T + N) * (q - V)), Ee = l(Ie - we);
        if (Ee === pr) return this.double();
        const Me = l(x * oo * Z), Ve = l(L * oo * K), Fe = Ve + Me, xe = Ie + we, _e = Ve - Me, O = l(Fe * Ee), w = l(xe * _e), M = l(Fe * _e), C = l(Ee * xe);
        return new v(O, w, C, M);
      }
      const re = l(N * V), ne = l(T * q), se = l(L * m * Z), ue = l(x * K), he = l((N + T) * (V + q) - re - ne), Q = ue - se, X = ue + se, Y = l(ne - y * re), J = l(he * Q), ie = l(X * Y), fe = l(he * Y), ye = l(Q * X);
      return new v(J, ie, ye, fe);
    }
    subtract(I) {
      return this.add(I.negate());
    }
    wNAF(I) {
      return k.wNAFCached(this, I, v.normalizeZ);
    }
    multiply(I) {
      const y = I;
      es("scalar", y, Ut, n);
      const { p: m, f: N } = this.wNAF(y);
      return v.normalizeZ([m, N])[0];
    }
    multiplyUnsafe(I, y = v.ZERO) {
      const m = I;
      return es("scalar", m, pr, n), m === pr ? A : this.is0() || m === Ut ? this : k.wNAFCachedUnsafe(this, m, v.normalizeZ, y);
    }
    isSmallOrder() {
      return this.multiplyUnsafe(u).is0();
    }
    isTorsionFree() {
      return k.unsafeLadder(this, n).is0();
    }
    toAffine(I) {
      return _(this, I);
    }
    clearCofactor() {
      const { h: I } = e;
      return I === Ut ? this : this.multiplyUnsafe(I);
    }
    static fromHex(I, y = false) {
      const { d: m, a: N } = e, T = t.BYTES;
      I = kr("pointHex", I, T), wc("zip215", y);
      const x = I.slice(), L = I[T - 1];
      x[T - 1] = L & -129;
      const V = Io(x), q = y ? c : t.ORDER;
      es("pointHex.y", V, pr, q);
      const K = l(V * V), Z = l(K - Ut), re = l(m * K - N);
      let { isValid: ne, value: se } = h(Z, re);
      if (!ne) throw new Error("Point.fromHex: invalid y coordinate");
      const ue = (se & Ut) === Ut, he = (L & 128) !== 0;
      if (!y && se === pr && he) throw new Error("Point.fromHex: x=0 and x_0=1");
      return he !== ue && (se = l(-se)), v.fromAffine({ x: se, y: V });
    }
    static fromPrivateKey(I) {
      return $(I).point;
    }
    toRawBytes() {
      const { x: I, y } = this.toAffine(), m = fu(y, t.BYTES);
      return m[m.length - 1] |= I & Ut ? 128 : 0, m;
    }
    toHex() {
      return hl(this.toRawBytes());
    }
  }
  v.BASE = new v(e.Gx, e.Gy, Ut, l(e.Gx * e.Gy)), v.ZERO = new v(pr, Ut, Ut, pr);
  const { BASE: E, ZERO: A } = v, k = W2(v, a * 8);
  function U(j) {
    return ct(j, n);
  }
  function P(j) {
    return U(Io(j));
  }
  function $(j) {
    const I = t.BYTES;
    j = kr("private key", j, I);
    const y = kr("hashed private key", i(j), 2 * I), m = f(y.slice(0, I)), N = y.slice(I, 2 * I), T = P(m), x = E.multiply(T), L = x.toRawBytes();
    return { head: m, prefix: N, scalar: T, point: x, pointBytes: L };
  }
  function ee(j) {
    return $(j).pointBytes;
  }
  function G(j = new Uint8Array(), ...I) {
    const y = Qd(...I);
    return P(i(g(y, kr("context", j), !!s)));
  }
  function H(j, I, y = {}) {
    j = kr("message", j), s && (j = s(j));
    const { prefix: m, scalar: N, pointBytes: T } = $(I), x = G(y.context, m, j), L = E.multiply(x).toRawBytes(), V = G(y.context, L, T, j), q = U(x + V * N);
    es("signature.s", q, pr, n);
    const K = Qd(L, fu(q, t.BYTES));
    return kr("result", K, t.BYTES * 2);
  }
  const R = J2;
  function z(j, I, y, m = R) {
    const { context: N, zip215: T } = m, x = t.BYTES;
    j = kr("signature", j, 2 * x), I = kr("message", I), y = kr("publicKey", y, x), T !== void 0 && wc("zip215", T), s && (I = s(I));
    const L = Io(j.slice(x, 2 * x));
    let V, q, K;
    try {
      V = v.fromHex(y, T), q = v.fromHex(j.slice(0, x), T), K = E.multiplyUnsafe(L);
    } catch {
      return false;
    }
    if (!T && V.isSmallOrder()) return false;
    const Z = G(N, q.toRawBytes(), V.toRawBytes(), I);
    return q.add(V.multiplyUnsafe(Z)).subtract(K).clearCofactor().equals(v.ZERO);
  }
  return E._setWindowSize(8), { CURVE: e, getPublicKey: ee, sign: H, verify: z, ExtendedPoint: v, utils: { getExtendedPublicKey: $, randomPrivateKey: () => o(t.BYTES), precompute(j = 8, I = v.BASE) {
    return I._setWindowSize(j), I.multiply(BigInt(3)), I;
  } } };
}
BigInt(0), BigInt(1);
var pl = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");
var Wd = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
BigInt(0);
var rN = BigInt(1);
var Kd = BigInt(2);
BigInt(3);
var nN = BigInt(5);
var iN = BigInt(8);
function sN(r) {
  const e = BigInt(10), t = BigInt(20), n = BigInt(40), s = BigInt(80), i = pl, o = r * r % i * r % i, a = Nr(o, Kd, i) * o % i, u = Nr(a, rN, i) * r % i, c = Nr(u, nN, i) * u % i, l = Nr(c, e, i) * c % i, d = Nr(l, t, i) * l % i, h = Nr(d, n, i) * d % i, f = Nr(h, s, i) * h % i, g = Nr(f, s, i) * h % i, p = Nr(g, e, i) * c % i;
  return { pow_p_5_8: Nr(p, Kd, i) * r % i, b2: o };
}
function oN(r) {
  return r[0] &= 248, r[31] &= 127, r[31] |= 64, r;
}
function aN(r, e) {
  const t = pl, n = ct(e * e * e, t), s = ct(n * n * e, t), i = sN(r * s).pow_p_5_8;
  let o = ct(r * n * i, t);
  const a = ct(e * o * o, t), u = o, c = ct(o * Wd, t), l = a === r, d = a === ct(-r, t), h = a === ct(-r * Wd, t);
  return l && (o = u), (d || h) && (o = c), F2(o, t) && (o = ct(-o, t)), { isValid: l || d, value: o };
}
var cN = _g(pl, void 0, true);
var uN = { a: BigInt(-1), d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"), Fp: cN, n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"), h: iN, Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"), Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"), hash: O2, randomBytes: bg, adjustScalarBytes: oN, uvRatio: aN };
var Ag = tN(uN);
var lN = "EdDSA";
var dN = "JWT";
var Uo = ".";
var ka = "base64url";
var Og = "utf8";
var Sg = "utf8";
var hN = ":";
var fN = "did";
var pN = "key";
var Xd = "base58btc";
var gN = "z";
var yN = "K36";
var wN = 32;
function gl(r) {
  return globalThis.Buffer != null ? new Uint8Array(r.buffer, r.byteOffset, r.byteLength) : r;
}
function jg(r = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? gl(globalThis.Buffer.allocUnsafe(r)) : new Uint8Array(r);
}
function Cg(r, e) {
  e || (e = r.reduce((s, i) => s + i.length, 0));
  const t = jg(e);
  let n = 0;
  for (const s of r) t.set(s, n), n += s.length;
  return gl(t);
}
function mN(r, e) {
  if (r.length >= 255) throw new TypeError("Alphabet too long");
  for (var t = new Uint8Array(256), n = 0; n < t.length; n++) t[n] = 255;
  for (var s = 0; s < r.length; s++) {
    var i = r.charAt(s), o = i.charCodeAt(0);
    if (t[o] !== 255) throw new TypeError(i + " is ambiguous");
    t[o] = s;
  }
  var a = r.length, u = r.charAt(0), c = Math.log(a) / Math.log(256), l = Math.log(256) / Math.log(a);
  function d(g) {
    if (g instanceof Uint8Array || (ArrayBuffer.isView(g) ? g = new Uint8Array(g.buffer, g.byteOffset, g.byteLength) : Array.isArray(g) && (g = Uint8Array.from(g))), !(g instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (g.length === 0) return "";
    for (var p = 0, b = 0, _ = 0, D = g.length; _ !== D && g[_] === 0; ) _++, p++;
    for (var v = (D - _) * l + 1 >>> 0, E = new Uint8Array(v); _ !== D; ) {
      for (var A = g[_], k = 0, U = v - 1; (A !== 0 || k < b) && U !== -1; U--, k++) A += 256 * E[U] >>> 0, E[U] = A % a >>> 0, A = A / a >>> 0;
      if (A !== 0) throw new Error("Non-zero carry");
      b = k, _++;
    }
    for (var P = v - b; P !== v && E[P] === 0; ) P++;
    for (var $ = u.repeat(p); P < v; ++P) $ += r.charAt(E[P]);
    return $;
  }
  function h(g) {
    if (typeof g != "string") throw new TypeError("Expected String");
    if (g.length === 0) return new Uint8Array();
    var p = 0;
    if (g[p] !== " ") {
      for (var b = 0, _ = 0; g[p] === u; ) b++, p++;
      for (var D = (g.length - p) * c + 1 >>> 0, v = new Uint8Array(D); g[p]; ) {
        var E = t[g.charCodeAt(p)];
        if (E === 255) return;
        for (var A = 0, k = D - 1; (E !== 0 || A < _) && k !== -1; k--, A++) E += a * v[k] >>> 0, v[k] = E % 256 >>> 0, E = E / 256 >>> 0;
        if (E !== 0) throw new Error("Non-zero carry");
        _ = A, p++;
      }
      if (g[p] !== " ") {
        for (var U = D - _; U !== D && v[U] === 0; ) U++;
        for (var P = new Uint8Array(b + (D - U)), $ = b; U !== D; ) P[$++] = v[U++];
        return P;
      }
    }
  }
  function f(g) {
    var p = h(g);
    if (p) return p;
    throw new Error(`Non-${e} character`);
  }
  return { encode: d, decodeUnsafe: h, decode: f };
}
var bN = mN;
var vN = bN;
var Lg = (r) => {
  if (r instanceof Uint8Array && r.constructor.name === "Uint8Array") return r;
  if (r instanceof ArrayBuffer) return new Uint8Array(r);
  if (ArrayBuffer.isView(r)) return new Uint8Array(r.buffer, r.byteOffset, r.byteLength);
  throw new Error("Unknown type, must be binary type");
};
var MN = (r) => new TextEncoder().encode(r);
var EN = (r) => new TextDecoder().decode(r);
var NN = class {
  constructor(e, t, n) {
    this.name = e, this.prefix = t, this.baseEncode = n;
  }
  encode(e) {
    if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
};
var xN = class {
  constructor(e, t, n) {
    if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
    this.prefixCodePoint = t.codePointAt(0), this.baseDecode = n;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else throw Error("Can only multibase decode strings");
  }
  or(e) {
    return zg(this, e);
  }
};
var IN = class {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return zg(this, e);
  }
  decode(e) {
    const t = e[0], n = this.decoders[t];
    if (n) return n.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
var zg = (r, e) => new IN({ ...r.decoders || { [r.prefix]: r }, ...e.decoders || { [e.prefix]: e } });
var _N = class {
  constructor(e, t, n, s) {
    this.name = e, this.prefix = t, this.baseEncode = n, this.baseDecode = s, this.encoder = new NN(e, t, n), this.decoder = new xN(e, t, s);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
};
var Ua = ({ name: r, prefix: e, encode: t, decode: n }) => new _N(r, e, t, n);
var ks = ({ prefix: r, name: e, alphabet: t }) => {
  const { encode: n, decode: s } = vN(t, e);
  return Ua({ prefix: r, name: e, encode: n, decode: (i) => Lg(s(i)) });
};
var DN = (r, e, t, n) => {
  const s = {};
  for (let l = 0; l < e.length; ++l) s[e[l]] = l;
  let i = r.length;
  for (; r[i - 1] === "="; ) --i;
  const o = new Uint8Array(i * t / 8 | 0);
  let a = 0, u = 0, c = 0;
  for (let l = 0; l < i; ++l) {
    const d = s[r[l]];
    if (d === void 0) throw new SyntaxError(`Non-${n} character`);
    u = u << t | d, a += t, a >= 8 && (a -= 8, o[c++] = 255 & u >> a);
  }
  if (a >= t || 255 & u << 8 - a) throw new SyntaxError("Unexpected end of data");
  return o;
};
var TN = (r, e, t) => {
  const n = e[e.length - 1] === "=", s = (1 << t) - 1;
  let i = "", o = 0, a = 0;
  for (let u = 0; u < r.length; ++u) for (a = a << 8 | r[u], o += 8; o > t; ) o -= t, i += e[s & a >> o];
  if (o && (i += e[s & a << t - o]), n) for (; i.length * t & 7; ) i += "=";
  return i;
};
var Mt = ({ name: r, prefix: e, bitsPerChar: t, alphabet: n }) => Ua({ prefix: e, name: r, encode(s) {
  return TN(s, n, t);
}, decode(s) {
  return DN(s, n, t, r);
} });
var AN = Ua({ prefix: "\0", name: "identity", encode: (r) => EN(r), decode: (r) => MN(r) });
var ON = Object.freeze({ __proto__: null, identity: AN });
var SN = Mt({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var jN = Object.freeze({ __proto__: null, base2: SN });
var CN = Mt({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var LN = Object.freeze({ __proto__: null, base8: CN });
var zN = ks({ prefix: "9", name: "base10", alphabet: "0123456789" });
var kN = Object.freeze({ __proto__: null, base10: zN });
var UN = Mt({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 });
var PN = Mt({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var BN = Object.freeze({ __proto__: null, base16: UN, base16upper: PN });
var RN = Mt({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
var $N = Mt({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 });
var FN = Mt({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 });
var QN = Mt({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 });
var qN = Mt({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 });
var YN = Mt({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 });
var VN = Mt({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 });
var HN = Mt({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 });
var GN = Mt({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var WN = Object.freeze({ __proto__: null, base32: RN, base32upper: $N, base32pad: FN, base32padupper: QN, base32hex: qN, base32hexupper: YN, base32hexpad: VN, base32hexpadupper: HN, base32z: GN });
var KN = ks({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" });
var XN = ks({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var ZN = Object.freeze({ __proto__: null, base36: KN, base36upper: XN });
var JN = ks({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
var ex = ks({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var tx = Object.freeze({ __proto__: null, base58btc: JN, base58flickr: ex });
var rx = Mt({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 });
var nx = Mt({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 });
var ix = Mt({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 });
var sx = Mt({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var ox = Object.freeze({ __proto__: null, base64: rx, base64pad: nx, base64url: ix, base64urlpad: sx });
var kg = Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂");
var ax = kg.reduce((r, e, t) => (r[t] = e, r), []);
var cx = kg.reduce((r, e, t) => (r[e.codePointAt(0)] = t, r), []);
function ux(r) {
  return r.reduce((e, t) => (e += ax[t], e), "");
}
function lx(r) {
  const e = [];
  for (const t of r) {
    const n = cx[t.codePointAt(0)];
    if (n === void 0) throw new Error(`Non-base256emoji character: ${t}`);
    e.push(n);
  }
  return new Uint8Array(e);
}
var dx = Ua({ prefix: "🚀", name: "base256emoji", encode: ux, decode: lx });
var hx = Object.freeze({ __proto__: null, base256emoji: dx });
var fx = Ug;
var Zd = 128;
var px = -128;
var gx = Math.pow(2, 31);
function Ug(r, e, t) {
  e = e || [], t = t || 0;
  for (var n = t; r >= gx; ) e[t++] = r & 255 | Zd, r /= 128;
  for (; r & px; ) e[t++] = r & 255 | Zd, r >>>= 7;
  return e[t] = r | 0, Ug.bytes = t - n + 1, e;
}
var yx = gu;
var wx = 128;
var Jd = 127;
function gu(r, n) {
  var t = 0, n = n || 0, s = 0, i = n, o, a = r.length;
  do {
    if (i >= a) throw gu.bytes = 0, new RangeError("Could not decode varint");
    o = r[i++], t += s < 28 ? (o & Jd) << s : (o & Jd) * Math.pow(2, s), s += 7;
  } while (o >= wx);
  return gu.bytes = i - n, t;
}
var mx = Math.pow(2, 7);
var bx = Math.pow(2, 14);
var vx = Math.pow(2, 21);
var Mx = Math.pow(2, 28);
var Ex = Math.pow(2, 35);
var Nx = Math.pow(2, 42);
var xx = Math.pow(2, 49);
var Ix = Math.pow(2, 56);
var _x = Math.pow(2, 63);
var Dx = function(r) {
  return r < mx ? 1 : r < bx ? 2 : r < vx ? 3 : r < Mx ? 4 : r < Ex ? 5 : r < Nx ? 6 : r < xx ? 7 : r < Ix ? 8 : r < _x ? 9 : 10;
};
var Tx = { encode: fx, decode: yx, encodingLength: Dx };
var Pg = Tx;
var eh = (r, e, t = 0) => (Pg.encode(r, e, t), e);
var th = (r) => Pg.encodingLength(r);
var yu = (r, e) => {
  const t = e.byteLength, n = th(r), s = n + th(t), i = new Uint8Array(s + t);
  return eh(r, i, 0), eh(t, i, n), i.set(e, s), new Ax(r, t, e, i);
};
var Ax = class {
  constructor(e, t, n, s) {
    this.code = e, this.size = t, this.digest = n, this.bytes = s;
  }
};
var Bg = ({ name: r, code: e, encode: t }) => new Ox(r, e, t);
var Ox = class {
  constructor(e, t, n) {
    this.name = e, this.code = t, this.encode = n;
  }
  digest(e) {
    if (e instanceof Uint8Array) {
      const t = this.encode(e);
      return t instanceof Uint8Array ? yu(this.code, t) : t.then((n) => yu(this.code, n));
    } else throw Error("Unknown type, must be binary type");
  }
};
var Rg = (r) => async (e) => new Uint8Array(await crypto.subtle.digest(r, e));
var Sx = Bg({ name: "sha2-256", code: 18, encode: Rg("SHA-256") });
var jx = Bg({ name: "sha2-512", code: 19, encode: Rg("SHA-512") });
var Cx = Object.freeze({ __proto__: null, sha256: Sx, sha512: jx });
var $g = 0;
var Lx = "identity";
var Fg = Lg;
var zx = (r) => yu($g, Fg(r));
var kx = { code: $g, name: Lx, encode: Fg, digest: zx };
var Ux = Object.freeze({ __proto__: null, identity: kx });
new TextEncoder(), new TextDecoder();
var rh = { ...ON, ...jN, ...LN, ...kN, ...BN, ...WN, ...ZN, ...tx, ...ox, ...hx };
({ ...Cx, ...Ux });
function Qg(r, e, t, n) {
  return { name: r, prefix: e, encoder: { name: r, prefix: e, encode: t }, decoder: { decode: n } };
}
var nh = Qg("utf8", "u", (r) => "u" + new TextDecoder("utf8").decode(r), (r) => new TextEncoder().encode(r.substring(1)));
var Nc = Qg("ascii", "a", (r) => {
  let e = "a";
  for (let t = 0; t < r.length; t++) e += String.fromCharCode(r[t]);
  return e;
}, (r) => {
  r = r.substring(1);
  const e = jg(r.length);
  for (let t = 0; t < r.length; t++) e[t] = r.charCodeAt(t);
  return e;
});
var qg = { utf8: nh, "utf-8": nh, hex: rh.base16, latin1: Nc, ascii: Nc, binary: Nc, ...rh };
function Pa(r, e = "utf8") {
  const t = qg[e];
  if (!t) throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(r.buffer, r.byteOffset, r.byteLength).toString("utf8") : t.encoder.encode(r).substring(1);
}
function Fi(r, e = "utf8") {
  const t = qg[e];
  if (!t) throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? gl(globalThis.Buffer.from(r, "utf-8")) : t.decoder.decode(`${t.prefix}${r}`);
}
function ih(r) {
  return zi(Pa(Fi(r, ka), Og));
}
function Po(r) {
  return Pa(Fi(ti(r), Og), ka);
}
function Yg(r) {
  const e = Fi(yN, Xd), t = gN + Pa(Cg([e, r]), Xd);
  return [fN, pN, t].join(hN);
}
function Px(r) {
  return Pa(r, ka);
}
function Bx(r) {
  return Fi(r, ka);
}
function Rx(r) {
  return Fi([Po(r.header), Po(r.payload)].join(Uo), Sg);
}
function $x(r) {
  return [Po(r.header), Po(r.payload), Px(r.signature)].join(Uo);
}
function wu(r) {
  const e = r.split(Uo), t = ih(e[0]), n = ih(e[1]), s = Bx(e[2]), i = Fi(e.slice(0, 2).join(Uo), Sg);
  return { header: t, payload: n, signature: s, data: i };
}
function sh(r = bg(wN)) {
  const e = Ag.getPublicKey(r);
  return { secretKey: Cg([r, e]), publicKey: e };
}
async function Fx(r, e, t, n, s = ce.fromMiliseconds(Date.now())) {
  const i = { alg: lN, typ: dN }, o = Yg(n.publicKey), a = s + t, u = { iss: o, sub: r, aud: e, iat: s, exp: a }, c = Rx({ header: i, payload: u }), l = Ag.sign(c, n.secretKey.slice(0, 32));
  return $x({ header: i, payload: u, signature: l });
}
var oh = function(r, e, t) {
  if (t || arguments.length === 2) for (var n = 0, s = e.length, i; n < s; n++)
    (i || !(n in e)) && (i || (i = Array.prototype.slice.call(e, 0, n)), i[n] = e[n]);
  return r.concat(i || Array.prototype.slice.call(e));
};
var Qx = (
  /** @class */
  /* @__PURE__ */ function() {
    function r(e, t, n) {
      this.name = e, this.version = t, this.os = n, this.type = "browser";
    }
    return r;
  }()
);
var qx = (
  /** @class */
  /* @__PURE__ */ function() {
    function r(e) {
      this.version = e, this.type = "node", this.name = "node", this.os = process.platform;
    }
    return r;
  }()
);
var Yx = (
  /** @class */
  /* @__PURE__ */ function() {
    function r(e, t, n, s) {
      this.name = e, this.version = t, this.os = n, this.bot = s, this.type = "bot-device";
    }
    return r;
  }()
);
var Vx = (
  /** @class */
  /* @__PURE__ */ function() {
    function r() {
      this.type = "bot", this.bot = true, this.name = "bot", this.version = null, this.os = null;
    }
    return r;
  }()
);
var Hx = (
  /** @class */
  /* @__PURE__ */ function() {
    function r() {
      this.type = "react-native", this.name = "react-native", this.version = null, this.os = null;
    }
    return r;
  }()
);
var Gx = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
var Wx = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
var ah = 3;
var Kx = [
  ["aol", /AOLShield\/([0-9\._]+)/],
  ["edge", /Edge\/([0-9\._]+)/],
  ["edge-ios", /EdgiOS\/([0-9\._]+)/],
  ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
  ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
  ["samsung", /SamsungBrowser\/([0-9\.]+)/],
  ["silk", /\bSilk\/([0-9._-]+)\b/],
  ["miui", /MiuiBrowser\/([0-9\.]+)$/],
  ["beaker", /BeakerBrowser\/([0-9\.]+)/],
  ["edge-chromium", /EdgA?\/([0-9\.]+)/],
  [
    "chromium-webview",
    /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
  ],
  ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
  ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
  ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
  ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
  ["fxios", /FxiOS\/([0-9\.]+)/],
  ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
  ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
  ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
  ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
  ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
  ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
  ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
  ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
  ["ie", /MSIE\s(7\.0)/],
  ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
  ["android", /Android\s([0-9\.]+)/],
  ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
  ["safari", /Version\/([0-9\._]+).*Safari/],
  ["facebook", /FB[AS]V\/([0-9\.]+)/],
  ["instagram", /Instagram\s([0-9\.]+)/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
  ["curl", /^curl\/([0-9\.]+)$/],
  ["searchbot", Gx]
];
var ch = [
  ["iOS", /iP(hone|od|ad)/],
  ["Android OS", /Android/],
  ["BlackBerry OS", /BlackBerry|BB10/],
  ["Windows Mobile", /IEMobile/],
  ["Amazon OS", /Kindle/],
  ["Windows 3.11", /Win16/],
  ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
  ["Windows 98", /(Windows 98)|(Win98)/],
  ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
  ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
  ["Windows Server 2003", /(Windows NT 5.2)/],
  ["Windows Vista", /(Windows NT 6.0)/],
  ["Windows 7", /(Windows NT 6.1)/],
  ["Windows 8", /(Windows NT 6.2)/],
  ["Windows 8.1", /(Windows NT 6.3)/],
  ["Windows 10", /(Windows NT 10.0)/],
  ["Windows ME", /Windows ME/],
  ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
  ["Open BSD", /OpenBSD/],
  ["Sun OS", /SunOS/],
  ["Chrome OS", /CrOS/],
  ["Linux", /(Linux)|(X11)/],
  ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
  ["QNX", /QNX/],
  ["BeOS", /BeOS/],
  ["OS/2", /OS\/2/]
];
function Xx(r) {
  return typeof document > "u" && typeof navigator < "u" && navigator.product === "ReactNative" ? new Hx() : typeof navigator < "u" ? Jx(navigator.userAgent) : tI();
}
function Zx(r) {
  return r !== "" && Kx.reduce(function(e, t) {
    var n = t[0], s = t[1];
    if (e)
      return e;
    var i = s.exec(r);
    return !!i && [n, i];
  }, false);
}
function Jx(r) {
  var e = Zx(r);
  if (!e)
    return null;
  var t = e[0], n = e[1];
  if (t === "searchbot")
    return new Vx();
  var s = n[1] && n[1].split(".").join("_").split("_").slice(0, 3);
  s ? s.length < ah && (s = oh(oh([], s, true), rI(ah - s.length), true)) : s = [];
  var i = s.join("."), o = eI(r), a = Wx.exec(r);
  return a && a[1] ? new Yx(t, i, o, a[1]) : new Qx(t, i, o);
}
function eI(r) {
  for (var e = 0, t = ch.length; e < t; e++) {
    var n = ch[e], s = n[0], i = n[1], o = i.exec(r);
    if (o)
      return s;
  }
  return null;
}
function tI() {
  var r = typeof process < "u" && process.version;
  return r ? new qx(process.version.slice(1)) : null;
}
function rI(r) {
  for (var e = [], t = 0; t < r; t++)
    e.push("0");
  return e;
}
var qe = {};
Object.defineProperty(qe, "__esModule", { value: true });
qe.getLocalStorage = qe.getLocalStorageOrThrow = qe.getCrypto = qe.getCryptoOrThrow = Vg = qe.getLocation = qe.getLocationOrThrow = yl = qe.getNavigator = qe.getNavigatorOrThrow = ri = qe.getDocument = qe.getDocumentOrThrow = qe.getFromWindowOrThrow = qe.getFromWindow = void 0;
function di(r) {
  let e;
  return typeof window < "u" && typeof window[r] < "u" && (e = window[r]), e;
}
qe.getFromWindow = di;
function Qi(r) {
  const e = di(r);
  if (!e)
    throw new Error(`${r} is not defined in Window`);
  return e;
}
qe.getFromWindowOrThrow = Qi;
function nI() {
  return Qi("document");
}
qe.getDocumentOrThrow = nI;
function iI() {
  return di("document");
}
var ri = qe.getDocument = iI;
function sI() {
  return Qi("navigator");
}
qe.getNavigatorOrThrow = sI;
function oI() {
  return di("navigator");
}
var yl = qe.getNavigator = oI;
function aI() {
  return Qi("location");
}
qe.getLocationOrThrow = aI;
function cI() {
  return di("location");
}
var Vg = qe.getLocation = cI;
function uI() {
  return Qi("crypto");
}
qe.getCryptoOrThrow = uI;
function lI() {
  return di("crypto");
}
qe.getCrypto = lI;
function dI() {
  return Qi("localStorage");
}
qe.getLocalStorageOrThrow = dI;
function hI() {
  return di("localStorage");
}
qe.getLocalStorage = hI;
var wl = {};
Object.defineProperty(wl, "__esModule", { value: true });
var Hg = wl.getWindowMetadata = void 0;
var uh = qe;
function fI() {
  let r, e;
  try {
    r = uh.getDocumentOrThrow(), e = uh.getLocationOrThrow();
  } catch {
    return null;
  }
  function t() {
    const d = r.getElementsByTagName("link"), h = [];
    for (let f = 0; f < d.length; f++) {
      const g = d[f], p = g.getAttribute("rel");
      if (p && p.toLowerCase().indexOf("icon") > -1) {
        const b = g.getAttribute("href");
        if (b)
          if (b.toLowerCase().indexOf("https:") === -1 && b.toLowerCase().indexOf("http:") === -1 && b.indexOf("//") !== 0) {
            let _ = e.protocol + "//" + e.host;
            if (b.indexOf("/") === 0)
              _ += b;
            else {
              const D = e.pathname.split("/");
              D.pop();
              const v = D.join("/");
              _ += v + "/" + b;
            }
            h.push(_);
          } else if (b.indexOf("//") === 0) {
            const _ = e.protocol + b;
            h.push(_);
          } else
            h.push(b);
      }
    }
    return h;
  }
  function n(...d) {
    const h = r.getElementsByTagName("meta");
    for (let f = 0; f < h.length; f++) {
      const g = h[f], p = ["itemprop", "property", "name"].map((b) => g.getAttribute(b)).filter((b) => b ? d.includes(b) : false);
      if (p.length && p) {
        const b = g.getAttribute("content");
        if (b)
          return b;
      }
    }
    return "";
  }
  function s() {
    let d = n("name", "og:site_name", "og:title", "twitter:title");
    return d || (d = r.title), d;
  }
  function i() {
    return n("description", "og:description", "twitter:description", "keywords");
  }
  const o = s(), a = i(), u = e.origin, c = t();
  return {
    description: a,
    url: u,
    icons: c,
    name: o
  };
}
Hg = wl.getWindowMetadata = fI;
var pI = "0.1.1";
function gI() {
  return pI;
}
var He = class _He extends Error {
  constructor(e, t = {}) {
    const n = (() => {
      var u;
      if (t.cause instanceof _He) {
        if (t.cause.details)
          return t.cause.details;
        if (t.cause.shortMessage)
          return t.cause.shortMessage;
      }
      return t.cause && "details" in t.cause && typeof t.cause.details == "string" ? t.cause.details : (u = t.cause) != null && u.message ? t.cause.message : t.details;
    })(), s = t.cause instanceof _He && t.cause.docsPath || t.docsPath, o = `https://oxlib.sh${s ?? ""}`, a = [
      e || "An error occurred.",
      ...t.metaMessages ? ["", ...t.metaMessages] : [],
      ...n || s ? [
        "",
        n ? `Details: ${n}` : void 0,
        s ? `See: ${o}` : void 0
      ] : []
    ].filter((u) => typeof u == "string").join(`
`);
    super(a, t.cause ? { cause: t.cause } : void 0), Object.defineProperty(this, "details", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    }), Object.defineProperty(this, "docs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    }), Object.defineProperty(this, "docsPath", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    }), Object.defineProperty(this, "shortMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    }), Object.defineProperty(this, "cause", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "BaseError"
    }), Object.defineProperty(this, "version", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: `ox@${gI()}`
    }), this.cause = t.cause, this.details = n, this.docs = o, this.docsPath = s, this.shortMessage = e;
  }
  walk(e) {
    return Gg(this, e);
  }
};
function Gg(r, e) {
  return e != null && e(r) ? r : r && typeof r == "object" && "cause" in r && r.cause ? Gg(r.cause, e) : e ? null : r;
}
var mi = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
function yI(r) {
  return r instanceof Uint8Array || ArrayBuffer.isView(r) && r.constructor.name === "Uint8Array";
}
function _s(r) {
  if (!Number.isSafeInteger(r) || r < 0)
    throw new Error("positive integer expected, got " + r);
}
function ni(r, ...e) {
  if (!yI(r))
    throw new Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(r.length))
    throw new Error("Uint8Array expected of length " + e + ", got length=" + r.length);
}
function wI(r) {
  if (typeof r != "function" || typeof r.create != "function")
    throw new Error("Hash should be wrapped by utils.createHasher");
  _s(r.outputLen), _s(r.blockLen);
}
function ki(r, e = true) {
  if (r.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (e && r.finished)
    throw new Error("Hash#digest() has already been called");
}
function Wg(r, e) {
  ni(r);
  const t = e.outputLen;
  if (r.length < t)
    throw new Error("digestInto() expects output buffer of length at least " + t);
}
function mI(r) {
  return new Uint32Array(r.buffer, r.byteOffset, Math.floor(r.byteLength / 4));
}
function Ui(...r) {
  for (let e = 0; e < r.length; e++)
    r[e].fill(0);
}
function xc(r) {
  return new DataView(r.buffer, r.byteOffset, r.byteLength);
}
function xr(r, e) {
  return r << 32 - e | r >>> e;
}
var bI = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function vI(r) {
  return r << 24 & 4278190080 | r << 8 & 16711680 | r >>> 8 & 65280 | r >>> 24 & 255;
}
function MI(r) {
  for (let e = 0; e < r.length; e++)
    r[e] = vI(r[e]);
  return r;
}
var lh = bI ? (r) => r : MI;
function EI(r) {
  if (typeof r != "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(r));
}
function Ba(r) {
  return typeof r == "string" && (r = EI(r)), ni(r), r;
}
function NI(...r) {
  let e = 0;
  for (let n = 0; n < r.length; n++) {
    const s = r[n];
    ni(s), e += s.length;
  }
  const t = new Uint8Array(e);
  for (let n = 0, s = 0; n < r.length; n++) {
    const i = r[n];
    t.set(i, s), s += i.length;
  }
  return t;
}
var ml = class {
};
function Kg(r) {
  const e = (n) => r().update(Ba(n)).digest(), t = r();
  return e.outputLen = t.outputLen, e.blockLen = t.blockLen, e.create = () => r(), e;
}
function xI(r = 32) {
  if (mi && typeof mi.getRandomValues == "function")
    return mi.getRandomValues(new Uint8Array(r));
  if (mi && typeof mi.randomBytes == "function")
    return Uint8Array.from(mi.randomBytes(r));
  throw new Error("crypto.getRandomValues must be defined");
}
function II(r, e, t, n) {
  if (typeof r.setBigUint64 == "function")
    return r.setBigUint64(e, t, n);
  const s = BigInt(32), i = BigInt(4294967295), o = Number(t >> s & i), a = Number(t & i), u = n ? 4 : 0, c = n ? 0 : 4;
  r.setUint32(e + u, o, n), r.setUint32(e + c, a, n);
}
function _I(r, e, t) {
  return r & e ^ ~r & t;
}
function DI(r, e, t) {
  return r & e ^ r & t ^ e & t;
}
var TI = class extends ml {
  constructor(e, t, n, s) {
    super(), this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.blockLen = e, this.outputLen = t, this.padOffset = n, this.isLE = s, this.buffer = new Uint8Array(e), this.view = xc(this.buffer);
  }
  update(e) {
    ki(this), e = Ba(e), ni(e);
    const { view: t, buffer: n, blockLen: s } = this, i = e.length;
    for (let o = 0; o < i; ) {
      const a = Math.min(s - this.pos, i - o);
      if (a === s) {
        const u = xc(e);
        for (; s <= i - o; o += s)
          this.process(u, o);
        continue;
      }
      n.set(e.subarray(o, o + a), this.pos), this.pos += a, o += a, this.pos === s && (this.process(t, 0), this.pos = 0);
    }
    return this.length += e.length, this.roundClean(), this;
  }
  digestInto(e) {
    ki(this), Wg(e, this), this.finished = true;
    const { buffer: t, view: n, blockLen: s, isLE: i } = this;
    let { pos: o } = this;
    t[o++] = 128, Ui(this.buffer.subarray(o)), this.padOffset > s - o && (this.process(n, 0), o = 0);
    for (let d = o; d < s; d++)
      t[d] = 0;
    II(n, s - 8, BigInt(this.length * 8), i), this.process(n, 0);
    const a = xc(e), u = this.outputLen;
    if (u % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const c = u / 4, l = this.get();
    if (c > l.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let d = 0; d < c; d++)
      a.setUint32(4 * d, l[d], i);
  }
  digest() {
    const { buffer: e, outputLen: t } = this;
    this.digestInto(e);
    const n = e.slice(0, t);
    return this.destroy(), n;
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get());
    const { blockLen: t, buffer: n, length: s, finished: i, destroyed: o, pos: a } = this;
    return e.destroyed = o, e.finished = i, e.length = s, e.pos = a, s % t && e.buffer.set(n), e;
  }
  clone() {
    return this._cloneInto();
  }
};
var sn = Uint32Array.from([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var ao = BigInt(2 ** 32 - 1);
var dh = BigInt(32);
function AI(r, e = false) {
  return e ? { h: Number(r & ao), l: Number(r >> dh & ao) } : { h: Number(r >> dh & ao) | 0, l: Number(r & ao) | 0 };
}
function OI(r, e = false) {
  const t = r.length;
  let n = new Uint32Array(t), s = new Uint32Array(t);
  for (let i = 0; i < t; i++) {
    const { h: o, l: a } = AI(r[i], e);
    [n[i], s[i]] = [o, a];
  }
  return [n, s];
}
var SI = (r, e, t) => r << t | e >>> 32 - t;
var jI = (r, e, t) => e << t | r >>> 32 - t;
var CI = (r, e, t) => e << t - 32 | r >>> 64 - t;
var LI = (r, e, t) => r << t - 32 | e >>> 64 - t;
var zI = BigInt(0);
var ts = BigInt(1);
var kI = BigInt(2);
var UI = BigInt(7);
var PI = BigInt(256);
var BI = BigInt(113);
var Xg = [];
var Zg = [];
var Jg = [];
for (let r = 0, e = ts, t = 1, n = 0; r < 24; r++) {
  [t, n] = [n, (2 * t + 3 * n) % 5], Xg.push(2 * (5 * n + t)), Zg.push((r + 1) * (r + 2) / 2 % 64);
  let s = zI;
  for (let i = 0; i < 7; i++)
    e = (e << ts ^ (e >> UI) * BI) % PI, e & kI && (s ^= ts << (ts << BigInt(i)) - ts);
  Jg.push(s);
}
var e0 = OI(Jg, true);
var RI = e0[0];
var $I = e0[1];
var hh = (r, e, t) => t > 32 ? CI(r, e, t) : SI(r, e, t);
var fh = (r, e, t) => t > 32 ? LI(r, e, t) : jI(r, e, t);
function FI(r, e = 24) {
  const t = new Uint32Array(10);
  for (let n = 24 - e; n < 24; n++) {
    for (let o = 0; o < 10; o++)
      t[o] = r[o] ^ r[o + 10] ^ r[o + 20] ^ r[o + 30] ^ r[o + 40];
    for (let o = 0; o < 10; o += 2) {
      const a = (o + 8) % 10, u = (o + 2) % 10, c = t[u], l = t[u + 1], d = hh(c, l, 1) ^ t[a], h = fh(c, l, 1) ^ t[a + 1];
      for (let f = 0; f < 50; f += 10)
        r[o + f] ^= d, r[o + f + 1] ^= h;
    }
    let s = r[2], i = r[3];
    for (let o = 0; o < 24; o++) {
      const a = Zg[o], u = hh(s, i, a), c = fh(s, i, a), l = Xg[o];
      s = r[l], i = r[l + 1], r[l] = u, r[l + 1] = c;
    }
    for (let o = 0; o < 50; o += 10) {
      for (let a = 0; a < 10; a++)
        t[a] = r[o + a];
      for (let a = 0; a < 10; a++)
        r[o + a] ^= ~t[(a + 2) % 10] & t[(a + 4) % 10];
    }
    r[0] ^= RI[n], r[1] ^= $I[n];
  }
  Ui(t);
}
var bl = class _bl extends ml {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(e, t, n, s = false, i = 24) {
    if (super(), this.pos = 0, this.posOut = 0, this.finished = false, this.destroyed = false, this.enableXOF = false, this.blockLen = e, this.suffix = t, this.outputLen = n, this.enableXOF = s, this.rounds = i, _s(n), !(0 < e && e < 200))
      throw new Error("only keccak-f1600 function is supported");
    this.state = new Uint8Array(200), this.state32 = mI(this.state);
  }
  clone() {
    return this._cloneInto();
  }
  keccak() {
    lh(this.state32), FI(this.state32, this.rounds), lh(this.state32), this.posOut = 0, this.pos = 0;
  }
  update(e) {
    ki(this), e = Ba(e), ni(e);
    const { blockLen: t, state: n } = this, s = e.length;
    for (let i = 0; i < s; ) {
      const o = Math.min(t - this.pos, s - i);
      for (let a = 0; a < o; a++)
        n[this.pos++] ^= e[i++];
      this.pos === t && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state: e, suffix: t, pos: n, blockLen: s } = this;
    e[n] ^= t, t & 128 && n === s - 1 && this.keccak(), e[s - 1] ^= 128, this.keccak();
  }
  writeInto(e) {
    ki(this, false), ni(e), this.finish();
    const t = this.state, { blockLen: n } = this;
    for (let s = 0, i = e.length; s < i; ) {
      this.posOut >= n && this.keccak();
      const o = Math.min(n - this.posOut, i - s);
      e.set(t.subarray(this.posOut, this.posOut + o), s), this.posOut += o, s += o;
    }
    return e;
  }
  xofInto(e) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(e);
  }
  xof(e) {
    return _s(e), this.xofInto(new Uint8Array(e));
  }
  digestInto(e) {
    if (Wg(e, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(e), this.destroy(), e;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true, Ui(this.state);
  }
  _cloneInto(e) {
    const { blockLen: t, suffix: n, outputLen: s, rounds: i, enableXOF: o } = this;
    return e || (e = new _bl(t, n, s, o, i)), e.state32.set(this.state32), e.pos = this.pos, e.posOut = this.posOut, e.finished = this.finished, e.rounds = i, e.suffix = n, e.outputLen = s, e.enableXOF = o, e.destroyed = this.destroyed, e;
  }
};
var QI = (r, e, t) => Kg(() => new bl(e, r, t));
var qI = QI(1, 136, 256 / 8);
var YI = Uint32Array.from([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var on = new Uint32Array(64);
var VI = class extends TI {
  constructor(e = 32) {
    super(64, e, 8, false), this.A = sn[0] | 0, this.B = sn[1] | 0, this.C = sn[2] | 0, this.D = sn[3] | 0, this.E = sn[4] | 0, this.F = sn[5] | 0, this.G = sn[6] | 0, this.H = sn[7] | 0;
  }
  get() {
    const { A: e, B: t, C: n, D: s, E: i, F: o, G: a, H: u } = this;
    return [e, t, n, s, i, o, a, u];
  }
  // prettier-ignore
  set(e, t, n, s, i, o, a, u) {
    this.A = e | 0, this.B = t | 0, this.C = n | 0, this.D = s | 0, this.E = i | 0, this.F = o | 0, this.G = a | 0, this.H = u | 0;
  }
  process(e, t) {
    for (let d = 0; d < 16; d++, t += 4)
      on[d] = e.getUint32(t, false);
    for (let d = 16; d < 64; d++) {
      const h = on[d - 15], f = on[d - 2], g = xr(h, 7) ^ xr(h, 18) ^ h >>> 3, p = xr(f, 17) ^ xr(f, 19) ^ f >>> 10;
      on[d] = p + on[d - 7] + g + on[d - 16] | 0;
    }
    let { A: n, B: s, C: i, D: o, E: a, F: u, G: c, H: l } = this;
    for (let d = 0; d < 64; d++) {
      const h = xr(a, 6) ^ xr(a, 11) ^ xr(a, 25), f = l + h + _I(a, u, c) + YI[d] + on[d] | 0, p = (xr(n, 2) ^ xr(n, 13) ^ xr(n, 22)) + DI(n, s, i) | 0;
      l = c, c = u, u = a, a = o + f | 0, o = i, i = s, s = n, n = f + p | 0;
    }
    n = n + this.A | 0, s = s + this.B | 0, i = i + this.C | 0, o = o + this.D | 0, a = a + this.E | 0, u = u + this.F | 0, c = c + this.G | 0, l = l + this.H | 0, this.set(n, s, i, o, a, u, c, l);
  }
  roundClean() {
    Ui(on);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), Ui(this.buffer);
  }
};
var HI = Kg(() => new VI());
var vl = BigInt(0);
var mu = BigInt(1);
function Us(r) {
  return r instanceof Uint8Array || ArrayBuffer.isView(r) && r.constructor.name === "Uint8Array";
}
function Ml(r) {
  if (!Us(r))
    throw new Error("Uint8Array expected");
}
function Ds(r, e) {
  if (typeof e != "boolean")
    throw new Error(r + " boolean expected, got " + e);
}
function co(r) {
  const e = r.toString(16);
  return e.length & 1 ? "0" + e : e;
}
function t0(r) {
  if (typeof r != "string")
    throw new Error("hex string expected, got " + typeof r);
  return r === "" ? vl : BigInt("0x" + r);
}
var r0 = (
  // @ts-ignore
  typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function"
);
var GI = Array.from({ length: 256 }, (r, e) => e.toString(16).padStart(2, "0"));
function Ts(r) {
  if (Ml(r), r0)
    return r.toHex();
  let e = "";
  for (let t = 0; t < r.length; t++)
    e += GI[r[t]];
  return e;
}
var Ur = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function ph(r) {
  if (r >= Ur._0 && r <= Ur._9)
    return r - Ur._0;
  if (r >= Ur.A && r <= Ur.F)
    return r - (Ur.A - 10);
  if (r >= Ur.a && r <= Ur.f)
    return r - (Ur.a - 10);
}
function Bo(r) {
  if (typeof r != "string")
    throw new Error("hex string expected, got " + typeof r);
  if (r0)
    return Uint8Array.fromHex(r);
  const e = r.length, t = e / 2;
  if (e % 2)
    throw new Error("hex string expected, got unpadded hex of length " + e);
  const n = new Uint8Array(t);
  for (let s = 0, i = 0; s < t; s++, i += 2) {
    const o = ph(r.charCodeAt(i)), a = ph(r.charCodeAt(i + 1));
    if (o === void 0 || a === void 0) {
      const u = r[i] + r[i + 1];
      throw new Error('hex string expected, got non-hex character "' + u + '" at index ' + i);
    }
    n[s] = o * 16 + a;
  }
  return n;
}
function Jn(r) {
  return t0(Ts(r));
}
function n0(r) {
  return Ml(r), t0(Ts(Uint8Array.from(r).reverse()));
}
function Ps(r, e) {
  return Bo(r.toString(16).padStart(e * 2, "0"));
}
function i0(r, e) {
  return Ps(r, e).reverse();
}
function cr(r, e, t) {
  let n;
  if (typeof e == "string")
    try {
      n = Bo(e);
    } catch (i) {
      throw new Error(r + " must be hex string or Uint8Array, cause: " + i);
    }
  else if (Us(e))
    n = Uint8Array.from(e);
  else
    throw new Error(r + " must be hex string or Uint8Array");
  const s = n.length;
  if (typeof t == "number" && s !== t)
    throw new Error(r + " of length " + t + " expected, got " + s);
  return n;
}
function Ro(...r) {
  let e = 0;
  for (let n = 0; n < r.length; n++) {
    const s = r[n];
    Ml(s), e += s.length;
  }
  const t = new Uint8Array(e);
  for (let n = 0, s = 0; n < r.length; n++) {
    const i = r[n];
    t.set(i, s), s += i.length;
  }
  return t;
}
var Ic = (r) => typeof r == "bigint" && vl <= r;
function El(r, e, t) {
  return Ic(r) && Ic(e) && Ic(t) && e <= r && r < t;
}
function Oi(r, e, t, n) {
  if (!El(e, t, n))
    throw new Error("expected valid " + r + ": " + t + " <= n < " + n + ", got " + e);
}
function WI(r) {
  let e;
  for (e = 0; r > vl; r >>= mu, e += 1)
    ;
  return e;
}
var Ra = (r) => (mu << BigInt(r)) - mu;
var _c = (r) => new Uint8Array(r);
var gh = (r) => Uint8Array.from(r);
function KI(r, e, t) {
  if (typeof r != "number" || r < 2)
    throw new Error("hashLen must be a number");
  if (typeof e != "number" || e < 2)
    throw new Error("qByteLen must be a number");
  if (typeof t != "function")
    throw new Error("hmacFn must be a function");
  let n = _c(r), s = _c(r), i = 0;
  const o = () => {
    n.fill(1), s.fill(0), i = 0;
  }, a = (...d) => t(s, n, ...d), u = (d = _c(0)) => {
    s = a(gh([0]), d), n = a(), d.length !== 0 && (s = a(gh([1]), d), n = a());
  }, c = () => {
    if (i++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let d = 0;
    const h = [];
    for (; d < e; ) {
      n = a();
      const f = n.slice();
      h.push(f), d += n.length;
    }
    return Ro(...h);
  };
  return (d, h) => {
    o(), u(d);
    let f;
    for (; !(f = h(c())); )
      u();
    return o(), f;
  };
}
var XI = {
  bigint: (r) => typeof r == "bigint",
  function: (r) => typeof r == "function",
  boolean: (r) => typeof r == "boolean",
  string: (r) => typeof r == "string",
  stringOrUint8Array: (r) => typeof r == "string" || Us(r),
  isSafeInteger: (r) => Number.isSafeInteger(r),
  array: (r) => Array.isArray(r),
  field: (r, e) => e.Fp.isValid(r),
  hash: (r) => typeof r == "function" && Number.isSafeInteger(r.outputLen)
};
function $a(r, e, t = {}) {
  const n = (s, i, o) => {
    const a = XI[i];
    if (typeof a != "function")
      throw new Error("invalid validator function");
    const u = r[s];
    if (!(o && u === void 0) && !a(u, r))
      throw new Error("param " + String(s) + " is invalid. Expected " + i + ", got " + u);
  };
  for (const [s, i] of Object.entries(e))
    n(s, i, false);
  for (const [s, i] of Object.entries(t))
    n(s, i, true);
  return r;
}
function yh(r) {
  const e = /* @__PURE__ */ new WeakMap();
  return (t, ...n) => {
    const s = e.get(t);
    if (s !== void 0)
      return s;
    const i = r(t, ...n);
    return e.set(t, i), i;
  };
}
function ZI(r, e) {
  if (vh(r) > e)
    throw new b_({
      givenSize: vh(r),
      maxSize: e
    });
}
var Pr = {
  zero: 48,
  nine: 57,
  A: 65,
  F: 70,
  a: 97,
  f: 102
};
function wh(r) {
  if (r >= Pr.zero && r <= Pr.nine)
    return r - Pr.zero;
  if (r >= Pr.A && r <= Pr.F)
    return r - (Pr.A - 10);
  if (r >= Pr.a && r <= Pr.f)
    return r - (Pr.a - 10);
}
function JI(r, e = {}) {
  const { dir: t, size: n = 32 } = e;
  if (n === 0)
    return r;
  if (r.length > n)
    throw new v_({
      size: r.length,
      targetSize: n,
      type: "Bytes"
    });
  const s = new Uint8Array(n);
  for (let i = 0; i < n; i++) {
    const o = t === "right";
    s[o ? i : n - i - 1] = r[o ? i : r.length - i - 1];
  }
  return s;
}
function s0(r, e) {
  if (An(r) > e)
    throw new u_({
      givenSize: An(r),
      maxSize: e
    });
}
function e_(r, e) {
  if (typeof e == "number" && e > 0 && e > An(r) - 1)
    throw new c0({
      offset: e,
      position: "start",
      size: An(r)
    });
}
function t_(r, e, t) {
  if (typeof e == "number" && typeof t == "number" && An(r) !== t - e)
    throw new c0({
      offset: t,
      position: "end",
      size: An(r)
    });
}
function o0(r, e = {}) {
  const { dir: t, size: n = 32 } = e;
  if (n === 0)
    return r;
  const s = r.replace("0x", "");
  if (s.length > n * 2)
    throw new l_({
      size: Math.ceil(s.length / 2),
      targetSize: n,
      type: "Hex"
    });
  return `0x${s[t === "right" ? "padEnd" : "padStart"](n * 2, "0")}`;
}
var r_ = "#__bigint";
function Nl(r, e, t) {
  return JSON.stringify(r, (n, s) => typeof s == "bigint" ? s.toString() + r_ : s, t);
}
var n_ = Array.from({ length: 256 }, (r, e) => e.toString(16).padStart(2, "0"));
function i_(r, e = {}) {
  const { strict: t = false } = e;
  if (!r)
    throw new mh(r);
  if (typeof r != "string")
    throw new mh(r);
  if (t && !/^0x[0-9a-fA-F]*$/.test(r))
    throw new bh(r);
  if (!r.startsWith("0x"))
    throw new bh(r);
}
function s_(...r) {
  return `0x${r.reduce((e, t) => e + t.replace("0x", ""), "")}`;
}
function xl(r) {
  return r instanceof Uint8Array ? $o(r) : Array.isArray(r) ? $o(new Uint8Array(r)) : r;
}
function $o(r, e = {}) {
  let t = "";
  for (let s = 0; s < r.length; s++)
    t += n_[r[s]];
  const n = `0x${t}`;
  return typeof e.size == "number" ? (s0(n, e.size), a0(n, e.size)) : n;
}
function Dc(r, e = {}) {
  const { signed: t, size: n } = e, s = BigInt(r);
  let i;
  n ? t ? i = (1n << BigInt(n) * 8n - 1n) - 1n : i = 2n ** (BigInt(n) * 8n) - 1n : typeof r == "number" && (i = BigInt(Number.MAX_SAFE_INTEGER));
  const o = typeof i == "bigint" && t ? -i - 1n : 0;
  if (i && s > i || s < o) {
    const c = typeof r == "bigint" ? "n" : "";
    throw new c_({
      max: i ? `${i}${c}` : void 0,
      min: `${o}${c}`,
      signed: t,
      size: n,
      value: `${r}${c}`
    });
  }
  const u = `0x${(t && s < 0 ? (1n << BigInt(n * 8)) + BigInt(s) : s).toString(16)}`;
  return n ? o_(u, n) : u;
}
function o_(r, e) {
  return o0(r, { dir: "left", size: e });
}
function a0(r, e) {
  return o0(r, { dir: "right", size: e });
}
function Yr(r, e, t, n = {}) {
  const { strict: s } = n;
  e_(r, e);
  const i = `0x${r.replace("0x", "").slice((e ?? 0) * 2, (t ?? r.length) * 2)}`;
  return s && t_(i, e, t), i;
}
function An(r) {
  return Math.ceil((r.length - 2) / 2);
}
function a_(r, e = {}) {
  const { strict: t = false } = e;
  try {
    return i_(r, { strict: t }), true;
  } catch {
    return false;
  }
}
var c_ = class extends He {
  constructor({ max: e, min: t, signed: n, size: s, value: i }) {
    super(`Number \`${i}\` is not in safe${s ? ` ${s * 8}-bit` : ""}${n ? " signed" : " unsigned"} integer range ${e ? `(\`${t}\` to \`${e}\`)` : `(above \`${t}\`)`}`), Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Hex.IntegerOutOfRangeError"
    });
  }
};
var mh = class extends He {
  constructor(e) {
    super(`Value \`${typeof e == "object" ? Nl(e) : e}\` of type \`${typeof e}\` is an invalid hex type.`, {
      metaMessages: ['Hex types must be represented as `"0x${string}"`.']
    }), Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Hex.InvalidHexTypeError"
    });
  }
};
var bh = class extends He {
  constructor(e) {
    super(`Value \`${e}\` is an invalid hex value.`, {
      metaMessages: [
        'Hex values must start with `"0x"` and contain only hexadecimal characters (0-9, a-f, A-F).'
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Hex.InvalidHexValueError"
    });
  }
};
var u_ = class extends He {
  constructor({ givenSize: e, maxSize: t }) {
    super(`Size cannot exceed \`${t}\` bytes. Given size: \`${e}\` bytes.`), Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Hex.SizeOverflowError"
    });
  }
};
var c0 = class extends He {
  constructor({ offset: e, position: t, size: n }) {
    super(`Slice ${t === "start" ? "starting" : "ending"} at offset \`${e}\` is out-of-bounds (size: \`${n}\`).`), Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Hex.SliceOffsetOutOfBoundsError"
    });
  }
};
var l_ = class extends He {
  constructor({ size: e, targetSize: t, type: n }) {
    super(`${n.charAt(0).toUpperCase()}${n.slice(1).toLowerCase()} size (\`${e}\`) exceeds padding size (\`${t}\`).`), Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Hex.SizeExceedsPaddingSizeError"
    });
  }
};
var d_ = new TextEncoder();
function h_(r) {
  if (!(r instanceof Uint8Array)) {
    if (!r)
      throw new uo(r);
    if (typeof r != "object")
      throw new uo(r);
    if (!("BYTES_PER_ELEMENT" in r))
      throw new uo(r);
    if (r.BYTES_PER_ELEMENT !== 1 || r.constructor.name !== "Uint8Array")
      throw new uo(r);
  }
}
function f_(r) {
  return r instanceof Uint8Array ? r : typeof r == "string" ? g_(r) : p_(r);
}
function p_(r) {
  return r instanceof Uint8Array ? r : new Uint8Array(r);
}
function g_(r, e = {}) {
  const { size: t } = e;
  let n = r;
  t && (s0(r, t), n = a0(r, t));
  let s = n.slice(2);
  s.length % 2 && (s = `0${s}`);
  const i = s.length / 2, o = new Uint8Array(i);
  for (let a = 0, u = 0; a < i; a++) {
    const c = wh(s.charCodeAt(u++)), l = wh(s.charCodeAt(u++));
    if (c === void 0 || l === void 0)
      throw new He(`Invalid byte sequence ("${s[u - 2]}${s[u - 1]}" in "${s}").`);
    o[a] = c * 16 + l;
  }
  return o;
}
function y_(r, e = {}) {
  const { size: t } = e, n = d_.encode(r);
  return typeof t == "number" ? (ZI(n, t), w_(n, t)) : n;
}
function w_(r, e) {
  return JI(r, { dir: "right", size: e });
}
function vh(r) {
  return r.length;
}
function m_(r) {
  try {
    return h_(r), true;
  } catch {
    return false;
  }
}
var uo = class extends He {
  constructor(e) {
    super(`Value \`${typeof e == "object" ? Nl(e) : e}\` of type \`${typeof e}\` is an invalid Bytes value.`, {
      metaMessages: ["Bytes values must be of type `Bytes`."]
    }), Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Bytes.InvalidBytesTypeError"
    });
  }
};
var b_ = class extends He {
  constructor({ givenSize: e, maxSize: t }) {
    super(`Size cannot exceed \`${t}\` bytes. Given size: \`${e}\` bytes.`), Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Bytes.SizeOverflowError"
    });
  }
};
var v_ = class extends He {
  constructor({ size: e, targetSize: t, type: n }) {
    super(`${n.charAt(0).toUpperCase()}${n.slice(1).toLowerCase()} size (\`${e}\`) exceeds padding size (\`${t}\`).`), Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Bytes.SizeExceedsPaddingSizeError"
    });
  }
};
function u0(r, e = {}) {
  const { as: t = typeof r == "string" ? "Hex" : "Bytes" } = e, n = qI(f_(r));
  return t === "Bytes" ? n : $o(n);
}
var M_ = class extends Map {
  constructor(e) {
    super(), Object.defineProperty(this, "maxSize", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    }), this.maxSize = e;
  }
  get(e) {
    const t = super.get(e);
    return super.has(e) && t !== void 0 && (this.delete(e), super.set(e, t)), t;
  }
  set(e, t) {
    if (super.set(e, t), this.maxSize && this.size > this.maxSize) {
      const n = this.keys().next().value;
      n && this.delete(n);
    }
    return this;
  }
};
var E_ = {
  checksum: new M_(8192)
};
var Tc = E_.checksum;
function l0(r, e = {}) {
  const { compressed: t } = e, { prefix: n, x: s, y: i } = r;
  if (t === false || typeof s == "bigint" && typeof i == "bigint") {
    if (n !== 4)
      throw new Mh({
        prefix: n,
        cause: new T_()
      });
    return;
  }
  if (t === true || typeof s == "bigint" && typeof i > "u") {
    if (n !== 3 && n !== 2)
      throw new Mh({
        prefix: n,
        cause: new D_()
      });
    return;
  }
  throw new __({ publicKey: r });
}
function N_(r) {
  const e = (() => {
    if (a_(r))
      return d0(r);
    if (m_(r))
      return x_(r);
    const { prefix: t, x: n, y: s } = r;
    return typeof n == "bigint" && typeof s == "bigint" ? { prefix: t ?? 4, x: n, y: s } : { prefix: t, x: n };
  })();
  return l0(e), e;
}
function x_(r) {
  return d0($o(r));
}
function d0(r) {
  if (r.length !== 132 && r.length !== 130 && r.length !== 68)
    throw new A_({ publicKey: r });
  if (r.length === 130) {
    const n = BigInt(Yr(r, 0, 32)), s = BigInt(Yr(r, 32, 64));
    return {
      prefix: 4,
      x: n,
      y: s
    };
  }
  if (r.length === 132) {
    const n = Number(Yr(r, 0, 1)), s = BigInt(Yr(r, 1, 33)), i = BigInt(Yr(r, 33, 65));
    return {
      prefix: n,
      x: s,
      y: i
    };
  }
  const e = Number(Yr(r, 0, 1)), t = BigInt(Yr(r, 1, 33));
  return {
    prefix: e,
    x: t
  };
}
function I_(r, e = {}) {
  l0(r);
  const { prefix: t, x: n, y: s } = r, { includePrefix: i = true } = e;
  return s_(
    i ? Dc(t, { size: 1 }) : "0x",
    Dc(n, { size: 32 }),
    // If the public key is not compressed, add the y coordinate.
    typeof s == "bigint" ? Dc(s, { size: 32 }) : "0x"
  );
}
var __ = class extends He {
  constructor({ publicKey: e }) {
    super(`Value \`${Nl(e)}\` is not a valid public key.`, {
      metaMessages: [
        "Public key must contain:",
        "- an `x` and `prefix` value (compressed)",
        "- an `x`, `y`, and `prefix` value (uncompressed)"
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "PublicKey.InvalidError"
    });
  }
};
var Mh = class extends He {
  constructor({ prefix: e, cause: t }) {
    super(`Prefix "${e}" is invalid.`, {
      cause: t
    }), Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "PublicKey.InvalidPrefixError"
    });
  }
};
var D_ = class extends He {
  constructor() {
    super("Prefix must be 2 or 3 for compressed public keys."), Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "PublicKey.InvalidCompressedPrefixError"
    });
  }
};
var T_ = class extends He {
  constructor() {
    super("Prefix must be 4 for uncompressed public keys."), Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "PublicKey.InvalidUncompressedPrefixError"
    });
  }
};
var A_ = class extends He {
  constructor({ publicKey: e }) {
    super(`Value \`${e}\` is an invalid public key size.`, {
      metaMessages: [
        "Expected: 33 bytes (compressed + prefix), 64 bytes (uncompressed) or 65 bytes (uncompressed + prefix).",
        `Received ${An(xl(e))} bytes.`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "PublicKey.InvalidSerializedSizeError"
    });
  }
};
var O_ = /^0x[a-fA-F0-9]{40}$/;
function h0(r, e = {}) {
  const { strict: t = true } = e;
  if (!O_.test(r))
    throw new Eh({
      address: r,
      cause: new C_()
    });
  if (t) {
    if (r.toLowerCase() === r)
      return;
    if (f0(r) !== r)
      throw new Eh({
        address: r,
        cause: new L_()
      });
  }
}
function f0(r) {
  if (Tc.has(r))
    return Tc.get(r);
  h0(r, { strict: false });
  const e = r.substring(2).toLowerCase(), t = u0(y_(e), { as: "Bytes" }), n = e.split("");
  for (let i = 0; i < 40; i += 2)
    t[i >> 1] >> 4 >= 8 && n[i] && (n[i] = n[i].toUpperCase()), (t[i >> 1] & 15) >= 8 && n[i + 1] && (n[i + 1] = n[i + 1].toUpperCase());
  const s = `0x${n.join("")}`;
  return Tc.set(r, s), s;
}
function S_(r, e = {}) {
  const { checksum: t = false } = e;
  return h0(r), t ? f0(r) : r;
}
function j_(r, e = {}) {
  const t = u0(`0x${I_(r).slice(4)}`).substring(26);
  return S_(`0x${t}`, e);
}
var Eh = class extends He {
  constructor({ address: e, cause: t }) {
    super(`Address "${e}" is invalid.`, {
      cause: t
    }), Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Address.InvalidAddressError"
    });
  }
};
var C_ = class extends He {
  constructor() {
    super("Address is not a 20 byte (40 hexadecimal character) value."), Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Address.InvalidInputError"
    });
  }
};
var L_ = class extends He {
  constructor() {
    super("Address does not match its checksum counterpart."), Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Address.InvalidChecksumError"
    });
  }
};
var p0 = class extends ml {
  constructor(e, t) {
    super(), this.finished = false, this.destroyed = false, wI(e);
    const n = Ba(t);
    if (this.iHash = e.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const s = this.blockLen, i = new Uint8Array(s);
    i.set(n.length > s ? e.create().update(n).digest() : n);
    for (let o = 0; o < i.length; o++)
      i[o] ^= 54;
    this.iHash.update(i), this.oHash = e.create();
    for (let o = 0; o < i.length; o++)
      i[o] ^= 106;
    this.oHash.update(i), Ui(i);
  }
  update(e) {
    return ki(this), this.iHash.update(e), this;
  }
  digestInto(e) {
    ki(this), ni(e, this.outputLen), this.finished = true, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy();
  }
  digest() {
    const e = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(e), e;
  }
  _cloneInto(e) {
    e || (e = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: t, iHash: n, finished: s, destroyed: i, blockLen: o, outputLen: a } = this;
    return e = e, e.finished = s, e.destroyed = i, e.blockLen = o, e.outputLen = a, e.oHash = t._cloneInto(e.oHash), e.iHash = n._cloneInto(e.iHash), e;
  }
  clone() {
    return this._cloneInto();
  }
  destroy() {
    this.destroyed = true, this.oHash.destroy(), this.iHash.destroy();
  }
};
var g0 = (r, e, t) => new p0(r, e).update(t).digest();
g0.create = (r, e) => new p0(r, e);
var Yt = BigInt(0);
var Lt = BigInt(1);
var Gn = BigInt(2);
var z_ = BigInt(3);
var y0 = BigInt(4);
var w0 = BigInt(5);
var m0 = BigInt(8);
function Ft(r, e) {
  const t = r % e;
  return t >= Yt ? t : e + t;
}
function nr(r, e, t) {
  let n = r;
  for (; e-- > Yt; )
    n *= n, n %= t;
  return n;
}
function bu(r, e) {
  if (r === Yt)
    throw new Error("invert: expected non-zero number");
  if (e <= Yt)
    throw new Error("invert: expected positive modulus, got " + e);
  let t = Ft(r, e), n = e, s = Yt, i = Lt;
  for (; t !== Yt; ) {
    const a = n / t, u = n % t, c = s - i * a;
    n = t, t = u, s = i, i = c;
  }
  if (n !== Lt)
    throw new Error("invert: does not exist");
  return Ft(s, e);
}
function b0(r, e) {
  const t = (r.ORDER + Lt) / y0, n = r.pow(e, t);
  if (!r.eql(r.sqr(n), e))
    throw new Error("Cannot find square root");
  return n;
}
function k_(r, e) {
  const t = (r.ORDER - w0) / m0, n = r.mul(e, Gn), s = r.pow(n, t), i = r.mul(e, s), o = r.mul(r.mul(i, Gn), s), a = r.mul(i, r.sub(o, r.ONE));
  if (!r.eql(r.sqr(a), e))
    throw new Error("Cannot find square root");
  return a;
}
function U_(r) {
  if (r < BigInt(3))
    throw new Error("sqrt is not defined for small field");
  let e = r - Lt, t = 0;
  for (; e % Gn === Yt; )
    e /= Gn, t++;
  let n = Gn;
  const s = Il(r);
  for (; Nh(s, n) === 1; )
    if (n++ > 1e3)
      throw new Error("Cannot find square root: probably non-prime P");
  if (t === 1)
    return b0;
  let i = s.pow(n, e);
  const o = (e + Lt) / Gn;
  return function(u, c) {
    if (u.is0(c))
      return c;
    if (Nh(u, c) !== 1)
      throw new Error("Cannot find square root");
    let l = t, d = u.mul(u.ONE, i), h = u.pow(c, e), f = u.pow(c, o);
    for (; !u.eql(h, u.ONE); ) {
      if (u.is0(h))
        return u.ZERO;
      let g = 1, p = u.sqr(h);
      for (; !u.eql(p, u.ONE); )
        if (g++, p = u.sqr(p), g === l)
          throw new Error("Cannot find square root");
      const b = Lt << BigInt(l - g - 1), _ = u.pow(d, b);
      l = g, d = u.sqr(_), h = u.mul(h, d), f = u.mul(f, _);
    }
    return f;
  };
}
function P_(r) {
  return r % y0 === z_ ? b0 : r % m0 === w0 ? k_ : U_(r);
}
var B_ = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function R_(r) {
  const e = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  }, t = B_.reduce((n, s) => (n[s] = "function", n), e);
  return $a(r, t);
}
function $_(r, e, t) {
  if (t < Yt)
    throw new Error("invalid exponent, negatives unsupported");
  if (t === Yt)
    return r.ONE;
  if (t === Lt)
    return e;
  let n = r.ONE, s = e;
  for (; t > Yt; )
    t & Lt && (n = r.mul(n, s)), s = r.sqr(s), t >>= Lt;
  return n;
}
function v0(r, e, t = false) {
  const n = new Array(e.length).fill(t ? r.ZERO : void 0), s = e.reduce((o, a, u) => r.is0(a) ? o : (n[u] = o, r.mul(o, a)), r.ONE), i = r.inv(s);
  return e.reduceRight((o, a, u) => r.is0(a) ? o : (n[u] = r.mul(o, n[u]), r.mul(o, a)), i), n;
}
function Nh(r, e) {
  const t = (r.ORDER - Lt) / Gn, n = r.pow(e, t), s = r.eql(n, r.ONE), i = r.eql(n, r.ZERO), o = r.eql(n, r.neg(r.ONE));
  if (!s && !i && !o)
    throw new Error("invalid Legendre symbol result");
  return s ? 1 : i ? 0 : -1;
}
function M0(r, e) {
  e !== void 0 && _s(e);
  const t = e !== void 0 ? e : r.toString(2).length, n = Math.ceil(t / 8);
  return { nBitLength: t, nByteLength: n };
}
function Il(r, e, t = false, n = {}) {
  if (r <= Yt)
    throw new Error("invalid field: expected ORDER > 0, got " + r);
  const { nBitLength: s, nByteLength: i } = M0(r, e);
  if (i > 2048)
    throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let o;
  const a = Object.freeze({
    ORDER: r,
    isLE: t,
    BITS: s,
    BYTES: i,
    MASK: Ra(s),
    ZERO: Yt,
    ONE: Lt,
    create: (u) => Ft(u, r),
    isValid: (u) => {
      if (typeof u != "bigint")
        throw new Error("invalid field element: expected bigint, got " + typeof u);
      return Yt <= u && u < r;
    },
    is0: (u) => u === Yt,
    isOdd: (u) => (u & Lt) === Lt,
    neg: (u) => Ft(-u, r),
    eql: (u, c) => u === c,
    sqr: (u) => Ft(u * u, r),
    add: (u, c) => Ft(u + c, r),
    sub: (u, c) => Ft(u - c, r),
    mul: (u, c) => Ft(u * c, r),
    pow: (u, c) => $_(a, u, c),
    div: (u, c) => Ft(u * bu(c, r), r),
    // Same as above, but doesn't normalize
    sqrN: (u) => u * u,
    addN: (u, c) => u + c,
    subN: (u, c) => u - c,
    mulN: (u, c) => u * c,
    inv: (u) => bu(u, r),
    sqrt: n.sqrt || ((u) => (o || (o = P_(r)), o(a, u))),
    toBytes: (u) => t ? i0(u, i) : Ps(u, i),
    fromBytes: (u) => {
      if (u.length !== i)
        throw new Error("Field.fromBytes: expected " + i + " bytes, got " + u.length);
      return t ? n0(u) : Jn(u);
    },
    // TODO: we don't need it here, move out to separate fn
    invertBatch: (u) => v0(a, u),
    // We can't move this out because Fp6, Fp12 implement it
    // and it's unclear what to return in there.
    cmov: (u, c, l) => l ? c : u
  });
  return Object.freeze(a);
}
function E0(r) {
  if (typeof r != "bigint")
    throw new Error("field order must be bigint");
  const e = r.toString(2).length;
  return Math.ceil(e / 8);
}
function N0(r) {
  const e = E0(r);
  return e + Math.ceil(e / 2);
}
function F_(r, e, t = false) {
  const n = r.length, s = E0(e), i = N0(e);
  if (n < 16 || n < i || n > 1024)
    throw new Error("expected " + i + "-1024 bytes of input, got " + n);
  const o = t ? n0(r) : Jn(r), a = Ft(o, e - Lt) + Lt;
  return t ? i0(a, s) : Ps(a, s);
}
var xh = BigInt(0);
var vu = BigInt(1);
function Ac(r, e) {
  const t = e.negate();
  return r ? t : e;
}
function x0(r, e) {
  if (!Number.isSafeInteger(r) || r <= 0 || r > e)
    throw new Error("invalid window size, expected [1.." + e + "], got W=" + r);
}
function Oc(r, e) {
  x0(r, e);
  const t = Math.ceil(e / r) + 1, n = 2 ** (r - 1), s = 2 ** r, i = Ra(r), o = BigInt(r);
  return { windows: t, windowSize: n, mask: i, maxNumber: s, shiftBy: o };
}
function Ih(r, e, t) {
  const { windowSize: n, mask: s, maxNumber: i, shiftBy: o } = t;
  let a = Number(r & s), u = r >> o;
  a > n && (a -= i, u += vu);
  const c = e * n, l = c + Math.abs(a) - 1, d = a === 0, h = a < 0, f = e % 2 !== 0;
  return { nextN: u, offset: l, isZero: d, isNeg: h, isNegF: f, offsetF: c };
}
function Q_(r, e) {
  if (!Array.isArray(r))
    throw new Error("array expected");
  r.forEach((t, n) => {
    if (!(t instanceof e))
      throw new Error("invalid point at index " + n);
  });
}
function q_(r, e) {
  if (!Array.isArray(r))
    throw new Error("array of scalars expected");
  r.forEach((t, n) => {
    if (!e.isValid(t))
      throw new Error("invalid scalar at index " + n);
  });
}
var Sc = /* @__PURE__ */ new WeakMap();
var I0 = /* @__PURE__ */ new WeakMap();
function jc(r) {
  return I0.get(r) || 1;
}
function Y_(r, e) {
  return {
    constTimeNegate: Ac,
    hasPrecomputes(t) {
      return jc(t) !== 1;
    },
    // non-const time multiplication ladder
    unsafeLadder(t, n, s = r.ZERO) {
      let i = t;
      for (; n > xh; )
        n & vu && (s = s.add(i)), i = i.double(), n >>= vu;
      return s;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
     * - 𝑊 is the window size
     * - 𝑛 is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @param elm Point instance
     * @param W window size
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(t, n) {
      const { windows: s, windowSize: i } = Oc(n, e), o = [];
      let a = t, u = a;
      for (let c = 0; c < s; c++) {
        u = a, o.push(u);
        for (let l = 1; l < i; l++)
          u = u.add(a), o.push(u);
        a = u.double();
      }
      return o;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(t, n, s) {
      let i = r.ZERO, o = r.BASE;
      const a = Oc(t, e);
      for (let u = 0; u < a.windows; u++) {
        const { nextN: c, offset: l, isZero: d, isNeg: h, isNegF: f, offsetF: g } = Ih(s, u, a);
        s = c, d ? o = o.add(Ac(f, n[g])) : i = i.add(Ac(h, n[l]));
      }
      return { p: i, f: o };
    },
    /**
     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @param acc accumulator point to add result of multiplication
     * @returns point
     */
    wNAFUnsafe(t, n, s, i = r.ZERO) {
      const o = Oc(t, e);
      for (let a = 0; a < o.windows && s !== xh; a++) {
        const { nextN: u, offset: c, isZero: l, isNeg: d } = Ih(s, a, o);
        if (s = u, !l) {
          const h = n[c];
          i = i.add(d ? h.negate() : h);
        }
      }
      return i;
    },
    getPrecomputes(t, n, s) {
      let i = Sc.get(n);
      return i || (i = this.precomputeWindow(n, t), t !== 1 && Sc.set(n, s(i))), i;
    },
    wNAFCached(t, n, s) {
      const i = jc(t);
      return this.wNAF(i, this.getPrecomputes(i, t, s), n);
    },
    wNAFCachedUnsafe(t, n, s, i) {
      const o = jc(t);
      return o === 1 ? this.unsafeLadder(t, n, i) : this.wNAFUnsafe(o, this.getPrecomputes(o, t, s), n, i);
    },
    // We calculate precomputes for elliptic curve point multiplication
    // using windowed method. This specifies window size and
    // stores precomputed values. Usually only base point would be precomputed.
    setWindowSize(t, n) {
      x0(n, e), I0.set(t, n), Sc.delete(t);
    }
  };
}
function V_(r, e, t, n) {
  Q_(t, r), q_(n, e);
  const s = t.length, i = n.length;
  if (s !== i)
    throw new Error("arrays of points and scalars must have equal length");
  const o = r.ZERO, a = WI(BigInt(s));
  let u = 1;
  a > 12 ? u = a - 3 : a > 4 ? u = a - 2 : a > 0 && (u = 2);
  const c = Ra(u), l = new Array(Number(c) + 1).fill(o), d = Math.floor((e.BITS - 1) / u) * u;
  let h = o;
  for (let f = d; f >= 0; f -= u) {
    l.fill(o);
    for (let p = 0; p < i; p++) {
      const b = n[p], _ = Number(b >> BigInt(f) & c);
      l[_] = l[_].add(t[p]);
    }
    let g = o;
    for (let p = l.length - 1, b = o; p > 0; p--)
      b = b.add(l[p]), g = g.add(b);
    if (h = h.add(g), f !== 0)
      for (let p = 0; p < u; p++)
        h = h.double();
  }
  return h;
}
function _0(r) {
  return R_(r.Fp), $a(r, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  }), Object.freeze({
    ...M0(r.n, r.nBitLength),
    ...r,
    p: r.Fp.ORDER
  });
}
function _h(r) {
  r.lowS !== void 0 && Ds("lowS", r.lowS), r.prehash !== void 0 && Ds("prehash", r.prehash);
}
function H_(r) {
  const e = _0(r);
  $a(e, {
    a: "field",
    b: "field"
  }, {
    allowInfinityPoint: "boolean",
    allowedPrivateKeyLengths: "array",
    clearCofactor: "function",
    fromBytes: "function",
    isTorsionFree: "function",
    toBytes: "function",
    wrapPrivateKey: "boolean"
  });
  const { endo: t, Fp: n, a: s } = e;
  if (t) {
    if (!n.eql(s, n.ZERO))
      throw new Error("invalid endo: CURVE.a must be 0");
    if (typeof t != "object" || typeof t.beta != "bigint" || typeof t.splitScalar != "function")
      throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function');
  }
  return Object.freeze({ ...e });
}
var G_ = class extends Error {
  constructor(e = "") {
    super(e);
  }
};
var Vr = {
  // asn.1 DER encoding utils
  Err: G_,
  // Basic building block is TLV (Tag-Length-Value)
  _tlv: {
    encode: (r, e) => {
      const { Err: t } = Vr;
      if (r < 0 || r > 256)
        throw new t("tlv.encode: wrong tag");
      if (e.length & 1)
        throw new t("tlv.encode: unpadded data");
      const n = e.length / 2, s = co(n);
      if (s.length / 2 & 128)
        throw new t("tlv.encode: long form length too big");
      const i = n > 127 ? co(s.length / 2 | 128) : "";
      return co(r) + i + s + e;
    },
    // v - value, l - left bytes (unparsed)
    decode(r, e) {
      const { Err: t } = Vr;
      let n = 0;
      if (r < 0 || r > 256)
        throw new t("tlv.encode: wrong tag");
      if (e.length < 2 || e[n++] !== r)
        throw new t("tlv.decode: wrong tlv");
      const s = e[n++], i = !!(s & 128);
      let o = 0;
      if (!i)
        o = s;
      else {
        const u = s & 127;
        if (!u)
          throw new t("tlv.decode(long): indefinite length not supported");
        if (u > 4)
          throw new t("tlv.decode(long): byte length is too big");
        const c = e.subarray(n, n + u);
        if (c.length !== u)
          throw new t("tlv.decode: length bytes not complete");
        if (c[0] === 0)
          throw new t("tlv.decode(long): zero leftmost byte");
        for (const l of c)
          o = o << 8 | l;
        if (n += u, o < 128)
          throw new t("tlv.decode(long): not minimal encoding");
      }
      const a = e.subarray(n, n + o);
      if (a.length !== o)
        throw new t("tlv.decode: wrong value length");
      return { v: a, l: e.subarray(n + o) };
    }
  },
  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
  // since we always use positive integers here. It must always be empty:
  // - add zero byte if exists
  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
  _int: {
    encode(r) {
      const { Err: e } = Vr;
      if (r < Wr)
        throw new e("integer: negative integers are not allowed");
      let t = co(r);
      if (Number.parseInt(t[0], 16) & 8 && (t = "00" + t), t.length & 1)
        throw new e("unexpected DER parsing assertion: unpadded hex");
      return t;
    },
    decode(r) {
      const { Err: e } = Vr;
      if (r[0] & 128)
        throw new e("invalid signature integer: negative");
      if (r[0] === 0 && !(r[1] & 128))
        throw new e("invalid signature integer: unnecessary leading zero");
      return Jn(r);
    }
  },
  toSig(r) {
    const { Err: e, _int: t, _tlv: n } = Vr, s = cr("signature", r), { v: i, l: o } = n.decode(48, s);
    if (o.length)
      throw new e("invalid signature: left bytes after parsing");
    const { v: a, l: u } = n.decode(2, i), { v: c, l } = n.decode(2, u);
    if (l.length)
      throw new e("invalid signature: left bytes after parsing");
    return { r: t.decode(a), s: t.decode(c) };
  },
  hexFromSig(r) {
    const { _tlv: e, _int: t } = Vr, n = e.encode(2, t.encode(r.r)), s = e.encode(2, t.encode(r.s)), i = n + s;
    return e.encode(48, i);
  }
};
function Cc(r, e) {
  return Ts(Ps(r, e));
}
var Wr = BigInt(0);
var pt = BigInt(1);
BigInt(2);
var Lc = BigInt(3);
var W_ = BigInt(4);
function K_(r) {
  const e = H_(r), { Fp: t } = e, n = Il(e.n, e.nBitLength), s = e.toBytes || ((v, E, A) => {
    const k = E.toAffine();
    return Ro(Uint8Array.from([4]), t.toBytes(k.x), t.toBytes(k.y));
  }), i = e.fromBytes || ((v) => {
    const E = v.subarray(1), A = t.fromBytes(E.subarray(0, t.BYTES)), k = t.fromBytes(E.subarray(t.BYTES, 2 * t.BYTES));
    return { x: A, y: k };
  });
  function o(v) {
    const { a: E, b: A } = e, k = t.sqr(v), U = t.mul(k, v);
    return t.add(t.add(U, t.mul(v, E)), A);
  }
  function a(v, E) {
    const A = t.sqr(E), k = o(v);
    return t.eql(A, k);
  }
  if (!a(e.Gx, e.Gy))
    throw new Error("bad curve params: generator point");
  const u = t.mul(t.pow(e.a, Lc), W_), c = t.mul(t.sqr(e.b), BigInt(27));
  if (t.is0(t.add(u, c)))
    throw new Error("bad curve params: a or b");
  function l(v) {
    return El(v, pt, e.n);
  }
  function d(v) {
    const { allowedPrivateKeyLengths: E, nByteLength: A, wrapPrivateKey: k, n: U } = e;
    if (E && typeof v != "bigint") {
      if (Us(v) && (v = Ts(v)), typeof v != "string" || !E.includes(v.length))
        throw new Error("invalid private key");
      v = v.padStart(A * 2, "0");
    }
    let P;
    try {
      P = typeof v == "bigint" ? v : Jn(cr("private key", v, A));
    } catch {
      throw new Error("invalid private key, expected hex or " + A + " bytes, got " + typeof v);
    }
    return k && (P = Ft(P, U)), Oi("private key", P, pt, U), P;
  }
  function h(v) {
    if (!(v instanceof p))
      throw new Error("ProjectivePoint expected");
  }
  const f = yh((v, E) => {
    const { px: A, py: k, pz: U } = v;
    if (t.eql(U, t.ONE))
      return { x: A, y: k };
    const P = v.is0();
    E == null && (E = P ? t.ONE : t.inv(U));
    const $ = t.mul(A, E), ee = t.mul(k, E), G = t.mul(U, E);
    if (P)
      return { x: t.ZERO, y: t.ZERO };
    if (!t.eql(G, t.ONE))
      throw new Error("invZ was invalid");
    return { x: $, y: ee };
  }), g = yh((v) => {
    if (v.is0()) {
      if (e.allowInfinityPoint && !t.is0(v.py))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x: E, y: A } = v.toAffine();
    if (!t.isValid(E) || !t.isValid(A))
      throw new Error("bad point: x or y not FE");
    if (!a(E, A))
      throw new Error("bad point: equation left != right");
    if (!v.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return true;
  });
  class p {
    constructor(E, A, k) {
      if (E == null || !t.isValid(E))
        throw new Error("x required");
      if (A == null || !t.isValid(A) || t.is0(A))
        throw new Error("y required");
      if (k == null || !t.isValid(k))
        throw new Error("z required");
      this.px = E, this.py = A, this.pz = k, Object.freeze(this);
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(E) {
      const { x: A, y: k } = E || {};
      if (!E || !t.isValid(A) || !t.isValid(k))
        throw new Error("invalid affine point");
      if (E instanceof p)
        throw new Error("projective point not allowed");
      const U = (P) => t.eql(P, t.ZERO);
      return U(A) && U(k) ? p.ZERO : new p(A, k, t.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(E) {
      const A = v0(t, E.map((k) => k.pz));
      return E.map((k, U) => k.toAffine(A[U])).map(p.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(E) {
      const A = p.fromAffine(i(cr("pointHex", E)));
      return A.assertValidity(), A;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(E) {
      return p.BASE.multiply(d(E));
    }
    // Multiscalar Multiplication
    static msm(E, A) {
      return V_(p, n, E, A);
    }
    // "Private method", don't use it directly
    _setWindowSize(E) {
      D.setWindowSize(this, E);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      g(this);
    }
    hasEvenY() {
      const { y: E } = this.toAffine();
      if (t.isOdd)
        return !t.isOdd(E);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(E) {
      h(E);
      const { px: A, py: k, pz: U } = this, { px: P, py: $, pz: ee } = E, G = t.eql(t.mul(A, ee), t.mul(P, U)), H = t.eql(t.mul(k, ee), t.mul($, U));
      return G && H;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new p(this.px, t.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: E, b: A } = e, k = t.mul(A, Lc), { px: U, py: P, pz: $ } = this;
      let ee = t.ZERO, G = t.ZERO, H = t.ZERO, R = t.mul(U, U), z = t.mul(P, P), j = t.mul($, $), I = t.mul(U, P);
      return I = t.add(I, I), H = t.mul(U, $), H = t.add(H, H), ee = t.mul(E, H), G = t.mul(k, j), G = t.add(ee, G), ee = t.sub(z, G), G = t.add(z, G), G = t.mul(ee, G), ee = t.mul(I, ee), H = t.mul(k, H), j = t.mul(E, j), I = t.sub(R, j), I = t.mul(E, I), I = t.add(I, H), H = t.add(R, R), R = t.add(H, R), R = t.add(R, j), R = t.mul(R, I), G = t.add(G, R), j = t.mul(P, $), j = t.add(j, j), R = t.mul(j, I), ee = t.sub(ee, R), H = t.mul(j, z), H = t.add(H, H), H = t.add(H, H), new p(ee, G, H);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(E) {
      h(E);
      const { px: A, py: k, pz: U } = this, { px: P, py: $, pz: ee } = E;
      let G = t.ZERO, H = t.ZERO, R = t.ZERO;
      const z = e.a, j = t.mul(e.b, Lc);
      let I = t.mul(A, P), y = t.mul(k, $), m = t.mul(U, ee), N = t.add(A, k), T = t.add(P, $);
      N = t.mul(N, T), T = t.add(I, y), N = t.sub(N, T), T = t.add(A, U);
      let x = t.add(P, ee);
      return T = t.mul(T, x), x = t.add(I, m), T = t.sub(T, x), x = t.add(k, U), G = t.add($, ee), x = t.mul(x, G), G = t.add(y, m), x = t.sub(x, G), R = t.mul(z, T), G = t.mul(j, m), R = t.add(G, R), G = t.sub(y, R), R = t.add(y, R), H = t.mul(G, R), y = t.add(I, I), y = t.add(y, I), m = t.mul(z, m), T = t.mul(j, T), y = t.add(y, m), m = t.sub(I, m), m = t.mul(z, m), T = t.add(T, m), I = t.mul(y, T), H = t.add(H, I), I = t.mul(x, T), G = t.mul(N, G), G = t.sub(G, I), I = t.mul(N, y), R = t.mul(x, R), R = t.add(R, I), new p(G, H, R);
    }
    subtract(E) {
      return this.add(E.negate());
    }
    is0() {
      return this.equals(p.ZERO);
    }
    wNAF(E) {
      return D.wNAFCached(this, E, p.normalizeZ);
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(E) {
      const { endo: A, n: k } = e;
      Oi("scalar", E, Wr, k);
      const U = p.ZERO;
      if (E === Wr)
        return U;
      if (this.is0() || E === pt)
        return this;
      if (!A || D.hasPrecomputes(this))
        return D.wNAFCachedUnsafe(this, E, p.normalizeZ);
      let { k1neg: P, k1: $, k2neg: ee, k2: G } = A.splitScalar(E), H = U, R = U, z = this;
      for (; $ > Wr || G > Wr; )
        $ & pt && (H = H.add(z)), G & pt && (R = R.add(z)), z = z.double(), $ >>= pt, G >>= pt;
      return P && (H = H.negate()), ee && (R = R.negate()), R = new p(t.mul(R.px, A.beta), R.py, R.pz), H.add(R);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(E) {
      const { endo: A, n: k } = e;
      Oi("scalar", E, pt, k);
      let U, P;
      if (A) {
        const { k1neg: $, k1: ee, k2neg: G, k2: H } = A.splitScalar(E);
        let { p: R, f: z } = this.wNAF(ee), { p: j, f: I } = this.wNAF(H);
        R = D.constTimeNegate($, R), j = D.constTimeNegate(G, j), j = new p(t.mul(j.px, A.beta), j.py, j.pz), U = R.add(j), P = z.add(I);
      } else {
        const { p: $, f: ee } = this.wNAF(E);
        U = $, P = ee;
      }
      return p.normalizeZ([U, P])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(E, A, k) {
      const U = p.BASE, P = (ee, G) => G === Wr || G === pt || !ee.equals(U) ? ee.multiplyUnsafe(G) : ee.multiply(G), $ = P(this, A).add(P(E, k));
      return $.is0() ? void 0 : $;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z) ∋ (x=x/z, y=y/z)
    toAffine(E) {
      return f(this, E);
    }
    isTorsionFree() {
      const { h: E, isTorsionFree: A } = e;
      if (E === pt)
        return true;
      if (A)
        return A(p, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: E, clearCofactor: A } = e;
      return E === pt ? this : A ? A(p, this) : this.multiplyUnsafe(e.h);
    }
    toRawBytes(E = true) {
      return Ds("isCompressed", E), this.assertValidity(), s(p, this, E);
    }
    toHex(E = true) {
      return Ds("isCompressed", E), Ts(this.toRawBytes(E));
    }
  }
  p.BASE = new p(e.Gx, e.Gy, t.ONE), p.ZERO = new p(t.ZERO, t.ONE, t.ZERO);
  const { endo: b, nBitLength: _ } = e, D = Y_(p, b ? Math.ceil(_ / 2) : _);
  return {
    CURVE: e,
    ProjectivePoint: p,
    normPrivateKeyToScalar: d,
    weierstrassEquation: o,
    isWithinCurveOrder: l
  };
}
function X_(r) {
  const e = _0(r);
  return $a(e, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  }), Object.freeze({ lowS: true, ...e });
}
function Z_(r) {
  const e = X_(r), { Fp: t, n, nByteLength: s, nBitLength: i } = e, o = t.BYTES + 1, a = 2 * t.BYTES + 1;
  function u(j) {
    return Ft(j, n);
  }
  function c(j) {
    return bu(j, n);
  }
  const { ProjectivePoint: l, normPrivateKeyToScalar: d, weierstrassEquation: h, isWithinCurveOrder: f } = K_({
    ...e,
    toBytes(j, I, y) {
      const m = I.toAffine(), N = t.toBytes(m.x), T = Ro;
      return Ds("isCompressed", y), y ? T(Uint8Array.from([I.hasEvenY() ? 2 : 3]), N) : T(Uint8Array.from([4]), N, t.toBytes(m.y));
    },
    fromBytes(j) {
      const I = j.length, y = j[0], m = j.subarray(1);
      if (I === o && (y === 2 || y === 3)) {
        const N = Jn(m);
        if (!El(N, pt, t.ORDER))
          throw new Error("Point is not on curve");
        const T = h(N);
        let x;
        try {
          x = t.sqrt(T);
        } catch (q) {
          const K = q instanceof Error ? ": " + q.message : "";
          throw new Error("Point is not on curve" + K);
        }
        const L = (x & pt) === pt;
        return (y & 1) === 1 !== L && (x = t.neg(x)), { x: N, y: x };
      } else if (I === a && y === 4) {
        const N = t.fromBytes(m.subarray(0, t.BYTES)), T = t.fromBytes(m.subarray(t.BYTES, 2 * t.BYTES));
        return { x: N, y: T };
      } else {
        const N = o, T = a;
        throw new Error("invalid Point, expected length of " + N + ", or uncompressed " + T + ", got " + I);
      }
    }
  });
  function g(j) {
    const I = n >> pt;
    return j > I;
  }
  function p(j) {
    return g(j) ? u(-j) : j;
  }
  const b = (j, I, y) => Jn(j.slice(I, y));
  class _ {
    constructor(I, y, m) {
      Oi("r", I, pt, n), Oi("s", y, pt, n), this.r = I, this.s = y, m != null && (this.recovery = m), Object.freeze(this);
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(I) {
      const y = s;
      return I = cr("compactSignature", I, y * 2), new _(b(I, 0, y), b(I, y, 2 * y));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(I) {
      const { r: y, s: m } = Vr.toSig(cr("DER", I));
      return new _(y, m);
    }
    /**
     * @todo remove
     * @deprecated
     */
    assertValidity() {
    }
    addRecoveryBit(I) {
      return new _(this.r, this.s, I);
    }
    recoverPublicKey(I) {
      const { r: y, s: m, recovery: N } = this, T = U(cr("msgHash", I));
      if (N == null || ![0, 1, 2, 3].includes(N))
        throw new Error("recovery id invalid");
      const x = N === 2 || N === 3 ? y + e.n : y;
      if (x >= t.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const L = N & 1 ? "03" : "02", V = l.fromHex(L + Cc(x, t.BYTES)), q = c(x), K = u(-T * q), Z = u(m * q), re = l.BASE.multiplyAndAddUnsafe(V, K, Z);
      if (!re)
        throw new Error("point at infinify");
      return re.assertValidity(), re;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return g(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new _(this.r, u(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return Bo(this.toDERHex());
    }
    toDERHex() {
      return Vr.hexFromSig(this);
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return Bo(this.toCompactHex());
    }
    toCompactHex() {
      const I = s;
      return Cc(this.r, I) + Cc(this.s, I);
    }
  }
  const D = {
    isValidPrivateKey(j) {
      try {
        return d(j), true;
      } catch {
        return false;
      }
    },
    normPrivateKeyToScalar: d,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const j = N0(e.n);
      return F_(e.randomBytes(j), e.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(j = 8, I = l.BASE) {
      return I._setWindowSize(j), I.multiply(BigInt(3)), I;
    }
  };
  function v(j, I = true) {
    return l.fromPrivateKey(j).toRawBytes(I);
  }
  function E(j) {
    if (typeof j == "bigint")
      return false;
    if (j instanceof l)
      return true;
    const y = cr("key", j).length, m = t.BYTES, N = m + 1, T = 2 * m + 1;
    if (!(e.allowedPrivateKeyLengths || s === N))
      return y === N || y === T;
  }
  function A(j, I, y = true) {
    if (E(j) === true)
      throw new Error("first arg must be private key");
    if (E(I) === false)
      throw new Error("second arg must be public key");
    return l.fromHex(I).multiply(d(j)).toRawBytes(y);
  }
  const k = e.bits2int || function(j) {
    if (j.length > 8192)
      throw new Error("input is too large");
    const I = Jn(j), y = j.length * 8 - i;
    return y > 0 ? I >> BigInt(y) : I;
  }, U = e.bits2int_modN || function(j) {
    return u(k(j));
  }, P = Ra(i);
  function $(j) {
    return Oi("num < 2^" + i, j, Wr, P), Ps(j, s);
  }
  function ee(j, I, y = G) {
    if (["recovered", "canonical"].some((se) => se in y))
      throw new Error("sign() legacy options not supported");
    const { hash: m, randomBytes: N } = e;
    let { lowS: T, prehash: x, extraEntropy: L } = y;
    T == null && (T = true), j = cr("msgHash", j), _h(y), x && (j = cr("prehashed msgHash", m(j)));
    const V = U(j), q = d(I), K = [$(q), $(V)];
    if (L != null && L !== false) {
      const se = L === true ? N(t.BYTES) : L;
      K.push(cr("extraEntropy", se));
    }
    const Z = Ro(...K), re = V;
    function ne(se) {
      const ue = k(se);
      if (!f(ue))
        return;
      const he = c(ue), Q = l.BASE.multiply(ue).toAffine(), X = u(Q.x);
      if (X === Wr)
        return;
      const Y = u(he * u(re + X * q));
      if (Y === Wr)
        return;
      let J = (Q.x === X ? 0 : 2) | Number(Q.y & pt), ie = Y;
      return T && g(Y) && (ie = p(Y), J ^= 1), new _(X, ie, J);
    }
    return { seed: Z, k2sig: ne };
  }
  const G = { lowS: e.lowS, prehash: false }, H = { lowS: e.lowS, prehash: false };
  function R(j, I, y = G) {
    const { seed: m, k2sig: N } = ee(j, I, y), T = e;
    return KI(T.hash.outputLen, T.nByteLength, T.hmac)(m, N);
  }
  l.BASE._setWindowSize(8);
  function z(j, I, y, m = H) {
    var J;
    const N = j;
    I = cr("msgHash", I), y = cr("publicKey", y);
    const { lowS: T, prehash: x, format: L } = m;
    if (_h(m), "strict" in m)
      throw new Error("options.strict was renamed to lowS");
    if (L !== void 0 && L !== "compact" && L !== "der")
      throw new Error("format must be compact or der");
    const V = typeof N == "string" || Us(N), q = !V && !L && typeof N == "object" && N !== null && typeof N.r == "bigint" && typeof N.s == "bigint";
    if (!V && !q)
      throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
    let K, Z;
    try {
      if (q && (K = new _(N.r, N.s)), V) {
        try {
          L !== "compact" && (K = _.fromDER(N));
        } catch (ie) {
          if (!(ie instanceof Vr.Err))
            throw ie;
        }
        !K && L !== "der" && (K = _.fromCompact(N));
      }
      Z = l.fromHex(y);
    } catch {
      return false;
    }
    if (!K || T && K.hasHighS())
      return false;
    x && (I = e.hash(I));
    const { r: re, s: ne } = K, se = U(I), ue = c(ne), he = u(se * ue), Q = u(re * ue), X = (J = l.BASE.multiplyAndAddUnsafe(Z, he, Q)) == null ? void 0 : J.toAffine();
    return X ? u(X.x) === re : false;
  }
  return {
    CURVE: e,
    getPublicKey: v,
    getSharedSecret: A,
    sign: R,
    verify: z,
    ProjectivePoint: l,
    Signature: _,
    utils: D
  };
}
function J_(r) {
  return {
    hash: r,
    hmac: (e, ...t) => g0(r, e, NI(...t)),
    randomBytes: xI
  };
}
function eD(r, e) {
  const t = (n) => Z_({ ...r, ...J_(n) });
  return { ...t(e), create: t };
}
var D0 = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
var Dh = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var tD = BigInt(0);
var rD = BigInt(1);
var Mu = BigInt(2);
var Th = (r, e) => (r + e / Mu) / e;
function nD(r) {
  const e = D0, t = BigInt(3), n = BigInt(6), s = BigInt(11), i = BigInt(22), o = BigInt(23), a = BigInt(44), u = BigInt(88), c = r * r * r % e, l = c * c * r % e, d = nr(l, t, e) * l % e, h = nr(d, t, e) * l % e, f = nr(h, Mu, e) * c % e, g = nr(f, s, e) * f % e, p = nr(g, i, e) * g % e, b = nr(p, a, e) * p % e, _ = nr(b, u, e) * b % e, D = nr(_, a, e) * p % e, v = nr(D, t, e) * l % e, E = nr(v, o, e) * g % e, A = nr(E, n, e) * c % e, k = nr(A, Mu, e);
  if (!Eu.eql(Eu.sqr(k), r))
    throw new Error("Cannot find square root");
  return k;
}
var Eu = Il(D0, void 0, void 0, { sqrt: nD });
var iD = eD({
  a: tD,
  b: BigInt(7),
  Fp: Eu,
  n: Dh,
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  lowS: true,
  // Allow only low-S signatures by default in sign() and verify()
  endo: {
    // Endomorphism, see above
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (r) => {
      const e = Dh, t = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), n = -rD * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), s = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), i = t, o = BigInt("0x100000000000000000000000000000000"), a = Th(i * r, e), u = Th(-n * r, e);
      let c = Ft(r - a * t - u * s, e), l = Ft(-a * n - u * i, e);
      const d = c > o, h = l > o;
      if (d && (c = e - c), h && (l = e - l), c > o || l > o)
        throw new Error("splitScalar: Endomorphism failed, k=" + r);
      return { k1neg: d, k1: c, k2neg: h, k2: l };
    }
  }
}, HI);
function sD(r) {
  if (r.length !== 130 && r.length !== 132)
    throw new aD({ signature: r });
  const e = BigInt(Yr(r, 0, 32)), t = BigInt(Yr(r, 32, 64)), n = (() => {
    const s = +`0x${r.slice(130)}`;
    if (!Number.isNaN(s))
      try {
        return oD(s);
      } catch {
        throw new cD({ value: s });
      }
  })();
  return typeof n > "u" ? {
    r: e,
    s: t
  } : {
    r: e,
    s: t,
    yParity: n
  };
}
function oD(r) {
  if (r === 0 || r === 27)
    return 0;
  if (r === 1 || r === 28)
    return 1;
  if (r >= 35)
    return r % 2 === 0 ? 1 : 0;
  throw new uD({ value: r });
}
var aD = class extends He {
  constructor({ signature: e }) {
    super(`Value \`${e}\` is an invalid signature size.`, {
      metaMessages: [
        "Expected: 64 bytes or 65 bytes.",
        `Received ${An(xl(e))} bytes.`
      ]
    }), Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Signature.InvalidSerializedSizeError"
    });
  }
};
var cD = class extends He {
  constructor({ value: e }) {
    super(`Value \`${e}\` is an invalid y-parity value. Y-parity must be 0 or 1.`), Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Signature.InvalidYParityError"
    });
  }
};
var uD = class extends He {
  constructor({ value: e }) {
    super(`Value \`${e}\` is an invalid v value. v must be 27, 28 or >=35.`), Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Signature.InvalidVError"
    });
  }
};
function lD(r) {
  return r instanceof Uint8Array || ArrayBuffer.isView(r) && r.constructor.name === "Uint8Array";
}
function T0(r, e) {
  return Array.isArray(e) ? e.length === 0 ? true : r ? e.every((t) => typeof t == "string") : e.every((t) => Number.isSafeInteger(t)) : false;
}
function Fo(r, e) {
  if (typeof e != "string")
    throw new Error(`${r}: string expected`);
  return true;
}
function _l(r) {
  if (!Number.isSafeInteger(r))
    throw new Error(`invalid integer: ${r}`);
}
function Nu(r) {
  if (!Array.isArray(r))
    throw new Error("array expected");
}
function Qo(r, e) {
  if (!T0(true, e))
    throw new Error(`${r}: array of strings expected`);
}
function dD(r, e) {
  if (!T0(false, e))
    throw new Error(`${r}: array of numbers expected`);
}
function hD(...r) {
  const e = (i) => i, t = (i, o) => (a) => i(o(a)), n = r.map((i) => i.encode).reduceRight(t, e), s = r.map((i) => i.decode).reduce(t, e);
  return { encode: n, decode: s };
}
function fD(r) {
  const e = typeof r == "string" ? r.split("") : r, t = e.length;
  Qo("alphabet", e);
  const n = new Map(e.map((s, i) => [s, i]));
  return {
    encode: (s) => (Nu(s), s.map((i) => {
      if (!Number.isSafeInteger(i) || i < 0 || i >= t)
        throw new Error(`alphabet.encode: digit index outside alphabet "${i}". Allowed: ${r}`);
      return e[i];
    })),
    decode: (s) => (Nu(s), s.map((i) => {
      Fo("alphabet.decode", i);
      const o = n.get(i);
      if (o === void 0)
        throw new Error(`Unknown letter: "${i}". Allowed: ${r}`);
      return o;
    }))
  };
}
function pD(r = "") {
  return Fo("join", r), {
    encode: (e) => (Qo("join.decode", e), e.join(r)),
    decode: (e) => (Fo("join.decode", e), e.split(r))
  };
}
function gD(r, e = "=") {
  return _l(r), Fo("padding", e), {
    encode(t) {
      for (Qo("padding.encode", t); t.length * r % 8; )
        t.push(e);
      return t;
    },
    decode(t) {
      Qo("padding.decode", t);
      let n = t.length;
      if (n * r % 8)
        throw new Error("padding: invalid, string should have whole number of bytes");
      for (; n > 0 && t[n - 1] === e; n--)
        if ((n - 1) * r % 8 === 0)
          throw new Error("padding: invalid, string has too much padding");
      return t.slice(0, n);
    }
  };
}
var A0 = (r, e) => e === 0 ? r : A0(e, r % e);
var qo = (r, e) => r + (e - A0(r, e));
var zc = (() => {
  let r = [];
  for (let e = 0; e < 40; e++)
    r.push(2 ** e);
  return r;
})();
function Ah(r, e, t, n) {
  if (Nu(r), e <= 0 || e > 32)
    throw new Error(`convertRadix2: wrong from=${e}`);
  if (t <= 0 || t > 32)
    throw new Error(`convertRadix2: wrong to=${t}`);
  if (qo(e, t) > 32)
    throw new Error(`convertRadix2: carry overflow from=${e} to=${t} carryBits=${qo(e, t)}`);
  let s = 0, i = 0;
  const o = zc[e], a = zc[t] - 1, u = [];
  for (const c of r) {
    if (_l(c), c >= o)
      throw new Error(`convertRadix2: invalid data word=${c} from=${e}`);
    if (s = s << e | c, i + e > 32)
      throw new Error(`convertRadix2: carry overflow pos=${i} from=${e}`);
    for (i += e; i >= t; i -= t)
      u.push((s >> i - t & a) >>> 0);
    const l = zc[i];
    if (l === void 0)
      throw new Error("invalid carry");
    s &= l - 1;
  }
  if (s = s << t - i & a, !n && i >= e)
    throw new Error("Excess padding");
  if (!n && s > 0)
    throw new Error(`Non-zero padding: ${s}`);
  return n && i > 0 && u.push(s >>> 0), u;
}
function yD(r, e = false) {
  if (_l(r), r <= 0 || r > 32)
    throw new Error("radix2: bits should be in (0..32]");
  if (qo(8, r) > 32 || qo(r, 8) > 32)
    throw new Error("radix2: carry overflow");
  return {
    encode: (t) => {
      if (!lD(t))
        throw new Error("radix2.encode input should be Uint8Array");
      return Ah(Array.from(t), 8, r, !e);
    },
    decode: (t) => (dD("radix2.decode", t), Uint8Array.from(Ah(t, r, 8, e)))
  };
}
var wD = hD(yD(5), fD("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), gD(5), pD(""));
function mD(r) {
  return j_(bD(r));
}
function bD(r) {
  const { payload: e, signature: t } = r, { r: n, s, yParity: i } = t, a = new iD.Signature(BigInt(n), BigInt(s)).addRecoveryBit(i).recoverPublicKey(xl(e).substring(2));
  return N_(a);
}
function vD(r) {
  if (r.length >= 255)
    throw new TypeError("Alphabet too long");
  const e = new Uint8Array(256);
  for (let c = 0; c < e.length; c++)
    e[c] = 255;
  for (let c = 0; c < r.length; c++) {
    const l = r.charAt(c), d = l.charCodeAt(0);
    if (e[d] !== 255)
      throw new TypeError(l + " is ambiguous");
    e[d] = c;
  }
  const t = r.length, n = r.charAt(0), s = Math.log(t) / Math.log(256), i = Math.log(256) / Math.log(t);
  function o(c) {
    if (c instanceof Uint8Array || (ArrayBuffer.isView(c) ? c = new Uint8Array(c.buffer, c.byteOffset, c.byteLength) : Array.isArray(c) && (c = Uint8Array.from(c))), !(c instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (c.length === 0)
      return "";
    let l = 0, d = 0, h = 0;
    const f = c.length;
    for (; h !== f && c[h] === 0; )
      h++, l++;
    const g = (f - h) * i + 1 >>> 0, p = new Uint8Array(g);
    for (; h !== f; ) {
      let D = c[h], v = 0;
      for (let E = g - 1; (D !== 0 || v < d) && E !== -1; E--, v++)
        D += 256 * p[E] >>> 0, p[E] = D % t >>> 0, D = D / t >>> 0;
      if (D !== 0)
        throw new Error("Non-zero carry");
      d = v, h++;
    }
    let b = g - d;
    for (; b !== g && p[b] === 0; )
      b++;
    let _ = n.repeat(l);
    for (; b < g; ++b)
      _ += r.charAt(p[b]);
    return _;
  }
  function a(c) {
    if (typeof c != "string")
      throw new TypeError("Expected String");
    if (c.length === 0)
      return new Uint8Array();
    let l = 0, d = 0, h = 0;
    for (; c[l] === n; )
      d++, l++;
    const f = (c.length - l) * s + 1 >>> 0, g = new Uint8Array(f);
    for (; l < c.length; ) {
      const D = c.charCodeAt(l);
      if (D > 255)
        return;
      let v = e[D];
      if (v === 255)
        return;
      let E = 0;
      for (let A = f - 1; (v !== 0 || E < h) && A !== -1; A--, E++)
        v += t * g[A] >>> 0, g[A] = v % 256 >>> 0, v = v / 256 >>> 0;
      if (v !== 0)
        throw new Error("Non-zero carry");
      h = E, l++;
    }
    let p = f - h;
    for (; p !== f && g[p] === 0; )
      p++;
    const b = new Uint8Array(d + (f - p));
    let _ = d;
    for (; p !== f; )
      b[_++] = g[p++];
    return b;
  }
  function u(c) {
    const l = a(c);
    if (l)
      return l;
    throw new Error("Non-base" + t + " character");
  }
  return {
    encode: o,
    decodeUnsafe: a,
    decode: u
  };
}
var MD = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var Bs = vD(MD);
function ED(r) {
  const e = r.length;
  let t = 0, n = 0;
  for (; n < e; ) {
    let s = r.charCodeAt(n++);
    if (s & 4294967168)
      if (!(s & 4294965248))
        t += 2;
      else {
        if (s >= 55296 && s <= 56319 && n < e) {
          const i = r.charCodeAt(n);
          (i & 64512) === 56320 && (++n, s = ((s & 1023) << 10) + (i & 1023) + 65536);
        }
        s & 4294901760 ? t += 4 : t += 3;
      }
    else {
      t++;
      continue;
    }
  }
  return t;
}
function ND(r, e, t) {
  const n = r.length;
  let s = t, i = 0;
  for (; i < n; ) {
    let o = r.charCodeAt(i++);
    if (o & 4294967168)
      if (!(o & 4294965248))
        e[s++] = o >> 6 & 31 | 192;
      else {
        if (o >= 55296 && o <= 56319 && i < n) {
          const a = r.charCodeAt(i);
          (a & 64512) === 56320 && (++i, o = ((o & 1023) << 10) + (a & 1023) + 65536);
        }
        o & 4294901760 ? (e[s++] = o >> 18 & 7 | 240, e[s++] = o >> 12 & 63 | 128, e[s++] = o >> 6 & 63 | 128) : (e[s++] = o >> 12 & 15 | 224, e[s++] = o >> 6 & 63 | 128);
      }
    else {
      e[s++] = o;
      continue;
    }
    e[s++] = o & 63 | 128;
  }
}
var xD = new TextEncoder();
var ID = 50;
function _D(r, e, t) {
  xD.encodeInto(r, e.subarray(t));
}
function DD(r, e, t) {
  r.length > ID ? _D(r, e, t) : ND(r, e, t);
}
var TD = 4096;
function O0(r, e, t) {
  let n = e;
  const s = n + t, i = [];
  let o = "";
  for (; n < s; ) {
    const a = r[n++];
    if (!(a & 128))
      i.push(a);
    else if ((a & 224) === 192) {
      const u = r[n++] & 63;
      i.push((a & 31) << 6 | u);
    } else if ((a & 240) === 224) {
      const u = r[n++] & 63, c = r[n++] & 63;
      i.push((a & 31) << 12 | u << 6 | c);
    } else if ((a & 248) === 240) {
      const u = r[n++] & 63, c = r[n++] & 63, l = r[n++] & 63;
      let d = (a & 7) << 18 | u << 12 | c << 6 | l;
      d > 65535 && (d -= 65536, i.push(d >>> 10 & 1023 | 55296), d = 56320 | d & 1023), i.push(d);
    } else
      i.push(a);
    i.length >= TD && (o += String.fromCharCode(...i), i.length = 0);
  }
  return i.length > 0 && (o += String.fromCharCode(...i)), o;
}
var AD = new TextDecoder();
var OD = 200;
function SD(r, e, t) {
  const n = r.subarray(e, e + t);
  return AD.decode(n);
}
function jD(r, e, t) {
  return t > OD ? SD(r, e, t) : O0(r, e, t);
}
var lo = class {
  constructor(e, t) {
    this.type = e, this.data = t;
  }
};
var Zt = class _Zt extends Error {
  constructor(e) {
    super(e);
    const t = Object.create(_Zt.prototype);
    Object.setPrototypeOf(this, t), Object.defineProperty(this, "name", {
      configurable: true,
      enumerable: false,
      value: _Zt.name
    });
  }
};
var rs = 4294967295;
function CD(r, e, t) {
  const n = t / 4294967296, s = t;
  r.setUint32(e, n), r.setUint32(e + 4, s);
}
function S0(r, e, t) {
  const n = Math.floor(t / 4294967296), s = t;
  r.setUint32(e, n), r.setUint32(e + 4, s);
}
function j0(r, e) {
  const t = r.getInt32(e), n = r.getUint32(e + 4);
  return t * 4294967296 + n;
}
function LD(r, e) {
  const t = r.getUint32(e), n = r.getUint32(e + 4);
  return t * 4294967296 + n;
}
var zD = -1;
var kD = 4294967296 - 1;
var UD = 17179869184 - 1;
function PD({ sec: r, nsec: e }) {
  if (r >= 0 && e >= 0 && r <= UD)
    if (e === 0 && r <= kD) {
      const t = new Uint8Array(4);
      return new DataView(t.buffer).setUint32(0, r), t;
    } else {
      const t = r / 4294967296, n = r & 4294967295, s = new Uint8Array(8), i = new DataView(s.buffer);
      return i.setUint32(0, e << 2 | t & 3), i.setUint32(4, n), s;
    }
  else {
    const t = new Uint8Array(12), n = new DataView(t.buffer);
    return n.setUint32(0, e), S0(n, 4, r), t;
  }
}
function BD(r) {
  const e = r.getTime(), t = Math.floor(e / 1e3), n = (e - t * 1e3) * 1e6, s = Math.floor(n / 1e9);
  return {
    sec: t + s,
    nsec: n - s * 1e9
  };
}
function RD(r) {
  if (r instanceof Date) {
    const e = BD(r);
    return PD(e);
  } else
    return null;
}
function $D(r) {
  const e = new DataView(r.buffer, r.byteOffset, r.byteLength);
  switch (r.byteLength) {
    case 4:
      return { sec: e.getUint32(0), nsec: 0 };
    case 8: {
      const t = e.getUint32(0), n = e.getUint32(4), s = (t & 3) * 4294967296 + n, i = t >>> 2;
      return { sec: s, nsec: i };
    }
    case 12: {
      const t = j0(e, 4), n = e.getUint32(0);
      return { sec: t, nsec: n };
    }
    default:
      throw new Zt(`Unrecognized data size for timestamp (expected 4, 8, or 12): ${r.length}`);
  }
}
function FD(r) {
  const e = $D(r);
  return new Date(e.sec * 1e3 + e.nsec / 1e6);
}
var QD = {
  type: zD,
  encode: RD,
  decode: FD
};
var Yo = class {
  constructor() {
    this.builtInEncoders = [], this.builtInDecoders = [], this.encoders = [], this.decoders = [], this.register(QD);
  }
  register({ type: e, encode: t, decode: n }) {
    if (e >= 0)
      this.encoders[e] = t, this.decoders[e] = n;
    else {
      const s = -1 - e;
      this.builtInEncoders[s] = t, this.builtInDecoders[s] = n;
    }
  }
  tryToEncode(e, t) {
    for (let n = 0; n < this.builtInEncoders.length; n++) {
      const s = this.builtInEncoders[n];
      if (s != null) {
        const i = s(e, t);
        if (i != null) {
          const o = -1 - n;
          return new lo(o, i);
        }
      }
    }
    for (let n = 0; n < this.encoders.length; n++) {
      const s = this.encoders[n];
      if (s != null) {
        const i = s(e, t);
        if (i != null) {
          const o = n;
          return new lo(o, i);
        }
      }
    }
    return e instanceof lo ? e : null;
  }
  decode(e, t, n) {
    const s = t < 0 ? this.builtInDecoders[-1 - t] : this.decoders[t];
    return s ? s(e, t, n) : new lo(t, e);
  }
};
Yo.defaultCodec = new Yo();
function qD(r) {
  return r instanceof ArrayBuffer || typeof SharedArrayBuffer < "u" && r instanceof SharedArrayBuffer;
}
function xu(r) {
  return r instanceof Uint8Array ? r : ArrayBuffer.isView(r) ? new Uint8Array(r.buffer, r.byteOffset, r.byteLength) : qD(r) ? new Uint8Array(r) : Uint8Array.from(r);
}
var YD = 100;
var VD = 2048;
var HD = class C0 {
  constructor(e) {
    this.entered = false, this.extensionCodec = (e == null ? void 0 : e.extensionCodec) ?? Yo.defaultCodec, this.context = e == null ? void 0 : e.context, this.useBigInt64 = (e == null ? void 0 : e.useBigInt64) ?? false, this.maxDepth = (e == null ? void 0 : e.maxDepth) ?? YD, this.initialBufferSize = (e == null ? void 0 : e.initialBufferSize) ?? VD, this.sortKeys = (e == null ? void 0 : e.sortKeys) ?? false, this.forceFloat32 = (e == null ? void 0 : e.forceFloat32) ?? false, this.ignoreUndefined = (e == null ? void 0 : e.ignoreUndefined) ?? false, this.forceIntegerToFloat = (e == null ? void 0 : e.forceIntegerToFloat) ?? false, this.pos = 0, this.view = new DataView(new ArrayBuffer(this.initialBufferSize)), this.bytes = new Uint8Array(this.view.buffer);
  }
  clone() {
    return new C0({
      extensionCodec: this.extensionCodec,
      context: this.context,
      useBigInt64: this.useBigInt64,
      maxDepth: this.maxDepth,
      initialBufferSize: this.initialBufferSize,
      sortKeys: this.sortKeys,
      forceFloat32: this.forceFloat32,
      ignoreUndefined: this.ignoreUndefined,
      forceIntegerToFloat: this.forceIntegerToFloat
    });
  }
  reinitializeState() {
    this.pos = 0;
  }
  /**
   * This is almost equivalent to {@link Encoder#encode}, but it returns an reference of the encoder's internal buffer and thus much faster than {@link Encoder#encode}.
   *
   * @returns Encodes the object and returns a shared reference the encoder's internal buffer.
   */
  encodeSharedRef(e) {
    if (this.entered)
      return this.clone().encodeSharedRef(e);
    try {
      return this.entered = true, this.reinitializeState(), this.doEncode(e, 1), this.bytes.subarray(0, this.pos);
    } finally {
      this.entered = false;
    }
  }
  /**
   * @returns Encodes the object and returns a copy of the encoder's internal buffer.
   */
  encode(e) {
    if (this.entered)
      return this.clone().encode(e);
    try {
      return this.entered = true, this.reinitializeState(), this.doEncode(e, 1), this.bytes.slice(0, this.pos);
    } finally {
      this.entered = false;
    }
  }
  doEncode(e, t) {
    if (t > this.maxDepth)
      throw new Error(`Too deep objects in depth ${t}`);
    e == null ? this.encodeNil() : typeof e == "boolean" ? this.encodeBoolean(e) : typeof e == "number" ? this.forceIntegerToFloat ? this.encodeNumberAsFloat(e) : this.encodeNumber(e) : typeof e == "string" ? this.encodeString(e) : this.useBigInt64 && typeof e == "bigint" ? this.encodeBigInt64(e) : this.encodeObject(e, t);
  }
  ensureBufferSizeToWrite(e) {
    const t = this.pos + e;
    this.view.byteLength < t && this.resizeBuffer(t * 2);
  }
  resizeBuffer(e) {
    const t = new ArrayBuffer(e), n = new Uint8Array(t), s = new DataView(t);
    n.set(this.bytes), this.view = s, this.bytes = n;
  }
  encodeNil() {
    this.writeU8(192);
  }
  encodeBoolean(e) {
    e === false ? this.writeU8(194) : this.writeU8(195);
  }
  encodeNumber(e) {
    !this.forceIntegerToFloat && Number.isSafeInteger(e) ? e >= 0 ? e < 128 ? this.writeU8(e) : e < 256 ? (this.writeU8(204), this.writeU8(e)) : e < 65536 ? (this.writeU8(205), this.writeU16(e)) : e < 4294967296 ? (this.writeU8(206), this.writeU32(e)) : this.useBigInt64 ? this.encodeNumberAsFloat(e) : (this.writeU8(207), this.writeU64(e)) : e >= -32 ? this.writeU8(224 | e + 32) : e >= -128 ? (this.writeU8(208), this.writeI8(e)) : e >= -32768 ? (this.writeU8(209), this.writeI16(e)) : e >= -2147483648 ? (this.writeU8(210), this.writeI32(e)) : this.useBigInt64 ? this.encodeNumberAsFloat(e) : (this.writeU8(211), this.writeI64(e)) : this.encodeNumberAsFloat(e);
  }
  encodeNumberAsFloat(e) {
    this.forceFloat32 ? (this.writeU8(202), this.writeF32(e)) : (this.writeU8(203), this.writeF64(e));
  }
  encodeBigInt64(e) {
    e >= BigInt(0) ? (this.writeU8(207), this.writeBigUint64(e)) : (this.writeU8(211), this.writeBigInt64(e));
  }
  writeStringHeader(e) {
    if (e < 32)
      this.writeU8(160 + e);
    else if (e < 256)
      this.writeU8(217), this.writeU8(e);
    else if (e < 65536)
      this.writeU8(218), this.writeU16(e);
    else if (e < 4294967296)
      this.writeU8(219), this.writeU32(e);
    else
      throw new Error(`Too long string: ${e} bytes in UTF-8`);
  }
  encodeString(e) {
    const n = ED(e);
    this.ensureBufferSizeToWrite(5 + n), this.writeStringHeader(n), DD(e, this.bytes, this.pos), this.pos += n;
  }
  encodeObject(e, t) {
    const n = this.extensionCodec.tryToEncode(e, this.context);
    if (n != null)
      this.encodeExtension(n);
    else if (Array.isArray(e))
      this.encodeArray(e, t);
    else if (ArrayBuffer.isView(e))
      this.encodeBinary(e);
    else if (typeof e == "object")
      this.encodeMap(e, t);
    else
      throw new Error(`Unrecognized object: ${Object.prototype.toString.apply(e)}`);
  }
  encodeBinary(e) {
    const t = e.byteLength;
    if (t < 256)
      this.writeU8(196), this.writeU8(t);
    else if (t < 65536)
      this.writeU8(197), this.writeU16(t);
    else if (t < 4294967296)
      this.writeU8(198), this.writeU32(t);
    else
      throw new Error(`Too large binary: ${t}`);
    const n = xu(e);
    this.writeU8a(n);
  }
  encodeArray(e, t) {
    const n = e.length;
    if (n < 16)
      this.writeU8(144 + n);
    else if (n < 65536)
      this.writeU8(220), this.writeU16(n);
    else if (n < 4294967296)
      this.writeU8(221), this.writeU32(n);
    else
      throw new Error(`Too large array: ${n}`);
    for (const s of e)
      this.doEncode(s, t + 1);
  }
  countWithoutUndefined(e, t) {
    let n = 0;
    for (const s of t)
      e[s] !== void 0 && n++;
    return n;
  }
  encodeMap(e, t) {
    const n = Object.keys(e);
    this.sortKeys && n.sort();
    const s = this.ignoreUndefined ? this.countWithoutUndefined(e, n) : n.length;
    if (s < 16)
      this.writeU8(128 + s);
    else if (s < 65536)
      this.writeU8(222), this.writeU16(s);
    else if (s < 4294967296)
      this.writeU8(223), this.writeU32(s);
    else
      throw new Error(`Too large map object: ${s}`);
    for (const i of n) {
      const o = e[i];
      this.ignoreUndefined && o === void 0 || (this.encodeString(i), this.doEncode(o, t + 1));
    }
  }
  encodeExtension(e) {
    if (typeof e.data == "function") {
      const n = e.data(this.pos + 6), s = n.length;
      if (s >= 4294967296)
        throw new Error(`Too large extension object: ${s}`);
      this.writeU8(201), this.writeU32(s), this.writeI8(e.type), this.writeU8a(n);
      return;
    }
    const t = e.data.length;
    if (t === 1)
      this.writeU8(212);
    else if (t === 2)
      this.writeU8(213);
    else if (t === 4)
      this.writeU8(214);
    else if (t === 8)
      this.writeU8(215);
    else if (t === 16)
      this.writeU8(216);
    else if (t < 256)
      this.writeU8(199), this.writeU8(t);
    else if (t < 65536)
      this.writeU8(200), this.writeU16(t);
    else if (t < 4294967296)
      this.writeU8(201), this.writeU32(t);
    else
      throw new Error(`Too large extension object: ${t}`);
    this.writeI8(e.type), this.writeU8a(e.data);
  }
  writeU8(e) {
    this.ensureBufferSizeToWrite(1), this.view.setUint8(this.pos, e), this.pos++;
  }
  writeU8a(e) {
    const t = e.length;
    this.ensureBufferSizeToWrite(t), this.bytes.set(e, this.pos), this.pos += t;
  }
  writeI8(e) {
    this.ensureBufferSizeToWrite(1), this.view.setInt8(this.pos, e), this.pos++;
  }
  writeU16(e) {
    this.ensureBufferSizeToWrite(2), this.view.setUint16(this.pos, e), this.pos += 2;
  }
  writeI16(e) {
    this.ensureBufferSizeToWrite(2), this.view.setInt16(this.pos, e), this.pos += 2;
  }
  writeU32(e) {
    this.ensureBufferSizeToWrite(4), this.view.setUint32(this.pos, e), this.pos += 4;
  }
  writeI32(e) {
    this.ensureBufferSizeToWrite(4), this.view.setInt32(this.pos, e), this.pos += 4;
  }
  writeF32(e) {
    this.ensureBufferSizeToWrite(4), this.view.setFloat32(this.pos, e), this.pos += 4;
  }
  writeF64(e) {
    this.ensureBufferSizeToWrite(8), this.view.setFloat64(this.pos, e), this.pos += 8;
  }
  writeU64(e) {
    this.ensureBufferSizeToWrite(8), CD(this.view, this.pos, e), this.pos += 8;
  }
  writeI64(e) {
    this.ensureBufferSizeToWrite(8), S0(this.view, this.pos, e), this.pos += 8;
  }
  writeBigUint64(e) {
    this.ensureBufferSizeToWrite(8), this.view.setBigUint64(this.pos, e), this.pos += 8;
  }
  writeBigInt64(e) {
    this.ensureBufferSizeToWrite(8), this.view.setBigInt64(this.pos, e), this.pos += 8;
  }
};
function GD(r, e) {
  return new HD(e).encodeSharedRef(r);
}
function kc(r) {
  return `${r < 0 ? "-" : ""}0x${Math.abs(r).toString(16).padStart(2, "0")}`;
}
var WD = 16;
var KD = 16;
var XD = class {
  constructor(e = WD, t = KD) {
    this.hit = 0, this.miss = 0, this.maxKeyLength = e, this.maxLengthPerKey = t, this.caches = [];
    for (let n = 0; n < this.maxKeyLength; n++)
      this.caches.push([]);
  }
  canBeCached(e) {
    return e > 0 && e <= this.maxKeyLength;
  }
  find(e, t, n) {
    const s = this.caches[n - 1];
    e: for (const i of s) {
      const o = i.bytes;
      for (let a = 0; a < n; a++)
        if (o[a] !== e[t + a])
          continue e;
      return i.str;
    }
    return null;
  }
  store(e, t) {
    const n = this.caches[e.length - 1], s = { bytes: e, str: t };
    n.length >= this.maxLengthPerKey ? n[Math.random() * n.length | 0] = s : n.push(s);
  }
  decode(e, t, n) {
    const s = this.find(e, t, n);
    if (s != null)
      return this.hit++, s;
    this.miss++;
    const i = O0(e, t, n), o = Uint8Array.prototype.slice.call(e, t, t + n);
    return this.store(o, i), i;
  }
};
var Iu = "array";
var ws = "map_key";
var L0 = "map_value";
var ZD = (r) => {
  if (typeof r == "string" || typeof r == "number")
    return r;
  throw new Zt("The type of key must be string or number but " + typeof r);
};
var JD = class {
  constructor() {
    this.stack = [], this.stackHeadPosition = -1;
  }
  get length() {
    return this.stackHeadPosition + 1;
  }
  top() {
    return this.stack[this.stackHeadPosition];
  }
  pushArrayState(e) {
    const t = this.getUninitializedStateFromPool();
    t.type = Iu, t.position = 0, t.size = e, t.array = new Array(e);
  }
  pushMapState(e) {
    const t = this.getUninitializedStateFromPool();
    t.type = ws, t.readCount = 0, t.size = e, t.map = {};
  }
  getUninitializedStateFromPool() {
    if (this.stackHeadPosition++, this.stackHeadPosition === this.stack.length) {
      const e = {
        type: void 0,
        size: 0,
        array: void 0,
        position: 0,
        readCount: 0,
        map: void 0,
        key: null
      };
      this.stack.push(e);
    }
    return this.stack[this.stackHeadPosition];
  }
  release(e) {
    if (this.stack[this.stackHeadPosition] !== e)
      throw new Error("Invalid stack state. Released state is not on top of the stack.");
    if (e.type === Iu) {
      const n = e;
      n.size = 0, n.array = void 0, n.position = 0, n.type = void 0;
    }
    if (e.type === ws || e.type === L0) {
      const n = e;
      n.size = 0, n.map = void 0, n.readCount = 0, n.type = void 0;
    }
    this.stackHeadPosition--;
  }
  reset() {
    this.stack.length = 0, this.stackHeadPosition = -1;
  }
};
var ns = -1;
var Dl = new DataView(new ArrayBuffer(0));
var eT = new Uint8Array(Dl.buffer);
try {
  Dl.getInt8(0);
} catch (r) {
  if (!(r instanceof RangeError))
    throw new Error("This module is not supported in the current JavaScript engine because DataView does not throw RangeError on out-of-bounds access");
}
var Oh = new RangeError("Insufficient data");
var tT = new XD();
var rT = class z0 {
  constructor(e) {
    this.totalPos = 0, this.pos = 0, this.view = Dl, this.bytes = eT, this.headByte = ns, this.stack = new JD(), this.entered = false, this.extensionCodec = (e == null ? void 0 : e.extensionCodec) ?? Yo.defaultCodec, this.context = e == null ? void 0 : e.context, this.useBigInt64 = (e == null ? void 0 : e.useBigInt64) ?? false, this.rawStrings = (e == null ? void 0 : e.rawStrings) ?? false, this.maxStrLength = (e == null ? void 0 : e.maxStrLength) ?? rs, this.maxBinLength = (e == null ? void 0 : e.maxBinLength) ?? rs, this.maxArrayLength = (e == null ? void 0 : e.maxArrayLength) ?? rs, this.maxMapLength = (e == null ? void 0 : e.maxMapLength) ?? rs, this.maxExtLength = (e == null ? void 0 : e.maxExtLength) ?? rs, this.keyDecoder = (e == null ? void 0 : e.keyDecoder) !== void 0 ? e.keyDecoder : tT, this.mapKeyConverter = (e == null ? void 0 : e.mapKeyConverter) ?? ZD;
  }
  clone() {
    return new z0({
      extensionCodec: this.extensionCodec,
      context: this.context,
      useBigInt64: this.useBigInt64,
      rawStrings: this.rawStrings,
      maxStrLength: this.maxStrLength,
      maxBinLength: this.maxBinLength,
      maxArrayLength: this.maxArrayLength,
      maxMapLength: this.maxMapLength,
      maxExtLength: this.maxExtLength,
      keyDecoder: this.keyDecoder
    });
  }
  reinitializeState() {
    this.totalPos = 0, this.headByte = ns, this.stack.reset();
  }
  setBuffer(e) {
    const t = xu(e);
    this.bytes = t, this.view = new DataView(t.buffer, t.byteOffset, t.byteLength), this.pos = 0;
  }
  appendBuffer(e) {
    if (this.headByte === ns && !this.hasRemaining(1))
      this.setBuffer(e);
    else {
      const t = this.bytes.subarray(this.pos), n = xu(e), s = new Uint8Array(t.length + n.length);
      s.set(t), s.set(n, t.length), this.setBuffer(s);
    }
  }
  hasRemaining(e) {
    return this.view.byteLength - this.pos >= e;
  }
  createExtraByteError(e) {
    const { view: t, pos: n } = this;
    return new RangeError(`Extra ${t.byteLength - n} of ${t.byteLength} byte(s) found at buffer[${e}]`);
  }
  /**
   * @throws {@link DecodeError}
   * @throws {@link RangeError}
   */
  decode(e) {
    if (this.entered)
      return this.clone().decode(e);
    try {
      this.entered = true, this.reinitializeState(), this.setBuffer(e);
      const t = this.doDecodeSync();
      if (this.hasRemaining(1))
        throw this.createExtraByteError(this.pos);
      return t;
    } finally {
      this.entered = false;
    }
  }
  *decodeMulti(e) {
    if (this.entered) {
      yield* this.clone().decodeMulti(e);
      return;
    }
    try {
      for (this.entered = true, this.reinitializeState(), this.setBuffer(e); this.hasRemaining(1); )
        yield this.doDecodeSync();
    } finally {
      this.entered = false;
    }
  }
  async decodeAsync(e) {
    if (this.entered)
      return this.clone().decodeAsync(e);
    try {
      this.entered = true;
      let t = false, n;
      for await (const a of e) {
        if (t)
          throw this.entered = false, this.createExtraByteError(this.totalPos);
        this.appendBuffer(a);
        try {
          n = this.doDecodeSync(), t = true;
        } catch (u) {
          if (!(u instanceof RangeError))
            throw u;
        }
        this.totalPos += this.pos;
      }
      if (t) {
        if (this.hasRemaining(1))
          throw this.createExtraByteError(this.totalPos);
        return n;
      }
      const { headByte: s, pos: i, totalPos: o } = this;
      throw new RangeError(`Insufficient data in parsing ${kc(s)} at ${o} (${i} in the current buffer)`);
    } finally {
      this.entered = false;
    }
  }
  decodeArrayStream(e) {
    return this.decodeMultiAsync(e, true);
  }
  decodeStream(e) {
    return this.decodeMultiAsync(e, false);
  }
  async *decodeMultiAsync(e, t) {
    if (this.entered) {
      yield* this.clone().decodeMultiAsync(e, t);
      return;
    }
    try {
      this.entered = true;
      let n = t, s = -1;
      for await (const i of e) {
        if (t && s === 0)
          throw this.createExtraByteError(this.totalPos);
        this.appendBuffer(i), n && (s = this.readArraySize(), n = false, this.complete());
        try {
          for (; yield this.doDecodeSync(), --s !== 0; )
            ;
        } catch (o) {
          if (!(o instanceof RangeError))
            throw o;
        }
        this.totalPos += this.pos;
      }
    } finally {
      this.entered = false;
    }
  }
  doDecodeSync() {
    e: for (; ; ) {
      const e = this.readHeadByte();
      let t;
      if (e >= 224)
        t = e - 256;
      else if (e < 192)
        if (e < 128)
          t = e;
        else if (e < 144) {
          const s = e - 128;
          if (s !== 0) {
            this.pushMapState(s), this.complete();
            continue e;
          } else
            t = {};
        } else if (e < 160) {
          const s = e - 144;
          if (s !== 0) {
            this.pushArrayState(s), this.complete();
            continue e;
          } else
            t = [];
        } else {
          const s = e - 160;
          t = this.decodeString(s, 0);
        }
      else if (e === 192)
        t = null;
      else if (e === 194)
        t = false;
      else if (e === 195)
        t = true;
      else if (e === 202)
        t = this.readF32();
      else if (e === 203)
        t = this.readF64();
      else if (e === 204)
        t = this.readU8();
      else if (e === 205)
        t = this.readU16();
      else if (e === 206)
        t = this.readU32();
      else if (e === 207)
        this.useBigInt64 ? t = this.readU64AsBigInt() : t = this.readU64();
      else if (e === 208)
        t = this.readI8();
      else if (e === 209)
        t = this.readI16();
      else if (e === 210)
        t = this.readI32();
      else if (e === 211)
        this.useBigInt64 ? t = this.readI64AsBigInt() : t = this.readI64();
      else if (e === 217) {
        const s = this.lookU8();
        t = this.decodeString(s, 1);
      } else if (e === 218) {
        const s = this.lookU16();
        t = this.decodeString(s, 2);
      } else if (e === 219) {
        const s = this.lookU32();
        t = this.decodeString(s, 4);
      } else if (e === 220) {
        const s = this.readU16();
        if (s !== 0) {
          this.pushArrayState(s), this.complete();
          continue e;
        } else
          t = [];
      } else if (e === 221) {
        const s = this.readU32();
        if (s !== 0) {
          this.pushArrayState(s), this.complete();
          continue e;
        } else
          t = [];
      } else if (e === 222) {
        const s = this.readU16();
        if (s !== 0) {
          this.pushMapState(s), this.complete();
          continue e;
        } else
          t = {};
      } else if (e === 223) {
        const s = this.readU32();
        if (s !== 0) {
          this.pushMapState(s), this.complete();
          continue e;
        } else
          t = {};
      } else if (e === 196) {
        const s = this.lookU8();
        t = this.decodeBinary(s, 1);
      } else if (e === 197) {
        const s = this.lookU16();
        t = this.decodeBinary(s, 2);
      } else if (e === 198) {
        const s = this.lookU32();
        t = this.decodeBinary(s, 4);
      } else if (e === 212)
        t = this.decodeExtension(1, 0);
      else if (e === 213)
        t = this.decodeExtension(2, 0);
      else if (e === 214)
        t = this.decodeExtension(4, 0);
      else if (e === 215)
        t = this.decodeExtension(8, 0);
      else if (e === 216)
        t = this.decodeExtension(16, 0);
      else if (e === 199) {
        const s = this.lookU8();
        t = this.decodeExtension(s, 1);
      } else if (e === 200) {
        const s = this.lookU16();
        t = this.decodeExtension(s, 2);
      } else if (e === 201) {
        const s = this.lookU32();
        t = this.decodeExtension(s, 4);
      } else
        throw new Zt(`Unrecognized type byte: ${kc(e)}`);
      this.complete();
      const n = this.stack;
      for (; n.length > 0; ) {
        const s = n.top();
        if (s.type === Iu)
          if (s.array[s.position] = t, s.position++, s.position === s.size)
            t = s.array, n.release(s);
          else
            continue e;
        else if (s.type === ws) {
          if (t === "__proto__")
            throw new Zt("The key __proto__ is not allowed");
          s.key = this.mapKeyConverter(t), s.type = L0;
          continue e;
        } else if (s.map[s.key] = t, s.readCount++, s.readCount === s.size)
          t = s.map, n.release(s);
        else {
          s.key = null, s.type = ws;
          continue e;
        }
      }
      return t;
    }
  }
  readHeadByte() {
    return this.headByte === ns && (this.headByte = this.readU8()), this.headByte;
  }
  complete() {
    this.headByte = ns;
  }
  readArraySize() {
    const e = this.readHeadByte();
    switch (e) {
      case 220:
        return this.readU16();
      case 221:
        return this.readU32();
      default: {
        if (e < 160)
          return e - 144;
        throw new Zt(`Unrecognized array type byte: ${kc(e)}`);
      }
    }
  }
  pushMapState(e) {
    if (e > this.maxMapLength)
      throw new Zt(`Max length exceeded: map length (${e}) > maxMapLengthLength (${this.maxMapLength})`);
    this.stack.pushMapState(e);
  }
  pushArrayState(e) {
    if (e > this.maxArrayLength)
      throw new Zt(`Max length exceeded: array length (${e}) > maxArrayLength (${this.maxArrayLength})`);
    this.stack.pushArrayState(e);
  }
  decodeString(e, t) {
    return !this.rawStrings || this.stateIsMapKey() ? this.decodeUtf8String(e, t) : this.decodeBinary(e, t);
  }
  /**
   * @throws {@link RangeError}
   */
  decodeUtf8String(e, t) {
    var i;
    if (e > this.maxStrLength)
      throw new Zt(`Max length exceeded: UTF-8 byte length (${e}) > maxStrLength (${this.maxStrLength})`);
    if (this.bytes.byteLength < this.pos + t + e)
      throw Oh;
    const n = this.pos + t;
    let s;
    return this.stateIsMapKey() && ((i = this.keyDecoder) != null && i.canBeCached(e)) ? s = this.keyDecoder.decode(this.bytes, n, e) : s = jD(this.bytes, n, e), this.pos += t + e, s;
  }
  stateIsMapKey() {
    return this.stack.length > 0 ? this.stack.top().type === ws : false;
  }
  /**
   * @throws {@link RangeError}
   */
  decodeBinary(e, t) {
    if (e > this.maxBinLength)
      throw new Zt(`Max length exceeded: bin length (${e}) > maxBinLength (${this.maxBinLength})`);
    if (!this.hasRemaining(e + t))
      throw Oh;
    const n = this.pos + t, s = this.bytes.subarray(n, n + e);
    return this.pos += t + e, s;
  }
  decodeExtension(e, t) {
    if (e > this.maxExtLength)
      throw new Zt(`Max length exceeded: ext length (${e}) > maxExtLength (${this.maxExtLength})`);
    const n = this.view.getInt8(this.pos + t), s = this.decodeBinary(
      e,
      t + 1
      /* extType */
    );
    return this.extensionCodec.decode(s, n, this.context);
  }
  lookU8() {
    return this.view.getUint8(this.pos);
  }
  lookU16() {
    return this.view.getUint16(this.pos);
  }
  lookU32() {
    return this.view.getUint32(this.pos);
  }
  readU8() {
    const e = this.view.getUint8(this.pos);
    return this.pos++, e;
  }
  readI8() {
    const e = this.view.getInt8(this.pos);
    return this.pos++, e;
  }
  readU16() {
    const e = this.view.getUint16(this.pos);
    return this.pos += 2, e;
  }
  readI16() {
    const e = this.view.getInt16(this.pos);
    return this.pos += 2, e;
  }
  readU32() {
    const e = this.view.getUint32(this.pos);
    return this.pos += 4, e;
  }
  readI32() {
    const e = this.view.getInt32(this.pos);
    return this.pos += 4, e;
  }
  readU64() {
    const e = LD(this.view, this.pos);
    return this.pos += 8, e;
  }
  readI64() {
    const e = j0(this.view, this.pos);
    return this.pos += 8, e;
  }
  readU64AsBigInt() {
    const e = this.view.getBigUint64(this.pos);
    return this.pos += 8, e;
  }
  readI64AsBigInt() {
    const e = this.view.getBigInt64(this.pos);
    return this.pos += 8, e;
  }
  readF32() {
    const e = this.view.getFloat32(this.pos);
    return this.pos += 4, e;
  }
  readF64() {
    const e = this.view.getFloat64(this.pos);
    return this.pos += 8, e;
  }
};
function nT(r, e) {
  return new rT(e).decode(r);
}
function Tl(r) {
  return globalThis.Buffer != null ? new Uint8Array(r.buffer, r.byteOffset, r.byteLength) : r;
}
function k0(r = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? Tl(globalThis.Buffer.allocUnsafe(r)) : new Uint8Array(r);
}
function ms(r, e) {
  e || (e = r.reduce((s, i) => s + i.length, 0));
  const t = k0(e);
  let n = 0;
  for (const s of r)
    t.set(s, n), n += s.length;
  return Tl(t);
}
function iT(r, e) {
  if (r.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var t = new Uint8Array(256), n = 0; n < t.length; n++)
    t[n] = 255;
  for (var s = 0; s < r.length; s++) {
    var i = r.charAt(s), o = i.charCodeAt(0);
    if (t[o] !== 255)
      throw new TypeError(i + " is ambiguous");
    t[o] = s;
  }
  var a = r.length, u = r.charAt(0), c = Math.log(a) / Math.log(256), l = Math.log(256) / Math.log(a);
  function d(g) {
    if (g instanceof Uint8Array || (ArrayBuffer.isView(g) ? g = new Uint8Array(g.buffer, g.byteOffset, g.byteLength) : Array.isArray(g) && (g = Uint8Array.from(g))), !(g instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (g.length === 0)
      return "";
    for (var p = 0, b = 0, _ = 0, D = g.length; _ !== D && g[_] === 0; )
      _++, p++;
    for (var v = (D - _) * l + 1 >>> 0, E = new Uint8Array(v); _ !== D; ) {
      for (var A = g[_], k = 0, U = v - 1; (A !== 0 || k < b) && U !== -1; U--, k++)
        A += 256 * E[U] >>> 0, E[U] = A % a >>> 0, A = A / a >>> 0;
      if (A !== 0)
        throw new Error("Non-zero carry");
      b = k, _++;
    }
    for (var P = v - b; P !== v && E[P] === 0; )
      P++;
    for (var $ = u.repeat(p); P < v; ++P)
      $ += r.charAt(E[P]);
    return $;
  }
  function h(g) {
    if (typeof g != "string")
      throw new TypeError("Expected String");
    if (g.length === 0)
      return new Uint8Array();
    var p = 0;
    if (g[p] !== " ") {
      for (var b = 0, _ = 0; g[p] === u; )
        b++, p++;
      for (var D = (g.length - p) * c + 1 >>> 0, v = new Uint8Array(D); g[p]; ) {
        var E = t[g.charCodeAt(p)];
        if (E === 255)
          return;
        for (var A = 0, k = D - 1; (E !== 0 || A < _) && k !== -1; k--, A++)
          E += a * v[k] >>> 0, v[k] = E % 256 >>> 0, E = E / 256 >>> 0;
        if (E !== 0)
          throw new Error("Non-zero carry");
        _ = A, p++;
      }
      if (g[p] !== " ") {
        for (var U = D - _; U !== D && v[U] === 0; )
          U++;
        for (var P = new Uint8Array(b + (D - U)), $ = b; U !== D; )
          P[$++] = v[U++];
        return P;
      }
    }
  }
  function f(g) {
    var p = h(g);
    if (p)
      return p;
    throw new Error(`Non-${e} character`);
  }
  return {
    encode: d,
    decodeUnsafe: h,
    decode: f
  };
}
var sT = iT;
var oT = sT;
var aT = (r) => {
  if (r instanceof Uint8Array && r.constructor.name === "Uint8Array")
    return r;
  if (r instanceof ArrayBuffer)
    return new Uint8Array(r);
  if (ArrayBuffer.isView(r))
    return new Uint8Array(r.buffer, r.byteOffset, r.byteLength);
  throw new Error("Unknown type, must be binary type");
};
var cT = (r) => new TextEncoder().encode(r);
var uT = (r) => new TextDecoder().decode(r);
var lT = class {
  constructor(e, t, n) {
    this.name = e, this.prefix = t, this.baseEncode = n;
  }
  encode(e) {
    if (e instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
};
var dT = class {
  constructor(e, t, n) {
    if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = t.codePointAt(0), this.baseDecode = n;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  or(e) {
    return U0(this, e);
  }
};
var hT = class {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return U0(this, e);
  }
  decode(e) {
    const t = e[0], n = this.decoders[t];
    if (n)
      return n.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
var U0 = (r, e) => new hT({
  ...r.decoders || { [r.prefix]: r },
  ...e.decoders || { [e.prefix]: e }
});
var fT = class {
  constructor(e, t, n, s) {
    this.name = e, this.prefix = t, this.baseEncode = n, this.baseDecode = s, this.encoder = new lT(e, t, n), this.decoder = new dT(e, t, s);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
};
var Fa = ({ name: r, prefix: e, encode: t, decode: n }) => new fT(r, e, t, n);
var Rs = ({ prefix: r, name: e, alphabet: t }) => {
  const { encode: n, decode: s } = oT(t, e);
  return Fa({
    prefix: r,
    name: e,
    encode: n,
    decode: (i) => aT(s(i))
  });
};
var pT = (r, e, t, n) => {
  const s = {};
  for (let l = 0; l < e.length; ++l)
    s[e[l]] = l;
  let i = r.length;
  for (; r[i - 1] === "="; )
    --i;
  const o = new Uint8Array(i * t / 8 | 0);
  let a = 0, u = 0, c = 0;
  for (let l = 0; l < i; ++l) {
    const d = s[r[l]];
    if (d === void 0)
      throw new SyntaxError(`Non-${n} character`);
    u = u << t | d, a += t, a >= 8 && (a -= 8, o[c++] = 255 & u >> a);
  }
  if (a >= t || 255 & u << 8 - a)
    throw new SyntaxError("Unexpected end of data");
  return o;
};
var gT = (r, e, t) => {
  const n = e[e.length - 1] === "=", s = (1 << t) - 1;
  let i = "", o = 0, a = 0;
  for (let u = 0; u < r.length; ++u)
    for (a = a << 8 | r[u], o += 8; o > t; )
      o -= t, i += e[s & a >> o];
  if (o && (i += e[s & a << t - o]), n)
    for (; i.length * t & 7; )
      i += "=";
  return i;
};
var Et = ({ name: r, prefix: e, bitsPerChar: t, alphabet: n }) => Fa({
  prefix: e,
  name: r,
  encode(s) {
    return gT(s, n, t);
  },
  decode(s) {
    return pT(s, n, t, r);
  }
});
var yT = Fa({
  prefix: "\0",
  name: "identity",
  encode: (r) => uT(r),
  decode: (r) => cT(r)
});
var wT = Object.freeze(Object.defineProperty({
  __proto__: null,
  identity: yT
}, Symbol.toStringTag, { value: "Module" }));
var mT = Et({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});
var bT = Object.freeze(Object.defineProperty({
  __proto__: null,
  base2: mT
}, Symbol.toStringTag, { value: "Module" }));
var vT = Et({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});
var MT = Object.freeze(Object.defineProperty({
  __proto__: null,
  base8: vT
}, Symbol.toStringTag, { value: "Module" }));
var ET = Rs({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});
var NT = Object.freeze(Object.defineProperty({
  __proto__: null,
  base10: ET
}, Symbol.toStringTag, { value: "Module" }));
var xT = Et({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var IT = Et({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});
var _T = Object.freeze(Object.defineProperty({
  __proto__: null,
  base16: xT,
  base16upper: IT
}, Symbol.toStringTag, { value: "Module" }));
var DT = Et({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var TT = Et({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var AT = Et({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var OT = Et({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var ST = Et({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var jT = Et({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var CT = Et({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var LT = Et({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var zT = Et({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});
var kT = Object.freeze(Object.defineProperty({
  __proto__: null,
  base32: DT,
  base32hex: ST,
  base32hexpad: CT,
  base32hexpadupper: LT,
  base32hexupper: jT,
  base32pad: AT,
  base32padupper: OT,
  base32upper: TT,
  base32z: zT
}, Symbol.toStringTag, { value: "Module" }));
var UT = Rs({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var PT = Rs({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});
var BT = Object.freeze(Object.defineProperty({
  __proto__: null,
  base36: UT,
  base36upper: PT
}, Symbol.toStringTag, { value: "Module" }));
var RT = Rs({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var $T = Rs({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});
var FT = Object.freeze(Object.defineProperty({
  __proto__: null,
  base58btc: RT,
  base58flickr: $T
}, Symbol.toStringTag, { value: "Module" }));
var QT = Et({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var qT = Et({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var YT = Et({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var VT = Et({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});
var HT = Object.freeze(Object.defineProperty({
  __proto__: null,
  base64: QT,
  base64pad: qT,
  base64url: YT,
  base64urlpad: VT
}, Symbol.toStringTag, { value: "Module" }));
var P0 = Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂");
var GT = P0.reduce((r, e, t) => (r[t] = e, r), []);
var WT = P0.reduce((r, e, t) => (r[e.codePointAt(0)] = t, r), []);
function KT(r) {
  return r.reduce((e, t) => (e += GT[t], e), "");
}
function XT(r) {
  const e = [];
  for (const t of r) {
    const n = WT[t.codePointAt(0)];
    if (n === void 0)
      throw new Error(`Non-base256emoji character: ${t}`);
    e.push(n);
  }
  return new Uint8Array(e);
}
var ZT = Fa({
  prefix: "🚀",
  name: "base256emoji",
  encode: KT,
  decode: XT
});
var JT = Object.freeze(Object.defineProperty({
  __proto__: null,
  base256emoji: ZT
}, Symbol.toStringTag, { value: "Module" }));
new TextEncoder();
new TextDecoder();
var Sh = {
  ...wT,
  ...bT,
  ...MT,
  ...NT,
  ..._T,
  ...kT,
  ...BT,
  ...FT,
  ...HT,
  ...JT
};
function B0(r, e, t, n) {
  return {
    name: r,
    prefix: e,
    encoder: {
      name: r,
      prefix: e,
      encode: t
    },
    decoder: { decode: n }
  };
}
var jh = B0("utf8", "u", (r) => "u" + new TextDecoder("utf8").decode(r), (r) => new TextEncoder().encode(r.substring(1)));
var Uc = B0("ascii", "a", (r) => {
  let e = "a";
  for (let t = 0; t < r.length; t++)
    e += String.fromCharCode(r[t]);
  return e;
}, (r) => {
  r = r.substring(1);
  const e = k0(r.length);
  for (let t = 0; t < r.length; t++)
    e[t] = r.charCodeAt(t);
  return e;
});
var R0 = {
  utf8: jh,
  "utf-8": jh,
  hex: Sh.base16,
  latin1: Uc,
  ascii: Uc,
  binary: Uc,
  ...Sh
};
function dr(r, e = "utf8") {
  const t = R0[e];
  if (!t)
    throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? Tl(globalThis.Buffer.from(r, "utf-8")) : t.decoder.decode(`${t.prefix}${r}`);
}
function Ht(r, e = "utf8") {
  const t = R0[e];
  if (!t)
    throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(r.buffer, r.byteOffset, r.byteLength).toString("utf8") : t.encoder.encode(r).substring(1);
}
var eA = { waku: { publish: "waku_publish", batchPublish: "waku_batchPublish", subscribe: "waku_subscribe", batchSubscribe: "waku_batchSubscribe", subscription: "waku_subscription", unsubscribe: "waku_unsubscribe", batchUnsubscribe: "waku_batchUnsubscribe", batchFetchMessages: "waku_batchFetchMessages" }, irn: { publish: "irn_publish", batchPublish: "irn_batchPublish", subscribe: "irn_subscribe", batchSubscribe: "irn_batchSubscribe", subscription: "irn_subscription", unsubscribe: "irn_unsubscribe", batchUnsubscribe: "irn_batchUnsubscribe", batchFetchMessages: "irn_batchFetchMessages" }, iridium: { publish: "iridium_publish", batchPublish: "iridium_batchPublish", subscribe: "iridium_subscribe", batchSubscribe: "iridium_batchSubscribe", subscription: "iridium_subscription", unsubscribe: "iridium_unsubscribe", batchUnsubscribe: "iridium_batchUnsubscribe", batchFetchMessages: "iridium_batchFetchMessages" } };
var tA = "Input must be an string, Buffer or Uint8Array";
function rA(r) {
  let e;
  if (r instanceof Uint8Array)
    e = r;
  else if (typeof r == "string")
    e = new TextEncoder().encode(r);
  else
    throw new Error(tA);
  return e;
}
function nA(r) {
  return Array.prototype.map.call(r, function(e) {
    return (e < 16 ? "0" : "") + e.toString(16);
  }).join("");
}
function ho(r) {
  return (4294967296 + r).toString(16).substring(1);
}
function iA(r, e, t) {
  let n = `
` + r + " = ";
  for (let s = 0; s < e.length; s += 2) {
    if (t === 32)
      n += ho(e[s]).toUpperCase(), n += " ", n += ho(e[s + 1]).toUpperCase();
    else if (t === 64)
      n += ho(e[s + 1]).toUpperCase(), n += ho(e[s]).toUpperCase();
    else throw new Error("Invalid size " + t);
    s % 6 === 4 ? n += `
` + new Array(r.length + 4).join(" ") : s < e.length - 2 && (n += " ");
  }
  console.log(n);
}
function sA(r, e, t) {
  let n = (/* @__PURE__ */ new Date()).getTime();
  const s = new Uint8Array(e);
  for (let o = 0; o < e; o++)
    s[o] = o % 256;
  const i = (/* @__PURE__ */ new Date()).getTime();
  console.log("Generated random input in " + (i - n) + "ms"), n = i;
  for (let o = 0; o < t; o++) {
    const a = r(s), u = (/* @__PURE__ */ new Date()).getTime(), c = u - n;
    n = u, console.log("Hashed in " + c + "ms: " + a.substring(0, 20) + "..."), console.log(
      Math.round(e / (1 << 20) / (c / 1e3) * 100) / 100 + " MB PER SECOND"
    );
  }
}
var $0 = {
  normalizeInput: rA,
  toHex: nA,
  debugPrint: iA,
  testSpeed: sA
};
var _o = $0;
function fo(r, e, t) {
  const n = r[e] + r[t];
  let s = r[e + 1] + r[t + 1];
  n >= 4294967296 && s++, r[e] = n, r[e + 1] = s;
}
function Ch(r, e, t, n) {
  let s = r[e] + t;
  t < 0 && (s += 4294967296);
  let i = r[e + 1] + n;
  s >= 4294967296 && i++, r[e] = s, r[e + 1] = i;
}
function F0(r, e) {
  return r[e] ^ r[e + 1] << 8 ^ r[e + 2] << 16 ^ r[e + 3] << 24;
}
function an(r, e, t, n, s, i) {
  const o = fs[s], a = fs[s + 1], u = fs[i], c = fs[i + 1];
  fo(ve, r, e), Ch(ve, r, o, a);
  let l = ve[n] ^ ve[r], d = ve[n + 1] ^ ve[r + 1];
  ve[n] = d, ve[n + 1] = l, fo(ve, t, n), l = ve[e] ^ ve[t], d = ve[e + 1] ^ ve[t + 1], ve[e] = l >>> 24 ^ d << 8, ve[e + 1] = d >>> 24 ^ l << 8, fo(ve, r, e), Ch(ve, r, u, c), l = ve[n] ^ ve[r], d = ve[n + 1] ^ ve[r + 1], ve[n] = l >>> 16 ^ d << 16, ve[n + 1] = d >>> 16 ^ l << 16, fo(ve, t, n), l = ve[e] ^ ve[t], d = ve[e + 1] ^ ve[t + 1], ve[e] = d >>> 31 ^ l << 1, ve[e + 1] = l >>> 31 ^ d << 1;
}
var Q0 = new Uint32Array([
  4089235720,
  1779033703,
  2227873595,
  3144134277,
  4271175723,
  1013904242,
  1595750129,
  2773480762,
  2917565137,
  1359893119,
  725511199,
  2600822924,
  4215389547,
  528734635,
  327033209,
  1541459225
]);
var oA = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3,
  11,
  8,
  12,
  0,
  5,
  2,
  15,
  13,
  10,
  14,
  3,
  6,
  7,
  1,
  9,
  4,
  7,
  9,
  3,
  1,
  13,
  12,
  11,
  14,
  2,
  6,
  5,
  10,
  4,
  0,
  15,
  8,
  9,
  0,
  5,
  7,
  2,
  4,
  10,
  15,
  14,
  1,
  11,
  12,
  6,
  8,
  3,
  13,
  2,
  12,
  6,
  10,
  0,
  11,
  8,
  3,
  4,
  13,
  7,
  5,
  15,
  14,
  1,
  9,
  12,
  5,
  1,
  15,
  14,
  13,
  4,
  10,
  0,
  7,
  6,
  3,
  9,
  2,
  8,
  11,
  13,
  11,
  7,
  14,
  12,
  1,
  3,
  9,
  5,
  0,
  15,
  4,
  8,
  6,
  2,
  10,
  6,
  15,
  14,
  9,
  11,
  3,
  0,
  8,
  12,
  2,
  13,
  7,
  1,
  4,
  10,
  5,
  10,
  2,
  8,
  4,
  7,
  6,
  1,
  5,
  15,
  11,
  9,
  14,
  3,
  12,
  13,
  0,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3
];
var xt = new Uint8Array(
  oA.map(function(r) {
    return r * 2;
  })
);
var ve = new Uint32Array(32);
var fs = new Uint32Array(32);
function q0(r, e) {
  let t = 0;
  for (t = 0; t < 16; t++)
    ve[t] = r.h[t], ve[t + 16] = Q0[t];
  for (ve[24] = ve[24] ^ r.t, ve[25] = ve[25] ^ r.t / 4294967296, e && (ve[28] = ~ve[28], ve[29] = ~ve[29]), t = 0; t < 32; t++)
    fs[t] = F0(r.b, 4 * t);
  for (t = 0; t < 12; t++)
    an(0, 8, 16, 24, xt[t * 16 + 0], xt[t * 16 + 1]), an(2, 10, 18, 26, xt[t * 16 + 2], xt[t * 16 + 3]), an(4, 12, 20, 28, xt[t * 16 + 4], xt[t * 16 + 5]), an(6, 14, 22, 30, xt[t * 16 + 6], xt[t * 16 + 7]), an(0, 10, 20, 30, xt[t * 16 + 8], xt[t * 16 + 9]), an(2, 12, 22, 24, xt[t * 16 + 10], xt[t * 16 + 11]), an(4, 14, 16, 26, xt[t * 16 + 12], xt[t * 16 + 13]), an(6, 8, 18, 28, xt[t * 16 + 14], xt[t * 16 + 15]);
  for (t = 0; t < 16; t++)
    r.h[t] = r.h[t] ^ ve[t] ^ ve[t + 16];
}
var cn = new Uint8Array([
  0,
  0,
  0,
  0,
  //  0: outlen, keylen, fanout, depth
  0,
  0,
  0,
  0,
  //  4: leaf length, sequential mode
  0,
  0,
  0,
  0,
  //  8: node offset
  0,
  0,
  0,
  0,
  // 12: node offset
  0,
  0,
  0,
  0,
  // 16: node depth, inner length, rfu
  0,
  0,
  0,
  0,
  // 20: rfu
  0,
  0,
  0,
  0,
  // 24: rfu
  0,
  0,
  0,
  0,
  // 28: rfu
  0,
  0,
  0,
  0,
  // 32: salt
  0,
  0,
  0,
  0,
  // 36: salt
  0,
  0,
  0,
  0,
  // 40: salt
  0,
  0,
  0,
  0,
  // 44: salt
  0,
  0,
  0,
  0,
  // 48: personal
  0,
  0,
  0,
  0,
  // 52: personal
  0,
  0,
  0,
  0,
  // 56: personal
  0,
  0,
  0,
  0
  // 60: personal
]);
function Y0(r, e, t, n) {
  if (r === 0 || r > 64)
    throw new Error("Illegal output length, expected 0 < length <= 64");
  if (e && e.length > 64)
    throw new Error("Illegal key, expected Uint8Array with 0 < length <= 64");
  if (t && t.length !== 16)
    throw new Error("Illegal salt, expected Uint8Array with length is 16");
  if (n && n.length !== 16)
    throw new Error("Illegal personal, expected Uint8Array with length is 16");
  const s = {
    b: new Uint8Array(128),
    h: new Uint32Array(16),
    t: 0,
    // input count
    c: 0,
    // pointer within buffer
    outlen: r
    // output length in bytes
  };
  cn.fill(0), cn[0] = r, e && (cn[1] = e.length), cn[2] = 1, cn[3] = 1, t && cn.set(t, 32), n && cn.set(n, 48);
  for (let i = 0; i < 16; i++)
    s.h[i] = Q0[i] ^ F0(cn, i * 4);
  return e && (Al(s, e), s.c = 128), s;
}
function Al(r, e) {
  for (let t = 0; t < e.length; t++)
    r.c === 128 && (r.t += r.c, q0(r, false), r.c = 0), r.b[r.c++] = e[t];
}
function V0(r) {
  for (r.t += r.c; r.c < 128; )
    r.b[r.c++] = 0;
  q0(r, true);
  const e = new Uint8Array(r.outlen);
  for (let t = 0; t < r.outlen; t++)
    e[t] = r.h[t >> 2] >> 8 * (t & 3);
  return e;
}
function H0(r, e, t, n, s) {
  t = t || 64, r = _o.normalizeInput(r), n && (n = _o.normalizeInput(n)), s && (s = _o.normalizeInput(s));
  const i = Y0(t, e, n, s);
  return Al(i, r), V0(i);
}
function aA(r, e, t, n, s) {
  const i = H0(r, e, t, n, s);
  return _o.toHex(i);
}
var cA = {
  blake2b: H0,
  blake2bHex: aA,
  blake2bInit: Y0,
  blake2bUpdate: Al,
  blake2bFinal: V0
};
var G0 = $0;
function uA(r, e) {
  return r[e] ^ r[e + 1] << 8 ^ r[e + 2] << 16 ^ r[e + 3] << 24;
}
function un(r, e, t, n, s, i) {
  je[r] = je[r] + je[e] + s, je[n] = po(je[n] ^ je[r], 16), je[t] = je[t] + je[n], je[e] = po(je[e] ^ je[t], 12), je[r] = je[r] + je[e] + i, je[n] = po(je[n] ^ je[r], 8), je[t] = je[t] + je[n], je[e] = po(je[e] ^ je[t], 7);
}
function po(r, e) {
  return r >>> e ^ r << 32 - e;
}
var W0 = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var It = new Uint8Array([
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3,
  11,
  8,
  12,
  0,
  5,
  2,
  15,
  13,
  10,
  14,
  3,
  6,
  7,
  1,
  9,
  4,
  7,
  9,
  3,
  1,
  13,
  12,
  11,
  14,
  2,
  6,
  5,
  10,
  4,
  0,
  15,
  8,
  9,
  0,
  5,
  7,
  2,
  4,
  10,
  15,
  14,
  1,
  11,
  12,
  6,
  8,
  3,
  13,
  2,
  12,
  6,
  10,
  0,
  11,
  8,
  3,
  4,
  13,
  7,
  5,
  15,
  14,
  1,
  9,
  12,
  5,
  1,
  15,
  14,
  13,
  4,
  10,
  0,
  7,
  6,
  3,
  9,
  2,
  8,
  11,
  13,
  11,
  7,
  14,
  12,
  1,
  3,
  9,
  5,
  0,
  15,
  4,
  8,
  6,
  2,
  10,
  6,
  15,
  14,
  9,
  11,
  3,
  0,
  8,
  12,
  2,
  13,
  7,
  1,
  4,
  10,
  5,
  10,
  2,
  8,
  4,
  7,
  6,
  1,
  5,
  15,
  11,
  9,
  14,
  3,
  12,
  13,
  0
]);
var je = new Uint32Array(16);
var wt = new Uint32Array(16);
function K0(r, e) {
  let t = 0;
  for (t = 0; t < 8; t++)
    je[t] = r.h[t], je[t + 8] = W0[t];
  for (je[12] ^= r.t, je[13] ^= r.t / 4294967296, e && (je[14] = ~je[14]), t = 0; t < 16; t++)
    wt[t] = uA(r.b, 4 * t);
  for (t = 0; t < 10; t++)
    un(0, 4, 8, 12, wt[It[t * 16 + 0]], wt[It[t * 16 + 1]]), un(1, 5, 9, 13, wt[It[t * 16 + 2]], wt[It[t * 16 + 3]]), un(2, 6, 10, 14, wt[It[t * 16 + 4]], wt[It[t * 16 + 5]]), un(3, 7, 11, 15, wt[It[t * 16 + 6]], wt[It[t * 16 + 7]]), un(0, 5, 10, 15, wt[It[t * 16 + 8]], wt[It[t * 16 + 9]]), un(1, 6, 11, 12, wt[It[t * 16 + 10]], wt[It[t * 16 + 11]]), un(2, 7, 8, 13, wt[It[t * 16 + 12]], wt[It[t * 16 + 13]]), un(3, 4, 9, 14, wt[It[t * 16 + 14]], wt[It[t * 16 + 15]]);
  for (t = 0; t < 8; t++)
    r.h[t] ^= je[t] ^ je[t + 8];
}
function X0(r, e) {
  if (!(r > 0 && r <= 32))
    throw new Error("Incorrect output length, should be in [1, 32]");
  const t = e ? e.length : 0;
  if (e && !(t > 0 && t <= 32))
    throw new Error("Incorrect key length, should be in [1, 32]");
  const n = {
    h: new Uint32Array(W0),
    // hash state
    b: new Uint8Array(64),
    // input block
    c: 0,
    // pointer within block
    t: 0,
    // input count
    outlen: r
    // output length in bytes
  };
  return n.h[0] ^= 16842752 ^ t << 8 ^ r, t > 0 && (Ol(n, e), n.c = 64), n;
}
function Ol(r, e) {
  for (let t = 0; t < e.length; t++)
    r.c === 64 && (r.t += r.c, K0(r, false), r.c = 0), r.b[r.c++] = e[t];
}
function Z0(r) {
  for (r.t += r.c; r.c < 64; )
    r.b[r.c++] = 0;
  K0(r, true);
  const e = new Uint8Array(r.outlen);
  for (let t = 0; t < r.outlen; t++)
    e[t] = r.h[t >> 2] >> 8 * (t & 3) & 255;
  return e;
}
function J0(r, e, t) {
  t = t || 32, r = G0.normalizeInput(r);
  const n = X0(t, e);
  return Ol(n, r), Z0(n);
}
function lA(r, e, t) {
  const n = J0(r, e, t);
  return G0.toHex(n);
}
var dA = {
  blake2s: J0,
  blake2sHex: lA,
  blake2sInit: X0,
  blake2sUpdate: Ol,
  blake2sFinal: Z0
};
var is = cA;
var ss = dA;
var hA = {
  blake2b: is.blake2b,
  blake2bHex: is.blake2bHex,
  blake2bInit: is.blake2bInit,
  blake2bUpdate: is.blake2bUpdate,
  blake2bFinal: is.blake2bFinal,
  blake2s: ss.blake2s,
  blake2sHex: ss.blake2sHex,
  blake2sInit: ss.blake2sInit,
  blake2sUpdate: ss.blake2sUpdate,
  blake2sFinal: ss.blake2sFinal
};
var fA = ":";
function Do(r) {
  const [e, t] = r.split(fA);
  return { namespace: e, reference: t };
}
function ey(r, e) {
  return r.includes(":") ? [r] : e.chains || [];
}
var pA = Object.defineProperty;
var gA = Object.defineProperties;
var yA = Object.getOwnPropertyDescriptors;
var Lh = Object.getOwnPropertySymbols;
var wA = Object.prototype.hasOwnProperty;
var mA = Object.prototype.propertyIsEnumerable;
var _u = (r, e, t) => e in r ? pA(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;
var zh = (r, e) => {
  for (var t in e || (e = {})) wA.call(e, t) && _u(r, t, e[t]);
  if (Lh) for (var t of Lh(e)) mA.call(e, t) && _u(r, t, e[t]);
  return r;
};
var bA = (r, e) => gA(r, yA(e));
var kh = (r, e, t) => _u(r, typeof e != "symbol" ? e + "" : e, t);
var vA = "ReactNative";
var er = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" };
var MA = "js";
function Vo() {
  return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
}
function Sn() {
  return !ri() && !!yl() && navigator.product === vA;
}
function EA() {
  return Sn() && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u" && (global == null ? void 0 : global.Platform.OS) === "android";
}
function NA() {
  return Sn() && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u" && (global == null ? void 0 : global.Platform.OS) === "ios";
}
function qi() {
  return !Vo() && !!yl() && !!ri();
}
function $s() {
  return Sn() ? er.reactNative : Vo() ? er.node : qi() ? er.browser : er.unknown;
}
function Uh() {
  var r;
  try {
    return Sn() && typeof global < "u" && typeof (global == null ? void 0 : global.Application) < "u" ? (r = global.Application) == null ? void 0 : r.applicationId : void 0;
  } catch {
    return;
  }
}
function xA(r, e) {
  const t = new URLSearchParams(r);
  return Object.entries(e).sort(([n], [s]) => n.localeCompare(s)).forEach(([n, s]) => {
    s != null && t.set(n, String(s));
  }), t.toString();
}
function IA(r) {
  var e, t;
  const n = ty();
  try {
    return r != null && r.url && n.url && new URL(r.url).host !== new URL(n.url).host && (console.warn(`The configured WalletConnect 'metadata.url':${r.url} differs from the actual page url:${n.url}. This is probably unintended and can lead to issues.`), r.url = n.url), (e = r == null ? void 0 : r.icons) != null && e.length && r.icons.length > 0 && (r.icons = r.icons.filter((s) => s !== "")), bA(zh(zh({}, n), r), { url: (r == null ? void 0 : r.url) || n.url, name: (r == null ? void 0 : r.name) || n.name, description: (r == null ? void 0 : r.description) || n.description, icons: (t = r == null ? void 0 : r.icons) != null && t.length && r.icons.length > 0 ? r.icons : n.icons });
  } catch (s) {
    return console.warn("Error populating app metadata", s), r || n;
  }
}
function ty() {
  return Hg() || { name: "", description: "", url: "", icons: [""] };
}
function _A() {
  if ($s() === er.reactNative && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u") {
    const { OS: t, Version: n } = global.Platform;
    return [t, n].join("-");
  }
  const r = Xx();
  if (r === null) return "unknown";
  const e = r.os ? r.os.replace(" ", "").toLowerCase() : "unknown";
  return r.type === "browser" ? [e, r.name, r.version].join("-") : [e, r.version].join("-");
}
function DA() {
  var r;
  const e = $s();
  return e === er.browser ? [e, ((r = Vg()) == null ? void 0 : r.host) || "unknown"].join(":") : e;
}
function ry(r, e, t) {
  const n = _A(), s = DA();
  return [[r, e].join("-"), [MA, t].join("-"), n, s].join("/");
}
function TA({ protocol: r, version: e, relayUrl: t, sdkVersion: n, auth: s, projectId: i, useOnCloseEvent: o, bundleId: a, packageName: u }) {
  const c = t.split("?"), l = ry(r, e, n), d = { auth: s, ua: l, projectId: i, useOnCloseEvent: o, packageName: u || void 0, bundleId: a || void 0 }, h = xA(c[1] || "", d);
  return c[0] + "?" + h;
}
function Wn(r, e) {
  return r.filter((t) => e.includes(t)).length === r.length;
}
function Du(r) {
  return Object.fromEntries(r.entries());
}
function Tu(r) {
  return new Map(Object.entries(r));
}
function Qn(r = ce.FIVE_MINUTES, e) {
  const t = ce.toMiliseconds(r || ce.FIVE_MINUTES);
  let n, s, i, o;
  return { resolve: (a) => {
    i && n && (clearTimeout(i), n(a), o = Promise.resolve(a));
  }, reject: (a) => {
    i && s && (clearTimeout(i), s(a));
  }, done: () => new Promise((a, u) => {
    if (o) return a(o);
    i = setTimeout(() => {
      const c = new Error(e);
      o = Promise.reject(c), u(c);
    }, t), n = a, s = u;
  }) };
}
function Cr(r, e, t) {
  return new Promise(async (n, s) => {
    const i = setTimeout(() => s(new Error(t)), e);
    try {
      const o = await r;
      n(o);
    } catch (o) {
      s(o);
    }
    clearTimeout(i);
  });
}
function ny(r, e) {
  if (typeof e == "string" && e.startsWith(`${r}:`)) return e;
  if (r.toLowerCase() === "topic") {
    if (typeof e != "string") throw new Error('Value must be "string" for expirer target type: topic');
    return `topic:${e}`;
  } else if (r.toLowerCase() === "id") {
    if (typeof e != "number") throw new Error('Value must be "number" for expirer target type: id');
    return `id:${e}`;
  }
  throw new Error(`Unknown expirer target type: ${r}`);
}
function AA(r) {
  return ny("topic", r);
}
function OA(r) {
  return ny("id", r);
}
function iy(r) {
  const [e, t] = r.split(":"), n = { id: void 0, topic: void 0 };
  if (e === "topic" && typeof t == "string") n.topic = t;
  else if (e === "id" && Number.isInteger(Number(t))) n.id = Number(t);
  else throw new Error(`Invalid target, expected id:number or topic:string, got ${e}:${t}`);
  return n;
}
function ot(r, e) {
  return ce.fromMiliseconds(Date.now() + ce.toMiliseconds(r));
}
function wn(r) {
  return Date.now() >= ce.toMiliseconds(r);
}
function Le(r, e) {
  return `${r}${e ? `:${e}` : ""}`;
}
function ei(r = [], e = []) {
  return [.../* @__PURE__ */ new Set([...r, ...e])];
}
async function SA({ id: r, topic: e, wcDeepLink: t }) {
  var n;
  try {
    if (!t) return;
    const s = typeof t == "string" ? JSON.parse(t) : t, i = s == null ? void 0 : s.href;
    if (typeof i != "string") return;
    const o = jA(i, r, e), a = $s();
    if (a === er.browser) {
      if (!((n = ri()) != null && n.hasFocus())) {
        console.warn("Document does not have focus, skipping deeplink.");
        return;
      }
      CA(o);
    } else a === er.reactNative && typeof (global == null ? void 0 : global.Linking) < "u" && await global.Linking.openURL(o);
  } catch (s) {
    console.error(s);
  }
}
function jA(r, e, t) {
  const n = `requestId=${e}&sessionTopic=${t}`;
  r.endsWith("/") && (r = r.slice(0, -1));
  let s = `${r}`;
  if (r.startsWith("https://t.me")) {
    const i = r.includes("?") ? "&startapp=" : "?startapp=";
    s = `${s}${i}${UA(n, true)}`;
  } else s = `${s}/wc?${n}`;
  return s;
}
function CA(r) {
  let e = "_self";
  kA() ? e = "_top" : (zA() || r.startsWith("https://") || r.startsWith("http://")) && (e = "_blank"), window.open(r, e, "noreferrer noopener");
}
async function LA(r, e) {
  let t = "";
  try {
    if (qi() && (t = localStorage.getItem(e), t)) return t;
    t = await r.getItem(e);
  } catch (n) {
    console.error(n);
  }
  return t;
}
function Ph(r, e) {
  if (!r.includes(e)) return null;
  const t = r.split(/([&,?,=])/), n = t.indexOf(e);
  return t[n + 2];
}
function Bh() {
  return typeof crypto < "u" && crypto != null && crypto.randomUUID ? crypto.randomUUID() : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, (r) => {
    const e = Math.random() * 16 | 0;
    return (r === "x" ? e : e & 3 | 8).toString(16);
  });
}
function Sl() {
  return typeof process < "u" && process.env.IS_VITEST === "true";
}
function zA() {
  return typeof window < "u" && (!!window.TelegramWebviewProxy || !!window.Telegram || !!window.TelegramWebviewProxyProto);
}
function kA() {
  try {
    return window.self !== window.top;
  } catch {
    return false;
  }
}
function UA(r, e = false) {
  const t = Buffer.from(r).toString("base64");
  return e ? t.replace(/[=]/g, "") : t;
}
function sy(r) {
  return Buffer.from(r, "base64").toString("utf-8");
}
function PA(r) {
  return new Promise((e) => setTimeout(e, r));
}
var BA = class {
  constructor({ limit: e }) {
    kh(this, "limit"), kh(this, "set"), this.limit = e, this.set = /* @__PURE__ */ new Set();
  }
  add(e) {
    if (!this.set.has(e)) {
      if (this.set.size >= this.limit) {
        const t = this.set.values().next().value;
        t && this.set.delete(t);
      }
      this.set.add(e);
    }
  }
  has(e) {
    return this.set.has(e);
  }
};
var go = BigInt(2 ** 32 - 1);
var Rh = BigInt(32);
function oy(r, e = false) {
  return e ? { h: Number(r & go), l: Number(r >> Rh & go) } : { h: Number(r >> Rh & go) | 0, l: Number(r & go) | 0 };
}
function ay(r, e = false) {
  const t = r.length;
  let n = new Uint32Array(t), s = new Uint32Array(t);
  for (let i = 0; i < t; i++) {
    const { h: o, l: a } = oy(r[i], e);
    [n[i], s[i]] = [o, a];
  }
  return [n, s];
}
var $h = (r, e, t) => r >>> t;
var Fh = (r, e, t) => r << 32 - t | e >>> t;
var mn = (r, e, t) => r >>> t | e << 32 - t;
var bn = (r, e, t) => r << 32 - t | e >>> t;
var ps = (r, e, t) => r << 64 - t | e >>> t - 32;
var gs = (r, e, t) => r >>> t - 32 | e << 64 - t;
var RA = (r, e) => e;
var $A = (r, e) => r;
var FA = (r, e, t) => r << t | e >>> 32 - t;
var QA = (r, e, t) => e << t | r >>> 32 - t;
var qA = (r, e, t) => e << t - 32 | r >>> 64 - t;
var YA = (r, e, t) => r << t - 32 | e >>> 64 - t;
function mr(r, e, t, n) {
  const s = (e >>> 0) + (n >>> 0);
  return { h: r + t + (s / 2 ** 32 | 0) | 0, l: s | 0 };
}
var jl = (r, e, t) => (r >>> 0) + (e >>> 0) + (t >>> 0);
var Cl = (r, e, t, n) => e + t + n + (r / 2 ** 32 | 0) | 0;
var VA = (r, e, t, n) => (r >>> 0) + (e >>> 0) + (t >>> 0) + (n >>> 0);
var HA = (r, e, t, n, s) => e + t + n + s + (r / 2 ** 32 | 0) | 0;
var GA = (r, e, t, n, s) => (r >>> 0) + (e >>> 0) + (t >>> 0) + (n >>> 0) + (s >>> 0);
var WA = (r, e, t, n, s, i) => e + t + n + s + i + (r / 2 ** 32 | 0) | 0;
var bi = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
function Qa(r) {
  return r instanceof Uint8Array || ArrayBuffer.isView(r) && r.constructor.name === "Uint8Array";
}
function en(r) {
  if (!Number.isSafeInteger(r) || r < 0) throw new Error("positive integer expected, got " + r);
}
function Mr(r, ...e) {
  if (!Qa(r)) throw new Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(r.length)) throw new Error("Uint8Array expected of length " + e + ", got length=" + r.length);
}
function qa(r) {
  if (typeof r != "function" || typeof r.create != "function") throw new Error("Hash should be wrapped by utils.createHasher");
  en(r.outputLen), en(r.blockLen);
}
function On(r, e = true) {
  if (r.destroyed) throw new Error("Hash instance has been destroyed");
  if (e && r.finished) throw new Error("Hash#digest() has already been called");
}
function Ll(r, e) {
  Mr(r);
  const t = e.outputLen;
  if (r.length < t) throw new Error("digestInto() expects output buffer of length at least " + t);
}
function As(r) {
  return new Uint32Array(r.buffer, r.byteOffset, Math.floor(r.byteLength / 4));
}
function hr(...r) {
  for (let e = 0; e < r.length; e++) r[e].fill(0);
}
function Pc(r) {
  return new DataView(r.buffer, r.byteOffset, r.byteLength);
}
function Ir(r, e) {
  return r << 32 - e | r >>> e;
}
var cy = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function uy(r) {
  return r << 24 & 4278190080 | r << 8 & 16711680 | r >>> 8 & 65280 | r >>> 24 & 255;
}
var Qr = cy ? (r) => r : (r) => uy(r);
function KA(r) {
  for (let e = 0; e < r.length; e++) r[e] = uy(r[e]);
  return r;
}
var vn = cy ? (r) => r : KA;
var ly = typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function";
var XA = Array.from({ length: 256 }, (r, e) => e.toString(16).padStart(2, "0"));
function Si(r) {
  if (Mr(r), ly) return r.toHex();
  let e = "";
  for (let t = 0; t < r.length; t++) e += XA[r[t]];
  return e;
}
var Br = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function Qh(r) {
  if (r >= Br._0 && r <= Br._9) return r - Br._0;
  if (r >= Br.A && r <= Br.F) return r - (Br.A - 10);
  if (r >= Br.a && r <= Br.f) return r - (Br.a - 10);
}
function Ho(r) {
  if (typeof r != "string") throw new Error("hex string expected, got " + typeof r);
  if (ly) return Uint8Array.fromHex(r);
  const e = r.length, t = e / 2;
  if (e % 2) throw new Error("hex string expected, got unpadded hex of length " + e);
  const n = new Uint8Array(t);
  for (let s = 0, i = 0; s < t; s++, i += 2) {
    const o = Qh(r.charCodeAt(i)), a = Qh(r.charCodeAt(i + 1));
    if (o === void 0 || a === void 0) {
      const u = r[i] + r[i + 1];
      throw new Error('hex string expected, got non-hex character "' + u + '" at index ' + i);
    }
    n[s] = o * 16 + a;
  }
  return n;
}
function dy(r) {
  if (typeof r != "string") throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(r));
}
function br(r) {
  return typeof r == "string" && (r = dy(r)), Mr(r), r;
}
function En(...r) {
  let e = 0;
  for (let n = 0; n < r.length; n++) {
    const s = r[n];
    Mr(s), e += s.length;
  }
  const t = new Uint8Array(e);
  for (let n = 0, s = 0; n < r.length; n++) {
    const i = r[n];
    t.set(i, s), s += i.length;
  }
  return t;
}
var Ya = class {
};
function Fs(r) {
  const e = (n) => r().update(br(n)).digest(), t = r();
  return e.outputLen = t.outputLen, e.blockLen = t.blockLen, e.create = () => r(), e;
}
function ZA(r) {
  const e = (n, s) => r(s).update(br(n)).digest(), t = r({});
  return e.outputLen = t.outputLen, e.blockLen = t.blockLen, e.create = (n) => r(n), e;
}
function hi(r = 32) {
  if (bi && typeof bi.getRandomValues == "function") return bi.getRandomValues(new Uint8Array(r));
  if (bi && typeof bi.randomBytes == "function") return Uint8Array.from(bi.randomBytes(r));
  throw new Error("crypto.getRandomValues must be defined");
}
var JA = BigInt(0);
var os = BigInt(1);
var e4 = BigInt(2);
var t4 = BigInt(7);
var r4 = BigInt(256);
var n4 = BigInt(113);
var hy = [];
var fy = [];
var py = [];
for (let r = 0, e = os, t = 1, n = 0; r < 24; r++) {
  [t, n] = [n, (2 * t + 3 * n) % 5], hy.push(2 * (5 * n + t)), fy.push((r + 1) * (r + 2) / 2 % 64);
  let s = JA;
  for (let i = 0; i < 7; i++) e = (e << os ^ (e >> t4) * n4) % r4, e & e4 && (s ^= os << (os << BigInt(i)) - os);
  py.push(s);
}
var gy = ay(py, true);
var i4 = gy[0];
var s4 = gy[1];
var qh = (r, e, t) => t > 32 ? qA(r, e, t) : FA(r, e, t);
var Yh = (r, e, t) => t > 32 ? YA(r, e, t) : QA(r, e, t);
function o4(r, e = 24) {
  const t = new Uint32Array(10);
  for (let n = 24 - e; n < 24; n++) {
    for (let o = 0; o < 10; o++) t[o] = r[o] ^ r[o + 10] ^ r[o + 20] ^ r[o + 30] ^ r[o + 40];
    for (let o = 0; o < 10; o += 2) {
      const a = (o + 8) % 10, u = (o + 2) % 10, c = t[u], l = t[u + 1], d = qh(c, l, 1) ^ t[a], h = Yh(c, l, 1) ^ t[a + 1];
      for (let f = 0; f < 50; f += 10) r[o + f] ^= d, r[o + f + 1] ^= h;
    }
    let s = r[2], i = r[3];
    for (let o = 0; o < 24; o++) {
      const a = fy[o], u = qh(s, i, a), c = Yh(s, i, a), l = hy[o];
      s = r[l], i = r[l + 1], r[l] = u, r[l + 1] = c;
    }
    for (let o = 0; o < 50; o += 10) {
      for (let a = 0; a < 10; a++) t[a] = r[o + a];
      for (let a = 0; a < 10; a++) r[o + a] ^= ~t[(a + 2) % 10] & t[(a + 4) % 10];
    }
    r[0] ^= i4[n], r[1] ^= s4[n];
  }
  hr(t);
}
var a4 = class yy extends Ya {
  constructor(e, t, n, s = false, i = 24) {
    if (super(), this.pos = 0, this.posOut = 0, this.finished = false, this.destroyed = false, this.enableXOF = false, this.blockLen = e, this.suffix = t, this.outputLen = n, this.enableXOF = s, this.rounds = i, en(n), !(0 < e && e < 200)) throw new Error("only keccak-f1600 function is supported");
    this.state = new Uint8Array(200), this.state32 = As(this.state);
  }
  clone() {
    return this._cloneInto();
  }
  keccak() {
    vn(this.state32), o4(this.state32, this.rounds), vn(this.state32), this.posOut = 0, this.pos = 0;
  }
  update(e) {
    On(this), e = br(e), Mr(e);
    const { blockLen: t, state: n } = this, s = e.length;
    for (let i = 0; i < s; ) {
      const o = Math.min(t - this.pos, s - i);
      for (let a = 0; a < o; a++) n[this.pos++] ^= e[i++];
      this.pos === t && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished) return;
    this.finished = true;
    const { state: e, suffix: t, pos: n, blockLen: s } = this;
    e[n] ^= t, t & 128 && n === s - 1 && this.keccak(), e[s - 1] ^= 128, this.keccak();
  }
  writeInto(e) {
    On(this, false), Mr(e), this.finish();
    const t = this.state, { blockLen: n } = this;
    for (let s = 0, i = e.length; s < i; ) {
      this.posOut >= n && this.keccak();
      const o = Math.min(n - this.posOut, i - s);
      e.set(t.subarray(this.posOut, this.posOut + o), s), this.posOut += o, s += o;
    }
    return e;
  }
  xofInto(e) {
    if (!this.enableXOF) throw new Error("XOF is not possible for this instance");
    return this.writeInto(e);
  }
  xof(e) {
    return en(e), this.xofInto(new Uint8Array(e));
  }
  digestInto(e) {
    if (Ll(e, this), this.finished) throw new Error("digest() was already called");
    return this.writeInto(e), this.destroy(), e;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true, hr(this.state);
  }
  _cloneInto(e) {
    const { blockLen: t, suffix: n, outputLen: s, rounds: i, enableXOF: o } = this;
    return e || (e = new yy(t, n, s, o, i)), e.state32.set(this.state32), e.pos = this.pos, e.posOut = this.posOut, e.finished = this.finished, e.rounds = i, e.suffix = n, e.outputLen = s, e.enableXOF = o, e.destroyed = this.destroyed, e;
  }
};
var c4 = (r, e, t) => Fs(() => new a4(e, r, t));
var u4 = c4(1, 136, 256 / 8);
function l4(r, e, t, n) {
  if (typeof r.setBigUint64 == "function") return r.setBigUint64(e, t, n);
  const s = BigInt(32), i = BigInt(4294967295), o = Number(t >> s & i), a = Number(t & i), u = n ? 4 : 0, c = n ? 0 : 4;
  r.setUint32(e + u, o, n), r.setUint32(e + c, a, n);
}
function d4(r, e, t) {
  return r & e ^ ~r & t;
}
function h4(r, e, t) {
  return r & e ^ r & t ^ e & t;
}
var wy = class extends Ya {
  constructor(e, t, n, s) {
    super(), this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.blockLen = e, this.outputLen = t, this.padOffset = n, this.isLE = s, this.buffer = new Uint8Array(e), this.view = Pc(this.buffer);
  }
  update(e) {
    On(this), e = br(e), Mr(e);
    const { view: t, buffer: n, blockLen: s } = this, i = e.length;
    for (let o = 0; o < i; ) {
      const a = Math.min(s - this.pos, i - o);
      if (a === s) {
        const u = Pc(e);
        for (; s <= i - o; o += s) this.process(u, o);
        continue;
      }
      n.set(e.subarray(o, o + a), this.pos), this.pos += a, o += a, this.pos === s && (this.process(t, 0), this.pos = 0);
    }
    return this.length += e.length, this.roundClean(), this;
  }
  digestInto(e) {
    On(this), Ll(e, this), this.finished = true;
    const { buffer: t, view: n, blockLen: s, isLE: i } = this;
    let { pos: o } = this;
    t[o++] = 128, hr(this.buffer.subarray(o)), this.padOffset > s - o && (this.process(n, 0), o = 0);
    for (let d = o; d < s; d++) t[d] = 0;
    l4(n, s - 8, BigInt(this.length * 8), i), this.process(n, 0);
    const a = Pc(e), u = this.outputLen;
    if (u % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
    const c = u / 4, l = this.get();
    if (c > l.length) throw new Error("_sha2: outputLen bigger than state");
    for (let d = 0; d < c; d++) a.setUint32(4 * d, l[d], i);
  }
  digest() {
    const { buffer: e, outputLen: t } = this;
    this.digestInto(e);
    const n = e.slice(0, t);
    return this.destroy(), n;
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get());
    const { blockLen: t, buffer: n, length: s, finished: i, destroyed: o, pos: a } = this;
    return e.destroyed = o, e.finished = i, e.length = s, e.pos = a, s % t && e.buffer.set(n), e;
  }
  clone() {
    return this._cloneInto();
  }
};
var ln = Uint32Array.from([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]);
var _t = Uint32Array.from([3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428]);
var Dt = Uint32Array.from([1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209]);
var f4 = Uint32Array.from([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]);
var dn = new Uint32Array(64);
var p4 = class extends wy {
  constructor(e = 32) {
    super(64, e, 8, false), this.A = ln[0] | 0, this.B = ln[1] | 0, this.C = ln[2] | 0, this.D = ln[3] | 0, this.E = ln[4] | 0, this.F = ln[5] | 0, this.G = ln[6] | 0, this.H = ln[7] | 0;
  }
  get() {
    const { A: e, B: t, C: n, D: s, E: i, F: o, G: a, H: u } = this;
    return [e, t, n, s, i, o, a, u];
  }
  set(e, t, n, s, i, o, a, u) {
    this.A = e | 0, this.B = t | 0, this.C = n | 0, this.D = s | 0, this.E = i | 0, this.F = o | 0, this.G = a | 0, this.H = u | 0;
  }
  process(e, t) {
    for (let d = 0; d < 16; d++, t += 4) dn[d] = e.getUint32(t, false);
    for (let d = 16; d < 64; d++) {
      const h = dn[d - 15], f = dn[d - 2], g = Ir(h, 7) ^ Ir(h, 18) ^ h >>> 3, p = Ir(f, 17) ^ Ir(f, 19) ^ f >>> 10;
      dn[d] = p + dn[d - 7] + g + dn[d - 16] | 0;
    }
    let { A: n, B: s, C: i, D: o, E: a, F: u, G: c, H: l } = this;
    for (let d = 0; d < 64; d++) {
      const h = Ir(a, 6) ^ Ir(a, 11) ^ Ir(a, 25), f = l + h + d4(a, u, c) + f4[d] + dn[d] | 0, g = (Ir(n, 2) ^ Ir(n, 13) ^ Ir(n, 22)) + h4(n, s, i) | 0;
      l = c, c = u, u = a, a = o + f | 0, o = i, i = s, s = n, n = f + g | 0;
    }
    n = n + this.A | 0, s = s + this.B | 0, i = i + this.C | 0, o = o + this.D | 0, a = a + this.E | 0, u = u + this.F | 0, c = c + this.G | 0, l = l + this.H | 0, this.set(n, s, i, o, a, u, c, l);
  }
  roundClean() {
    hr(dn);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), hr(this.buffer);
  }
};
var my = ay(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map((r) => BigInt(r)));
var g4 = my[0];
var y4 = my[1];
var hn = new Uint32Array(80);
var fn = new Uint32Array(80);
var zl = class extends wy {
  constructor(e = 64) {
    super(128, e, 16, false), this.Ah = Dt[0] | 0, this.Al = Dt[1] | 0, this.Bh = Dt[2] | 0, this.Bl = Dt[3] | 0, this.Ch = Dt[4] | 0, this.Cl = Dt[5] | 0, this.Dh = Dt[6] | 0, this.Dl = Dt[7] | 0, this.Eh = Dt[8] | 0, this.El = Dt[9] | 0, this.Fh = Dt[10] | 0, this.Fl = Dt[11] | 0, this.Gh = Dt[12] | 0, this.Gl = Dt[13] | 0, this.Hh = Dt[14] | 0, this.Hl = Dt[15] | 0;
  }
  get() {
    const { Ah: e, Al: t, Bh: n, Bl: s, Ch: i, Cl: o, Dh: a, Dl: u, Eh: c, El: l, Fh: d, Fl: h, Gh: f, Gl: g, Hh: p, Hl: b } = this;
    return [e, t, n, s, i, o, a, u, c, l, d, h, f, g, p, b];
  }
  set(e, t, n, s, i, o, a, u, c, l, d, h, f, g, p, b) {
    this.Ah = e | 0, this.Al = t | 0, this.Bh = n | 0, this.Bl = s | 0, this.Ch = i | 0, this.Cl = o | 0, this.Dh = a | 0, this.Dl = u | 0, this.Eh = c | 0, this.El = l | 0, this.Fh = d | 0, this.Fl = h | 0, this.Gh = f | 0, this.Gl = g | 0, this.Hh = p | 0, this.Hl = b | 0;
  }
  process(e, t) {
    for (let v = 0; v < 16; v++, t += 4) hn[v] = e.getUint32(t), fn[v] = e.getUint32(t += 4);
    for (let v = 16; v < 80; v++) {
      const E = hn[v - 15] | 0, A = fn[v - 15] | 0, k = mn(E, A, 1) ^ mn(E, A, 8) ^ $h(E, A, 7), U = bn(E, A, 1) ^ bn(E, A, 8) ^ Fh(E, A, 7), P = hn[v - 2] | 0, $ = fn[v - 2] | 0, ee = mn(P, $, 19) ^ ps(P, $, 61) ^ $h(P, $, 6), G = bn(P, $, 19) ^ gs(P, $, 61) ^ Fh(P, $, 6), H = VA(U, G, fn[v - 7], fn[v - 16]), R = HA(H, k, ee, hn[v - 7], hn[v - 16]);
      hn[v] = R | 0, fn[v] = H | 0;
    }
    let { Ah: n, Al: s, Bh: i, Bl: o, Ch: a, Cl: u, Dh: c, Dl: l, Eh: d, El: h, Fh: f, Fl: g, Gh: p, Gl: b, Hh: _, Hl: D } = this;
    for (let v = 0; v < 80; v++) {
      const E = mn(d, h, 14) ^ mn(d, h, 18) ^ ps(d, h, 41), A = bn(d, h, 14) ^ bn(d, h, 18) ^ gs(d, h, 41), k = d & f ^ ~d & p, U = h & g ^ ~h & b, P = GA(D, A, U, y4[v], fn[v]), $ = WA(P, _, E, k, g4[v], hn[v]), ee = P | 0, G = mn(n, s, 28) ^ ps(n, s, 34) ^ ps(n, s, 39), H = bn(n, s, 28) ^ gs(n, s, 34) ^ gs(n, s, 39), R = n & i ^ n & a ^ i & a, z = s & o ^ s & u ^ o & u;
      _ = p | 0, D = b | 0, p = f | 0, b = g | 0, f = d | 0, g = h | 0, { h: d, l: h } = mr(c | 0, l | 0, $ | 0, ee | 0), c = a | 0, l = u | 0, a = i | 0, u = o | 0, i = n | 0, o = s | 0;
      const j = jl(ee, H, z);
      n = Cl(j, $, G, R), s = j | 0;
    }
    ({ h: n, l: s } = mr(this.Ah | 0, this.Al | 0, n | 0, s | 0)), { h: i, l: o } = mr(this.Bh | 0, this.Bl | 0, i | 0, o | 0), { h: a, l: u } = mr(this.Ch | 0, this.Cl | 0, a | 0, u | 0), { h: c, l } = mr(this.Dh | 0, this.Dl | 0, c | 0, l | 0), { h: d, l: h } = mr(this.Eh | 0, this.El | 0, d | 0, h | 0), { h: f, l: g } = mr(this.Fh | 0, this.Fl | 0, f | 0, g | 0), { h: p, l: b } = mr(this.Gh | 0, this.Gl | 0, p | 0, b | 0), { h: _, l: D } = mr(this.Hh | 0, this.Hl | 0, _ | 0, D | 0), this.set(n, s, i, o, a, u, c, l, d, h, f, g, p, b, _, D);
  }
  roundClean() {
    hr(hn, fn);
  }
  destroy() {
    hr(this.buffer), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var w4 = class extends zl {
  constructor() {
    super(48), this.Ah = _t[0] | 0, this.Al = _t[1] | 0, this.Bh = _t[2] | 0, this.Bl = _t[3] | 0, this.Ch = _t[4] | 0, this.Cl = _t[5] | 0, this.Dh = _t[6] | 0, this.Dl = _t[7] | 0, this.Eh = _t[8] | 0, this.El = _t[9] | 0, this.Fh = _t[10] | 0, this.Fl = _t[11] | 0, this.Gh = _t[12] | 0, this.Gl = _t[13] | 0, this.Hh = _t[14] | 0, this.Hl = _t[15] | 0;
  }
};
var Tt = Uint32Array.from([573645204, 4230739756, 2673172387, 3360449730, 596883563, 1867755857, 2520282905, 1497426621, 2519219938, 2827943907, 3193839141, 1401305490, 721525244, 746961066, 246885852, 2177182882]);
var m4 = class extends zl {
  constructor() {
    super(32), this.Ah = Tt[0] | 0, this.Al = Tt[1] | 0, this.Bh = Tt[2] | 0, this.Bl = Tt[3] | 0, this.Ch = Tt[4] | 0, this.Cl = Tt[5] | 0, this.Dh = Tt[6] | 0, this.Dl = Tt[7] | 0, this.Eh = Tt[8] | 0, this.El = Tt[9] | 0, this.Fh = Tt[10] | 0, this.Fl = Tt[11] | 0, this.Gh = Tt[12] | 0, this.Gl = Tt[13] | 0, this.Hh = Tt[14] | 0, this.Hl = Tt[15] | 0;
  }
};
var Va = Fs(() => new p4());
var b4 = Fs(() => new zl());
var v4 = Fs(() => new w4());
var M4 = Fs(() => new m4());
var E4 = Uint8Array.from([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9, 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11, 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10, 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5, 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9]);
var st = Uint32Array.from([4089235720, 1779033703, 2227873595, 3144134277, 4271175723, 1013904242, 1595750129, 2773480762, 2917565137, 1359893119, 725511199, 2600822924, 4215389547, 528734635, 327033209, 1541459225]);
var de = new Uint32Array(32);
function pn(r, e, t, n, s, i) {
  const o = s[i], a = s[i + 1];
  let u = de[2 * r], c = de[2 * r + 1], l = de[2 * e], d = de[2 * e + 1], h = de[2 * t], f = de[2 * t + 1], g = de[2 * n], p = de[2 * n + 1], b = jl(u, l, o);
  c = Cl(b, c, d, a), u = b | 0, { Dh: p, Dl: g } = { Dh: p ^ c, Dl: g ^ u }, { Dh: p, Dl: g } = { Dh: RA(p, g), Dl: $A(p) }, { h: f, l: h } = mr(f, h, p, g), { Bh: d, Bl: l } = { Bh: d ^ f, Bl: l ^ h }, { Bh: d, Bl: l } = { Bh: mn(d, l, 24), Bl: bn(d, l, 24) }, de[2 * r] = u, de[2 * r + 1] = c, de[2 * e] = l, de[2 * e + 1] = d, de[2 * t] = h, de[2 * t + 1] = f, de[2 * n] = g, de[2 * n + 1] = p;
}
function gn(r, e, t, n, s, i) {
  const o = s[i], a = s[i + 1];
  let u = de[2 * r], c = de[2 * r + 1], l = de[2 * e], d = de[2 * e + 1], h = de[2 * t], f = de[2 * t + 1], g = de[2 * n], p = de[2 * n + 1], b = jl(u, l, o);
  c = Cl(b, c, d, a), u = b | 0, { Dh: p, Dl: g } = { Dh: p ^ c, Dl: g ^ u }, { Dh: p, Dl: g } = { Dh: mn(p, g, 16), Dl: bn(p, g, 16) }, { h: f, l: h } = mr(f, h, p, g), { Bh: d, Bl: l } = { Bh: d ^ f, Bl: l ^ h }, { Bh: d, Bl: l } = { Bh: ps(d, l, 63), Bl: gs(d, l, 63) }, de[2 * r] = u, de[2 * r + 1] = c, de[2 * e] = l, de[2 * e + 1] = d, de[2 * t] = h, de[2 * t + 1] = f, de[2 * n] = g, de[2 * n + 1] = p;
}
function N4(r, e = {}, t, n, s) {
  if (en(t), r < 0 || r > t) throw new Error("outputLen bigger than keyLen");
  const { key: i, salt: o, personalization: a } = e;
  if (i !== void 0 && (i.length < 1 || i.length > t)) throw new Error("key length must be undefined or 1.." + t);
  if (o !== void 0 && o.length !== n) throw new Error("salt must be undefined or " + n);
  if (a !== void 0 && a.length !== s) throw new Error("personalization must be undefined or " + s);
}
var x4 = class extends Ya {
  constructor(e, t) {
    super(), this.finished = false, this.destroyed = false, this.length = 0, this.pos = 0, en(e), en(t), this.blockLen = e, this.outputLen = t, this.buffer = new Uint8Array(e), this.buffer32 = As(this.buffer);
  }
  update(e) {
    On(this), e = br(e), Mr(e);
    const { blockLen: t, buffer: n, buffer32: s } = this, i = e.length, o = e.byteOffset, a = e.buffer;
    for (let u = 0; u < i; ) {
      this.pos === t && (vn(s), this.compress(s, 0, false), vn(s), this.pos = 0);
      const c = Math.min(t - this.pos, i - u), l = o + u;
      if (c === t && !(l % 4) && u + c < i) {
        const d = new Uint32Array(a, l, Math.floor((i - u) / 4));
        vn(d);
        for (let h = 0; u + t < i; h += s.length, u += t) this.length += t, this.compress(d, h, false);
        vn(d);
        continue;
      }
      n.set(e.subarray(u, u + c), this.pos), this.pos += c, this.length += c, u += c;
    }
    return this;
  }
  digestInto(e) {
    On(this), Ll(e, this);
    const { pos: t, buffer32: n } = this;
    this.finished = true, hr(this.buffer.subarray(t)), vn(n), this.compress(n, 0, true), vn(n);
    const s = As(e);
    this.get().forEach((i, o) => s[o] = Qr(i));
  }
  digest() {
    const { buffer: e, outputLen: t } = this;
    this.digestInto(e);
    const n = e.slice(0, t);
    return this.destroy(), n;
  }
  _cloneInto(e) {
    const { buffer: t, length: n, finished: s, destroyed: i, outputLen: o, pos: a } = this;
    return e || (e = new this.constructor({ dkLen: o })), e.set(...this.get()), e.buffer.set(t), e.destroyed = i, e.finished = s, e.length = n, e.pos = a, e.outputLen = o, e;
  }
  clone() {
    return this._cloneInto();
  }
};
var I4 = class extends x4 {
  constructor(e = {}) {
    const t = e.dkLen === void 0 ? 64 : e.dkLen;
    super(128, t), this.v0l = st[0] | 0, this.v0h = st[1] | 0, this.v1l = st[2] | 0, this.v1h = st[3] | 0, this.v2l = st[4] | 0, this.v2h = st[5] | 0, this.v3l = st[6] | 0, this.v3h = st[7] | 0, this.v4l = st[8] | 0, this.v4h = st[9] | 0, this.v5l = st[10] | 0, this.v5h = st[11] | 0, this.v6l = st[12] | 0, this.v6h = st[13] | 0, this.v7l = st[14] | 0, this.v7h = st[15] | 0, N4(t, e, 64, 16, 16);
    let { key: n, personalization: s, salt: i } = e, o = 0;
    if (n !== void 0 && (n = br(n), o = n.length), this.v0l ^= this.outputLen | o << 8 | 65536 | 1 << 24, i !== void 0) {
      i = br(i);
      const a = As(i);
      this.v4l ^= Qr(a[0]), this.v4h ^= Qr(a[1]), this.v5l ^= Qr(a[2]), this.v5h ^= Qr(a[3]);
    }
    if (s !== void 0) {
      s = br(s);
      const a = As(s);
      this.v6l ^= Qr(a[0]), this.v6h ^= Qr(a[1]), this.v7l ^= Qr(a[2]), this.v7h ^= Qr(a[3]);
    }
    if (n !== void 0) {
      const a = new Uint8Array(this.blockLen);
      a.set(n), this.update(a);
    }
  }
  get() {
    let { v0l: e, v0h: t, v1l: n, v1h: s, v2l: i, v2h: o, v3l: a, v3h: u, v4l: c, v4h: l, v5l: d, v5h: h, v6l: f, v6h: g, v7l: p, v7h: b } = this;
    return [e, t, n, s, i, o, a, u, c, l, d, h, f, g, p, b];
  }
  set(e, t, n, s, i, o, a, u, c, l, d, h, f, g, p, b) {
    this.v0l = e | 0, this.v0h = t | 0, this.v1l = n | 0, this.v1h = s | 0, this.v2l = i | 0, this.v2h = o | 0, this.v3l = a | 0, this.v3h = u | 0, this.v4l = c | 0, this.v4h = l | 0, this.v5l = d | 0, this.v5h = h | 0, this.v6l = f | 0, this.v6h = g | 0, this.v7l = p | 0, this.v7h = b | 0;
  }
  compress(e, t, n) {
    this.get().forEach((u, c) => de[c] = u), de.set(st, 16);
    let { h: s, l: i } = oy(BigInt(this.length));
    de[24] = st[8] ^ i, de[25] = st[9] ^ s, n && (de[28] = ~de[28], de[29] = ~de[29]);
    let o = 0;
    const a = E4;
    for (let u = 0; u < 12; u++) pn(0, 4, 8, 12, e, t + 2 * a[o++]), gn(0, 4, 8, 12, e, t + 2 * a[o++]), pn(1, 5, 9, 13, e, t + 2 * a[o++]), gn(1, 5, 9, 13, e, t + 2 * a[o++]), pn(2, 6, 10, 14, e, t + 2 * a[o++]), gn(2, 6, 10, 14, e, t + 2 * a[o++]), pn(3, 7, 11, 15, e, t + 2 * a[o++]), gn(3, 7, 11, 15, e, t + 2 * a[o++]), pn(0, 5, 10, 15, e, t + 2 * a[o++]), gn(0, 5, 10, 15, e, t + 2 * a[o++]), pn(1, 6, 11, 12, e, t + 2 * a[o++]), gn(1, 6, 11, 12, e, t + 2 * a[o++]), pn(2, 7, 8, 13, e, t + 2 * a[o++]), gn(2, 7, 8, 13, e, t + 2 * a[o++]), pn(3, 4, 9, 14, e, t + 2 * a[o++]), gn(3, 4, 9, 14, e, t + 2 * a[o++]);
    this.v0l ^= de[0] ^ de[16], this.v0h ^= de[1] ^ de[17], this.v1l ^= de[2] ^ de[18], this.v1h ^= de[3] ^ de[19], this.v2l ^= de[4] ^ de[20], this.v2h ^= de[5] ^ de[21], this.v3l ^= de[6] ^ de[22], this.v3h ^= de[7] ^ de[23], this.v4l ^= de[8] ^ de[24], this.v4h ^= de[9] ^ de[25], this.v5l ^= de[10] ^ de[26], this.v5h ^= de[11] ^ de[27], this.v6l ^= de[12] ^ de[28], this.v6h ^= de[13] ^ de[29], this.v7l ^= de[14] ^ de[30], this.v7h ^= de[15] ^ de[31], hr(de);
  }
  destroy() {
    this.destroyed = true, hr(this.buffer32), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var _4 = ZA((r) => new I4(r));
var D4 = "https://rpc.walletconnect.org/v1";
function by(r) {
  const e = `Ethereum Signed Message:
${r.length}`, t = new TextEncoder().encode(e + r);
  return "0x" + Buffer.from(u4(t)).toString("hex");
}
async function T4(r, e, t, n, s, i) {
  switch (t.t) {
    case "eip191":
      return await A4(r, e, t.s);
    case "eip1271":
      return await O4(r, e, t.s, n, s, i);
    default:
      throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${t.t}`);
  }
}
function A4(r, e, t) {
  const n = sD(t);
  return mD({ payload: by(e), signature: n }).toLowerCase() === r.toLowerCase();
}
async function O4(r, e, t, n, s, i) {
  const o = Do(n);
  if (!o.namespace || !o.reference) throw new Error(`isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${n}`);
  try {
    const a = "0x1626ba7e", u = "0000000000000000000000000000000000000000000000000000000000000040", c = t.substring(2), l = (c.length / 2).toString(16).padStart(64, "0"), d = (e.startsWith("0x") ? e : by(e)).substring(2), h = a + d + u + l + c, f = await fetch(`${i || D4}/?chainId=${n}&projectId=${s}`, { headers: { "Content-Type": "application/json" }, method: "POST", body: JSON.stringify({ id: S4(), jsonrpc: "2.0", method: "eth_call", params: [{ to: r, data: h }, "latest"] }) }), { result: g } = await f.json();
    return g ? g.slice(0, a.length).toLowerCase() === a.toLowerCase() : false;
  } catch (a) {
    return console.error("isValidEip1271Signature: ", a), false;
  }
}
function S4() {
  return Date.now() + Math.floor(Math.random() * 1e3);
}
function j4(r) {
  const e = atob(r), t = new Uint8Array(e.length);
  for (let o = 0; o < e.length; o++) t[o] = e.charCodeAt(o);
  const n = t[0];
  if (n === 0) throw new Error("No signatures found");
  const s = 1 + n * 64;
  if (t.length < s) throw new Error("Transaction data too short for claimed signature count");
  if (t.length < 100) throw new Error("Transaction too short");
  const i = Buffer.from(r, "base64").slice(1, 65);
  return Bs.encode(i);
}
function C4(r) {
  const e = new Uint8Array(Buffer.from(r, "base64")), t = Array.from("TransactionData::").map((i) => i.charCodeAt(0)), n = new Uint8Array(t.length + e.length);
  n.set(t), n.set(e, t.length);
  const s = _4(n, { dkLen: 32 });
  return Bs.encode(s);
}
function Vh(r) {
  const e = new Uint8Array(Va(L4(r)));
  return Bs.encode(e);
}
function L4(r) {
  if (r instanceof Uint8Array) return r;
  if (Array.isArray(r)) return new Uint8Array(r);
  if (typeof r == "object" && r != null && r.data) return new Uint8Array(Object.values(r.data));
  if (typeof r == "object" && r) return new Uint8Array(Object.values(r));
  throw new Error("getNearUint8ArrayFromBytes: Unexpected result type from bytes array");
}
function Hh(r) {
  const e = Buffer.from(r, "base64"), t = nT(e).txn;
  if (!t) throw new Error("Invalid signed transaction: missing 'txn' field");
  const n = GD(t), s = Buffer.from("TX"), i = Buffer.concat([s, Buffer.from(n)]), o = M4(i);
  return wD.encode(o).replace(/=+$/, "");
}
function Bc(r) {
  const e = [];
  let t = BigInt(r);
  for (; t >= BigInt(128); ) e.push(Number(t & BigInt(127) | BigInt(128))), t >>= BigInt(7);
  return e.push(Number(t)), Buffer.from(e);
}
function z4(r) {
  const e = Buffer.from(r.signed.bodyBytes, "base64"), t = Buffer.from(r.signed.authInfoBytes, "base64"), n = Buffer.from(r.signature.signature, "base64"), s = [];
  s.push(Buffer.from([10])), s.push(Bc(e.length)), s.push(e), s.push(Buffer.from([18])), s.push(Bc(t.length)), s.push(t), s.push(Buffer.from([26])), s.push(Bc(n.length)), s.push(n);
  const i = Buffer.concat(s), o = Va(i);
  return Buffer.from(o).toString("hex").toUpperCase();
}
function k4(r) {
  var e, t;
  const n = [];
  try {
    if (typeof r == "string") return n.push(r), n;
    if (typeof r != "object") return n;
    r != null && r.id && n.push(r.id);
    const s = (t = (e = r == null ? void 0 : r.capabilities) == null ? void 0 : e.caip345) == null ? void 0 : t.transactionHashes;
    s && n.push(...s);
  } catch (s) {
    console.warn("getWalletSendCallsHashes failed: ", s);
  }
  return n;
}
var U4 = Object.defineProperty;
var P4 = Object.defineProperties;
var B4 = Object.getOwnPropertyDescriptors;
var Gh = Object.getOwnPropertySymbols;
var R4 = Object.prototype.hasOwnProperty;
var $4 = Object.prototype.propertyIsEnumerable;
var Wh = (r, e, t) => e in r ? U4(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;
var F4 = (r, e) => {
  for (var t in e || (e = {})) R4.call(e, t) && Wh(r, t, e[t]);
  if (Gh) for (var t of Gh(e)) $4.call(e, t) && Wh(r, t, e[t]);
  return r;
};
var Q4 = (r, e) => P4(r, B4(e));
var q4 = "did:pkh:";
var kl = (r) => r == null ? void 0 : r.split(":");
var Y4 = (r) => {
  const e = r && kl(r);
  if (e) return r.includes(q4) ? e[3] : e[1];
};
var Au = (r) => {
  const e = r && kl(r);
  if (e) return e[2] + ":" + e[3];
};
var Go = (r) => {
  const e = r && kl(r);
  if (e) return e.pop();
};
async function Kh(r) {
  const { cacao: e, projectId: t } = r, { s: n, p: s } = e, i = vy(s, s.iss), o = Go(s.iss);
  return await T4(o, i, n, Au(s.iss), t);
}
var vy = (r, e) => {
  const t = `${r.domain} wants you to sign in with your Ethereum account:`, n = Go(e);
  if (!r.aud && !r.uri) throw new Error("Either `aud` or `uri` is required to construct the message");
  let s = r.statement || void 0;
  const i = `URI: ${r.aud || r.uri}`, o = `Version: ${r.version}`, a = `Chain ID: ${Y4(e)}`, u = `Nonce: ${r.nonce}`, c = `Issued At: ${r.iat}`, l = r.exp ? `Expiration Time: ${r.exp}` : void 0, d = r.nbf ? `Not Before: ${r.nbf}` : void 0, h = r.requestId ? `Request ID: ${r.requestId}` : void 0, f = r.resources ? `Resources:${r.resources.map((p) => `
- ${p}`).join("")}` : void 0, g = To(r.resources);
  if (g) {
    const p = Os(g);
    s = eO(s, p);
  }
  return [t, n, "", s, "", i, o, a, u, c, l, d, h, f].filter((p) => p != null).join(`
`);
};
function V4(r) {
  return Buffer.from(JSON.stringify(r)).toString("base64");
}
function H4(r) {
  return JSON.parse(Buffer.from(r, "base64").toString("utf-8"));
}
function ii(r) {
  if (!r) throw new Error("No recap provided, value is undefined");
  if (!r.att) throw new Error("No `att` property found");
  const e = Object.keys(r.att);
  if (!(e != null && e.length)) throw new Error("No resources found in `att` property");
  e.forEach((t) => {
    const n = r.att[t];
    if (Array.isArray(n)) throw new Error(`Resource must be an object: ${t}`);
    if (typeof n != "object") throw new Error(`Resource must be an object: ${t}`);
    if (!Object.keys(n).length) throw new Error(`Resource object is empty: ${t}`);
    Object.keys(n).forEach((s) => {
      const i = n[s];
      if (!Array.isArray(i)) throw new Error(`Ability limits ${s} must be an array of objects, found: ${i}`);
      if (!i.length) throw new Error(`Value of ${s} is empty array, must be an array with objects`);
      i.forEach((o) => {
        if (typeof o != "object") throw new Error(`Ability limits (${s}) must be an array of objects, found: ${o}`);
      });
    });
  });
}
function G4(r, e, t, n = {}) {
  return t == null || t.sort((s, i) => s.localeCompare(i)), { att: { [r]: W4(e, t, n) } };
}
function W4(r, e, t = {}) {
  e = e == null ? void 0 : e.sort((s, i) => s.localeCompare(i));
  const n = e.map((s) => ({ [`${r}/${s}`]: [t] }));
  return Object.assign({}, ...n);
}
function My(r) {
  return ii(r), `urn:recap:${V4(r).replace(/=/g, "")}`;
}
function Os(r) {
  const e = H4(r.replace("urn:recap:", ""));
  return ii(e), e;
}
function K4(r, e, t) {
  const n = G4(r, e, t);
  return My(n);
}
function X4(r) {
  return r && r.includes("urn:recap:");
}
function Z4(r, e) {
  const t = Os(r), n = Os(e), s = J4(t, n);
  return My(s);
}
function J4(r, e) {
  ii(r), ii(e);
  const t = Object.keys(r.att).concat(Object.keys(e.att)).sort((s, i) => s.localeCompare(i)), n = { att: {} };
  return t.forEach((s) => {
    var i, o;
    Object.keys(((i = r.att) == null ? void 0 : i[s]) || {}).concat(Object.keys(((o = e.att) == null ? void 0 : o[s]) || {})).sort((a, u) => a.localeCompare(u)).forEach((a) => {
      var u, c;
      n.att[s] = Q4(F4({}, n.att[s]), { [a]: ((u = r.att[s]) == null ? void 0 : u[a]) || ((c = e.att[s]) == null ? void 0 : c[a]) });
    });
  }), n;
}
function eO(r = "", e) {
  ii(e);
  const t = "I further authorize the stated URI to perform the following actions on my behalf: ";
  if (r.includes(t)) return r;
  const n = [];
  let s = 0;
  Object.keys(e.att).forEach((a) => {
    const u = Object.keys(e.att[a]).map((d) => ({ ability: d.split("/")[0], action: d.split("/")[1] }));
    u.sort((d, h) => d.action.localeCompare(h.action));
    const c = {};
    u.forEach((d) => {
      c[d.ability] || (c[d.ability] = []), c[d.ability].push(d.action);
    });
    const l = Object.keys(c).map((d) => (s++, `(${s}) '${d}': '${c[d].join("', '")}' for '${a}'.`));
    n.push(l.join(", ").replace(".,", "."));
  });
  const i = n.join(" "), o = `${t}${i}`;
  return `${r ? r + " " : ""}${o}`;
}
function Xh(r) {
  var e;
  const t = Os(r);
  ii(t);
  const n = (e = t.att) == null ? void 0 : e.eip155;
  return n ? Object.keys(n).map((s) => s.split("/")[1]) : [];
}
function Zh(r) {
  const e = Os(r);
  ii(e);
  const t = [];
  return Object.values(e.att).forEach((n) => {
    Object.values(n).forEach((s) => {
      var i;
      (i = s == null ? void 0 : s[0]) != null && i.chains && t.push(s[0].chains);
    });
  }), [...new Set(t.flat())];
}
function To(r) {
  if (!r) return;
  const e = r == null ? void 0 : r[r.length - 1];
  return X4(e) ? e : void 0;
}
function Ey(r) {
  return r instanceof Uint8Array || ArrayBuffer.isView(r) && r.constructor.name === "Uint8Array";
}
function Ou(r) {
  if (typeof r != "boolean") throw new Error(`boolean expected, not ${r}`);
}
function Rc(r) {
  if (!Number.isSafeInteger(r) || r < 0) throw new Error("positive integer expected, got " + r);
}
function Qt(r, ...e) {
  if (!Ey(r)) throw new Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(r.length)) throw new Error("Uint8Array expected of length " + e + ", got length=" + r.length);
}
function Jh(r, e = true) {
  if (r.destroyed) throw new Error("Hash instance has been destroyed");
  if (e && r.finished) throw new Error("Hash#digest() has already been called");
}
function tO(r, e) {
  Qt(r);
  const t = e.outputLen;
  if (r.length < t) throw new Error("digestInto() expects output buffer of length at least " + t);
}
function Tn(r) {
  return new Uint32Array(r.buffer, r.byteOffset, Math.floor(r.byteLength / 4));
}
function Pi(...r) {
  for (let e = 0; e < r.length; e++) r[e].fill(0);
}
function rO(r) {
  return new DataView(r.buffer, r.byteOffset, r.byteLength);
}
var nO = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function iO(r) {
  if (typeof r != "string") throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(r));
}
function Su(r) {
  if (typeof r == "string") r = iO(r);
  else if (Ey(r)) r = ju(r);
  else throw new Error("Uint8Array expected, got " + typeof r);
  return r;
}
function sO(r, e) {
  if (e == null || typeof e != "object") throw new Error("options must be defined");
  return Object.assign(r, e);
}
function oO(r, e) {
  if (r.length !== e.length) return false;
  let t = 0;
  for (let n = 0; n < r.length; n++) t |= r[n] ^ e[n];
  return t === 0;
}
var aO = (r, e) => {
  function t(n, ...s) {
    if (Qt(n), !nO) throw new Error("Non little-endian hardware is not yet supported");
    if (r.nonceLength !== void 0) {
      const c = s[0];
      if (!c) throw new Error("nonce / iv required");
      r.varSizeNonce ? Qt(c) : Qt(c, r.nonceLength);
    }
    const i = r.tagLength;
    i && s[1] !== void 0 && Qt(s[1]);
    const o = e(n, ...s), a = (c, l) => {
      if (l !== void 0) {
        if (c !== 2) throw new Error("cipher output not supported");
        Qt(l);
      }
    };
    let u = false;
    return { encrypt(c, l) {
      if (u) throw new Error("cannot encrypt() twice with same key + nonce");
      return u = true, Qt(c), a(o.encrypt.length, l), o.encrypt(c, l);
    }, decrypt(c, l) {
      if (Qt(c), i && c.length < i) throw new Error("invalid ciphertext length: smaller than tagLength=" + i);
      return a(o.decrypt.length, l), o.decrypt(c, l);
    } };
  }
  return Object.assign(t, r), t;
};
function ef(r, e, t = true) {
  if (e === void 0) return new Uint8Array(r);
  if (e.length !== r) throw new Error("invalid output length, expected " + r + ", got: " + e.length);
  if (t && !uO(e)) throw new Error("invalid output, must be aligned");
  return e;
}
function tf(r, e, t, n) {
  if (typeof r.setBigUint64 == "function") return r.setBigUint64(e, t, n);
  const s = BigInt(32), i = BigInt(4294967295), o = Number(t >> s & i), a = Number(t & i);
  r.setUint32(e + 4, o, n), r.setUint32(e + 0, a, n);
}
function cO(r, e, t) {
  Ou(t);
  const n = new Uint8Array(16), s = rO(n);
  return tf(s, 0, BigInt(e), t), tf(s, 8, BigInt(r), t), n;
}
function uO(r) {
  return r.byteOffset % 4 === 0;
}
function ju(r) {
  return Uint8Array.from(r);
}
var Ny = (r) => Uint8Array.from(r.split("").map((e) => e.charCodeAt(0)));
var lO = Ny("expand 16-byte k");
var dO = Ny("expand 32-byte k");
var hO = Tn(lO);
var fO = Tn(dO);
function Oe(r, e) {
  return r << e | r >>> 32 - e;
}
function Cu(r) {
  return r.byteOffset % 4 === 0;
}
var yo = 64;
var pO = 16;
var xy = 2 ** 32 - 1;
var rf = new Uint32Array();
function gO(r, e, t, n, s, i, o, a) {
  const u = s.length, c = new Uint8Array(yo), l = Tn(c), d = Cu(s) && Cu(i), h = d ? Tn(s) : rf, f = d ? Tn(i) : rf;
  for (let g = 0; g < u; o++) {
    if (r(e, t, n, l, o, a), o >= xy) throw new Error("arx: counter overflow");
    const p = Math.min(yo, u - g);
    if (d && p === yo) {
      const b = g / 4;
      if (g % 4 !== 0) throw new Error("arx: invalid block position");
      for (let _ = 0, D; _ < pO; _++) D = b + _, f[D] = h[D] ^ l[_];
      g += yo;
      continue;
    }
    for (let b = 0, _; b < p; b++) _ = g + b, i[_] = s[_] ^ c[b];
    g += p;
  }
}
function yO(r, e) {
  const { allowShortKeys: t, extendNonceFn: n, counterLength: s, counterRight: i, rounds: o } = sO({ allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 }, e);
  if (typeof r != "function") throw new Error("core must be a function");
  return Rc(s), Rc(o), Ou(i), Ou(t), (a, u, c, l, d = 0) => {
    Qt(a), Qt(u), Qt(c);
    const h = c.length;
    if (l === void 0 && (l = new Uint8Array(h)), Qt(l), Rc(d), d < 0 || d >= xy) throw new Error("arx: counter overflow");
    if (l.length < h) throw new Error(`arx: output (${l.length}) is shorter than data (${h})`);
    const f = [];
    let g = a.length, p, b;
    if (g === 32) f.push(p = ju(a)), b = fO;
    else if (g === 16 && t) p = new Uint8Array(32), p.set(a), p.set(a, 16), b = hO, f.push(p);
    else throw new Error(`arx: invalid 32-byte key, got length=${g}`);
    Cu(u) || f.push(u = ju(u));
    const _ = Tn(p);
    if (n) {
      if (u.length !== 24) throw new Error("arx: extended nonce must be 24 bytes");
      n(b, _, Tn(u.subarray(0, 16)), _), u = u.subarray(16);
    }
    const D = 16 - s;
    if (D !== u.length) throw new Error(`arx: nonce must be ${D} or 16 bytes`);
    if (D !== 12) {
      const E = new Uint8Array(12);
      E.set(u, i ? 0 : 12 - u.length), u = E, f.push(u);
    }
    const v = Tn(u);
    return gO(r, b, _, v, c, l, d, o), Pi(...f), l;
  };
}
var mt = (r, e) => r[e++] & 255 | (r[e++] & 255) << 8;
var wO = class {
  constructor(e) {
    this.blockLen = 16, this.outputLen = 16, this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.pos = 0, this.finished = false, e = Su(e), Qt(e, 32);
    const t = mt(e, 0), n = mt(e, 2), s = mt(e, 4), i = mt(e, 6), o = mt(e, 8), a = mt(e, 10), u = mt(e, 12), c = mt(e, 14);
    this.r[0] = t & 8191, this.r[1] = (t >>> 13 | n << 3) & 8191, this.r[2] = (n >>> 10 | s << 6) & 7939, this.r[3] = (s >>> 7 | i << 9) & 8191, this.r[4] = (i >>> 4 | o << 12) & 255, this.r[5] = o >>> 1 & 8190, this.r[6] = (o >>> 14 | a << 2) & 8191, this.r[7] = (a >>> 11 | u << 5) & 8065, this.r[8] = (u >>> 8 | c << 8) & 8191, this.r[9] = c >>> 5 & 127;
    for (let l = 0; l < 8; l++) this.pad[l] = mt(e, 16 + 2 * l);
  }
  process(e, t, n = false) {
    const s = n ? 0 : 2048, { h: i, r: o } = this, a = o[0], u = o[1], c = o[2], l = o[3], d = o[4], h = o[5], f = o[6], g = o[7], p = o[8], b = o[9], _ = mt(e, t + 0), D = mt(e, t + 2), v = mt(e, t + 4), E = mt(e, t + 6), A = mt(e, t + 8), k = mt(e, t + 10), U = mt(e, t + 12), P = mt(e, t + 14);
    let $ = i[0] + (_ & 8191), ee = i[1] + ((_ >>> 13 | D << 3) & 8191), G = i[2] + ((D >>> 10 | v << 6) & 8191), H = i[3] + ((v >>> 7 | E << 9) & 8191), R = i[4] + ((E >>> 4 | A << 12) & 8191), z = i[5] + (A >>> 1 & 8191), j = i[6] + ((A >>> 14 | k << 2) & 8191), I = i[7] + ((k >>> 11 | U << 5) & 8191), y = i[8] + ((U >>> 8 | P << 8) & 8191), m = i[9] + (P >>> 5 | s), N = 0, T = N + $ * a + ee * (5 * b) + G * (5 * p) + H * (5 * g) + R * (5 * f);
    N = T >>> 13, T &= 8191, T += z * (5 * h) + j * (5 * d) + I * (5 * l) + y * (5 * c) + m * (5 * u), N += T >>> 13, T &= 8191;
    let x = N + $ * u + ee * a + G * (5 * b) + H * (5 * p) + R * (5 * g);
    N = x >>> 13, x &= 8191, x += z * (5 * f) + j * (5 * h) + I * (5 * d) + y * (5 * l) + m * (5 * c), N += x >>> 13, x &= 8191;
    let L = N + $ * c + ee * u + G * a + H * (5 * b) + R * (5 * p);
    N = L >>> 13, L &= 8191, L += z * (5 * g) + j * (5 * f) + I * (5 * h) + y * (5 * d) + m * (5 * l), N += L >>> 13, L &= 8191;
    let V = N + $ * l + ee * c + G * u + H * a + R * (5 * b);
    N = V >>> 13, V &= 8191, V += z * (5 * p) + j * (5 * g) + I * (5 * f) + y * (5 * h) + m * (5 * d), N += V >>> 13, V &= 8191;
    let q = N + $ * d + ee * l + G * c + H * u + R * a;
    N = q >>> 13, q &= 8191, q += z * (5 * b) + j * (5 * p) + I * (5 * g) + y * (5 * f) + m * (5 * h), N += q >>> 13, q &= 8191;
    let K = N + $ * h + ee * d + G * l + H * c + R * u;
    N = K >>> 13, K &= 8191, K += z * a + j * (5 * b) + I * (5 * p) + y * (5 * g) + m * (5 * f), N += K >>> 13, K &= 8191;
    let Z = N + $ * f + ee * h + G * d + H * l + R * c;
    N = Z >>> 13, Z &= 8191, Z += z * u + j * a + I * (5 * b) + y * (5 * p) + m * (5 * g), N += Z >>> 13, Z &= 8191;
    let re = N + $ * g + ee * f + G * h + H * d + R * l;
    N = re >>> 13, re &= 8191, re += z * c + j * u + I * a + y * (5 * b) + m * (5 * p), N += re >>> 13, re &= 8191;
    let ne = N + $ * p + ee * g + G * f + H * h + R * d;
    N = ne >>> 13, ne &= 8191, ne += z * l + j * c + I * u + y * a + m * (5 * b), N += ne >>> 13, ne &= 8191;
    let se = N + $ * b + ee * p + G * g + H * f + R * h;
    N = se >>> 13, se &= 8191, se += z * d + j * l + I * c + y * u + m * a, N += se >>> 13, se &= 8191, N = (N << 2) + N | 0, N = N + T | 0, T = N & 8191, N = N >>> 13, x += N, i[0] = T, i[1] = x, i[2] = L, i[3] = V, i[4] = q, i[5] = K, i[6] = Z, i[7] = re, i[8] = ne, i[9] = se;
  }
  finalize() {
    const { h: e, pad: t } = this, n = new Uint16Array(10);
    let s = e[1] >>> 13;
    e[1] &= 8191;
    for (let a = 2; a < 10; a++) e[a] += s, s = e[a] >>> 13, e[a] &= 8191;
    e[0] += s * 5, s = e[0] >>> 13, e[0] &= 8191, e[1] += s, s = e[1] >>> 13, e[1] &= 8191, e[2] += s, n[0] = e[0] + 5, s = n[0] >>> 13, n[0] &= 8191;
    for (let a = 1; a < 10; a++) n[a] = e[a] + s, s = n[a] >>> 13, n[a] &= 8191;
    n[9] -= 8192;
    let i = (s ^ 1) - 1;
    for (let a = 0; a < 10; a++) n[a] &= i;
    i = ~i;
    for (let a = 0; a < 10; a++) e[a] = e[a] & i | n[a];
    e[0] = (e[0] | e[1] << 13) & 65535, e[1] = (e[1] >>> 3 | e[2] << 10) & 65535, e[2] = (e[2] >>> 6 | e[3] << 7) & 65535, e[3] = (e[3] >>> 9 | e[4] << 4) & 65535, e[4] = (e[4] >>> 12 | e[5] << 1 | e[6] << 14) & 65535, e[5] = (e[6] >>> 2 | e[7] << 11) & 65535, e[6] = (e[7] >>> 5 | e[8] << 8) & 65535, e[7] = (e[8] >>> 8 | e[9] << 5) & 65535;
    let o = e[0] + t[0];
    e[0] = o & 65535;
    for (let a = 1; a < 8; a++) o = (e[a] + t[a] | 0) + (o >>> 16) | 0, e[a] = o & 65535;
    Pi(n);
  }
  update(e) {
    Jh(this), e = Su(e), Qt(e);
    const { buffer: t, blockLen: n } = this, s = e.length;
    for (let i = 0; i < s; ) {
      const o = Math.min(n - this.pos, s - i);
      if (o === n) {
        for (; n <= s - i; i += n) this.process(e, i);
        continue;
      }
      t.set(e.subarray(i, i + o), this.pos), this.pos += o, i += o, this.pos === n && (this.process(t, 0, false), this.pos = 0);
    }
    return this;
  }
  destroy() {
    Pi(this.h, this.r, this.buffer, this.pad);
  }
  digestInto(e) {
    Jh(this), tO(e, this), this.finished = true;
    const { buffer: t, h: n } = this;
    let { pos: s } = this;
    if (s) {
      for (t[s++] = 1; s < 16; s++) t[s] = 0;
      this.process(t, 0, true);
    }
    this.finalize();
    let i = 0;
    for (let o = 0; o < 8; o++) e[i++] = n[o] >>> 0, e[i++] = n[o] >>> 8;
    return e;
  }
  digest() {
    const { buffer: e, outputLen: t } = this;
    this.digestInto(e);
    const n = e.slice(0, t);
    return this.destroy(), n;
  }
};
function mO(r) {
  const e = (n, s) => r(s).update(Su(n)).digest(), t = r(new Uint8Array(32));
  return e.outputLen = t.outputLen, e.blockLen = t.blockLen, e.create = (n) => r(n), e;
}
var bO = mO((r) => new wO(r));
function vO(r, e, t, n, s, i = 20) {
  let o = r[0], a = r[1], u = r[2], c = r[3], l = e[0], d = e[1], h = e[2], f = e[3], g = e[4], p = e[5], b = e[6], _ = e[7], D = s, v = t[0], E = t[1], A = t[2], k = o, U = a, P = u, $ = c, ee = l, G = d, H = h, R = f, z = g, j = p, I = b, y = _, m = D, N = v, T = E, x = A;
  for (let V = 0; V < i; V += 2) k = k + ee | 0, m = Oe(m ^ k, 16), z = z + m | 0, ee = Oe(ee ^ z, 12), k = k + ee | 0, m = Oe(m ^ k, 8), z = z + m | 0, ee = Oe(ee ^ z, 7), U = U + G | 0, N = Oe(N ^ U, 16), j = j + N | 0, G = Oe(G ^ j, 12), U = U + G | 0, N = Oe(N ^ U, 8), j = j + N | 0, G = Oe(G ^ j, 7), P = P + H | 0, T = Oe(T ^ P, 16), I = I + T | 0, H = Oe(H ^ I, 12), P = P + H | 0, T = Oe(T ^ P, 8), I = I + T | 0, H = Oe(H ^ I, 7), $ = $ + R | 0, x = Oe(x ^ $, 16), y = y + x | 0, R = Oe(R ^ y, 12), $ = $ + R | 0, x = Oe(x ^ $, 8), y = y + x | 0, R = Oe(R ^ y, 7), k = k + G | 0, x = Oe(x ^ k, 16), I = I + x | 0, G = Oe(G ^ I, 12), k = k + G | 0, x = Oe(x ^ k, 8), I = I + x | 0, G = Oe(G ^ I, 7), U = U + H | 0, m = Oe(m ^ U, 16), y = y + m | 0, H = Oe(H ^ y, 12), U = U + H | 0, m = Oe(m ^ U, 8), y = y + m | 0, H = Oe(H ^ y, 7), P = P + R | 0, N = Oe(N ^ P, 16), z = z + N | 0, R = Oe(R ^ z, 12), P = P + R | 0, N = Oe(N ^ P, 8), z = z + N | 0, R = Oe(R ^ z, 7), $ = $ + ee | 0, T = Oe(T ^ $, 16), j = j + T | 0, ee = Oe(ee ^ j, 12), $ = $ + ee | 0, T = Oe(T ^ $, 8), j = j + T | 0, ee = Oe(ee ^ j, 7);
  let L = 0;
  n[L++] = o + k | 0, n[L++] = a + U | 0, n[L++] = u + P | 0, n[L++] = c + $ | 0, n[L++] = l + ee | 0, n[L++] = d + G | 0, n[L++] = h + H | 0, n[L++] = f + R | 0, n[L++] = g + z | 0, n[L++] = p + j | 0, n[L++] = b + I | 0, n[L++] = _ + y | 0, n[L++] = D + m | 0, n[L++] = v + N | 0, n[L++] = E + T | 0, n[L++] = A + x | 0;
}
var MO = yO(vO, { counterRight: false, counterLength: 4, allowShortKeys: false });
var EO = new Uint8Array(16);
var nf = (r, e) => {
  r.update(e);
  const t = e.length % 16;
  t && r.update(EO.subarray(t));
};
var NO = new Uint8Array(32);
function sf(r, e, t, n, s) {
  const i = r(e, t, NO), o = bO.create(i);
  s && nf(o, s), nf(o, n);
  const a = cO(n.length, s ? s.length : 0, true);
  o.update(a);
  const u = o.digest();
  return Pi(i, a), u;
}
var xO = (r) => (e, t, n) => ({ encrypt(s, i) {
  const o = s.length;
  i = ef(o + 16, i, false), i.set(s);
  const a = i.subarray(0, -16);
  r(e, t, a, a, 1);
  const u = sf(r, e, t, a, n);
  return i.set(u, o), Pi(u), i;
}, decrypt(s, i) {
  i = ef(s.length - 16, i, false);
  const o = s.subarray(0, -16), a = s.subarray(-16), u = sf(r, e, t, o, n);
  if (!oO(a, u)) throw new Error("invalid tag");
  return i.set(s.subarray(0, -16)), r(e, t, i, i, 1), Pi(u), i;
} });
var Iy = aO({ blockSize: 64, nonceLength: 12, tagLength: 16 }, xO(MO));
var _y = class extends Ya {
  constructor(e, t) {
    super(), this.finished = false, this.destroyed = false, qa(e);
    const n = br(t);
    if (this.iHash = e.create(), typeof this.iHash.update != "function") throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const s = this.blockLen, i = new Uint8Array(s);
    i.set(n.length > s ? e.create().update(n).digest() : n);
    for (let o = 0; o < i.length; o++) i[o] ^= 54;
    this.iHash.update(i), this.oHash = e.create();
    for (let o = 0; o < i.length; o++) i[o] ^= 106;
    this.oHash.update(i), hr(i);
  }
  update(e) {
    return On(this), this.iHash.update(e), this;
  }
  digestInto(e) {
    On(this), Mr(e, this.outputLen), this.finished = true, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy();
  }
  digest() {
    const e = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(e), e;
  }
  _cloneInto(e) {
    e || (e = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: t, iHash: n, finished: s, destroyed: i, blockLen: o, outputLen: a } = this;
    return e = e, e.finished = s, e.destroyed = i, e.blockLen = o, e.outputLen = a, e.oHash = t._cloneInto(e.oHash), e.iHash = n._cloneInto(e.iHash), e;
  }
  clone() {
    return this._cloneInto();
  }
  destroy() {
    this.destroyed = true, this.oHash.destroy(), this.iHash.destroy();
  }
};
var Ha = (r, e, t) => new _y(r, e).update(t).digest();
Ha.create = (r, e) => new _y(r, e);
function IO(r, e, t) {
  return qa(r), t === void 0 && (t = new Uint8Array(r.outputLen)), Ha(r, br(t), br(e));
}
var $c = Uint8Array.from([0]);
var of = Uint8Array.of();
function _O(r, e, t, n = 32) {
  qa(r), en(n);
  const s = r.outputLen;
  if (n > 255 * s) throw new Error("Length should be <= 255*HashLen");
  const i = Math.ceil(n / s);
  t === void 0 && (t = of);
  const o = new Uint8Array(i * s), a = Ha.create(r, e), u = a._cloneInto(), c = new Uint8Array(a.outputLen);
  for (let l = 0; l < i; l++) $c[0] = l + 1, u.update(l === 0 ? of : c).update(t).update($c).digestInto(c), o.set(c, s * l), a._cloneInto(u);
  return a.destroy(), u.destroy(), hr(c, $c), o.slice(0, n);
}
var DO = (r, e, t, n, s) => _O(r, IO(r, e, t), n, s);
var Ga = Va;
var Ul = BigInt(0);
var Lu = BigInt(1);
function Wo(r, e = "") {
  if (typeof r != "boolean") {
    const t = e && `"${e}"`;
    throw new Error(t + "expected boolean, got type=" + typeof r);
  }
  return r;
}
function Kn(r, e, t = "") {
  const n = Qa(r), s = r == null ? void 0 : r.length, i = e !== void 0;
  if (!n || i && s !== e) {
    const o = t && `"${t}" `, a = i ? ` of length ${e}` : "", u = n ? `length=${s}` : `type=${typeof r}`;
    throw new Error(o + "expected Uint8Array" + a + ", got " + u);
  }
  return r;
}
function wo(r) {
  const e = r.toString(16);
  return e.length & 1 ? "0" + e : e;
}
function Dy(r) {
  if (typeof r != "string") throw new Error("hex string expected, got " + typeof r);
  return r === "" ? Ul : BigInt("0x" + r);
}
function Wa(r) {
  return Dy(Si(r));
}
function Ko(r) {
  return Mr(r), Dy(Si(Uint8Array.from(r).reverse()));
}
function Pl(r, e) {
  return Ho(r.toString(16).padStart(e * 2, "0"));
}
function Bl(r, e) {
  return Pl(r, e).reverse();
}
function jt(r, e, t) {
  let n;
  if (typeof e == "string") try {
    n = Ho(e);
  } catch (i) {
    throw new Error(r + " must be hex string or Uint8Array, cause: " + i);
  }
  else if (Qa(e)) n = Uint8Array.from(e);
  else throw new Error(r + " must be hex string or Uint8Array");
  const s = n.length;
  if (typeof t == "number" && s !== t) throw new Error(r + " of length " + t + " expected, got " + s);
  return n;
}
var Fc = (r) => typeof r == "bigint" && Ul <= r;
function TO(r, e, t) {
  return Fc(r) && Fc(e) && Fc(t) && e <= r && r < t;
}
function zu(r, e, t, n) {
  if (!TO(e, t, n)) throw new Error("expected valid " + r + ": " + t + " <= n < " + n + ", got " + e);
}
function Ty(r) {
  let e;
  for (e = 0; r > Ul; r >>= Lu, e += 1) ;
  return e;
}
var Qs = (r) => (Lu << BigInt(r)) - Lu;
function AO(r, e, t) {
  if (typeof r != "number" || r < 2) throw new Error("hashLen must be a number");
  if (typeof e != "number" || e < 2) throw new Error("qByteLen must be a number");
  if (typeof t != "function") throw new Error("hmacFn must be a function");
  const n = (h) => new Uint8Array(h), s = (h) => Uint8Array.of(h);
  let i = n(r), o = n(r), a = 0;
  const u = () => {
    i.fill(1), o.fill(0), a = 0;
  }, c = (...h) => t(o, i, ...h), l = (h = n(0)) => {
    o = c(s(0), h), i = c(), h.length !== 0 && (o = c(s(1), h), i = c());
  }, d = () => {
    if (a++ >= 1e3) throw new Error("drbg: tried 1000 values");
    let h = 0;
    const f = [];
    for (; h < e; ) {
      i = c();
      const g = i.slice();
      f.push(g), h += i.length;
    }
    return En(...f);
  };
  return (h, f) => {
    u(), l(h);
    let g;
    for (; !(g = f(d())); ) l();
    return u(), g;
  };
}
function Ka(r, e, t = {}) {
  if (!r || typeof r != "object") throw new Error("expected valid options object");
  function n(s, i, o) {
    const a = r[s];
    if (o && a === void 0) return;
    const u = typeof a;
    if (u !== i || a === null) throw new Error(`param "${s}" is invalid: expected ${i}, got ${u}`);
  }
  Object.entries(e).forEach(([s, i]) => n(s, i, false)), Object.entries(t).forEach(([s, i]) => n(s, i, true));
}
function af(r) {
  const e = /* @__PURE__ */ new WeakMap();
  return (t, ...n) => {
    const s = e.get(t);
    if (s !== void 0) return s;
    const i = r(t, ...n);
    return e.set(t, i), i;
  };
}
var Vt = BigInt(0);
var zt = BigInt(1);
var Xn = BigInt(2);
var Ay = BigInt(3);
var Oy = BigInt(4);
var Sy = BigInt(5);
var OO = BigInt(7);
var jy = BigInt(8);
var SO = BigInt(9);
var Cy = BigInt(16);
function Jt(r, e) {
  const t = r % e;
  return t >= Vt ? t : e + t;
}
function wr(r, e, t) {
  let n = r;
  for (; e-- > Vt; ) n *= n, n %= t;
  return n;
}
function cf(r, e) {
  if (r === Vt) throw new Error("invert: expected non-zero number");
  if (e <= Vt) throw new Error("invert: expected positive modulus, got " + e);
  let t = Jt(r, e), n = e, s = Vt, i = zt;
  for (; t !== Vt; ) {
    const o = n / t, a = n % t, u = s - i * o;
    n = t, t = a, s = i, i = u;
  }
  if (n !== zt) throw new Error("invert: does not exist");
  return Jt(s, e);
}
function Rl(r, e, t) {
  if (!r.eql(r.sqr(e), t)) throw new Error("Cannot find square root");
}
function Ly(r, e) {
  const t = (r.ORDER + zt) / Oy, n = r.pow(e, t);
  return Rl(r, n, e), n;
}
function jO(r, e) {
  const t = (r.ORDER - Sy) / jy, n = r.mul(e, Xn), s = r.pow(n, t), i = r.mul(e, s), o = r.mul(r.mul(i, Xn), s), a = r.mul(i, r.sub(o, r.ONE));
  return Rl(r, a, e), a;
}
function CO(r) {
  const e = jn(r), t = zy(r), n = t(e, e.neg(e.ONE)), s = t(e, n), i = t(e, e.neg(n)), o = (r + OO) / Cy;
  return (a, u) => {
    let c = a.pow(u, o), l = a.mul(c, n);
    const d = a.mul(c, s), h = a.mul(c, i), f = a.eql(a.sqr(l), u), g = a.eql(a.sqr(d), u);
    c = a.cmov(c, l, f), l = a.cmov(h, d, g);
    const p = a.eql(a.sqr(l), u), b = a.cmov(c, l, p);
    return Rl(a, b, u), b;
  };
}
function zy(r) {
  if (r < Ay) throw new Error("sqrt is not defined for small field");
  let e = r - zt, t = 0;
  for (; e % Xn === Vt; ) e /= Xn, t++;
  let n = Xn;
  const s = jn(r);
  for (; uf(s, n) === 1; ) if (n++ > 1e3) throw new Error("Cannot find square root: probably non-prime P");
  if (t === 1) return Ly;
  let i = s.pow(n, e);
  const o = (e + zt) / Xn;
  return function(a, u) {
    if (a.is0(u)) return u;
    if (uf(a, u) !== 1) throw new Error("Cannot find square root");
    let c = t, l = a.mul(a.ONE, i), d = a.pow(u, e), h = a.pow(u, o);
    for (; !a.eql(d, a.ONE); ) {
      if (a.is0(d)) return a.ZERO;
      let f = 1, g = a.sqr(d);
      for (; !a.eql(g, a.ONE); ) if (f++, g = a.sqr(g), f === c) throw new Error("Cannot find square root");
      const p = zt << BigInt(c - f - 1), b = a.pow(l, p);
      c = f, l = a.sqr(b), d = a.mul(d, l), h = a.mul(h, b);
    }
    return h;
  };
}
function LO(r) {
  return r % Oy === Ay ? Ly : r % jy === Sy ? jO : r % Cy === SO ? CO(r) : zy(r);
}
var zO = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];
function kO(r) {
  const e = { ORDER: "bigint", MASK: "bigint", BYTES: "number", BITS: "number" }, t = zO.reduce((n, s) => (n[s] = "function", n), e);
  return Ka(r, t), r;
}
function UO(r, e, t) {
  if (t < Vt) throw new Error("invalid exponent, negatives unsupported");
  if (t === Vt) return r.ONE;
  if (t === zt) return e;
  let n = r.ONE, s = e;
  for (; t > Vt; ) t & zt && (n = r.mul(n, s)), s = r.sqr(s), t >>= zt;
  return n;
}
function ky(r, e, t = false) {
  const n = new Array(e.length).fill(t ? r.ZERO : void 0), s = e.reduce((o, a, u) => r.is0(a) ? o : (n[u] = o, r.mul(o, a)), r.ONE), i = r.inv(s);
  return e.reduceRight((o, a, u) => r.is0(a) ? o : (n[u] = r.mul(o, n[u]), r.mul(o, a)), i), n;
}
function uf(r, e) {
  const t = (r.ORDER - zt) / Xn, n = r.pow(e, t), s = r.eql(n, r.ONE), i = r.eql(n, r.ZERO), o = r.eql(n, r.neg(r.ONE));
  if (!s && !i && !o) throw new Error("invalid Legendre symbol result");
  return s ? 1 : i ? 0 : -1;
}
function Uy(r, e) {
  e !== void 0 && en(e);
  const t = e !== void 0 ? e : r.toString(2).length, n = Math.ceil(t / 8);
  return { nBitLength: t, nByteLength: n };
}
function jn(r, e, t = false, n = {}) {
  if (r <= Vt) throw new Error("invalid field: expected ORDER > 0, got " + r);
  let s, i, o = false, a;
  if (typeof e == "object" && e != null) {
    if (n.sqrt || t) throw new Error("cannot specify opts in two arguments");
    const h = e;
    h.BITS && (s = h.BITS), h.sqrt && (i = h.sqrt), typeof h.isLE == "boolean" && (t = h.isLE), typeof h.modFromBytes == "boolean" && (o = h.modFromBytes), a = h.allowedLengths;
  } else typeof e == "number" && (s = e), n.sqrt && (i = n.sqrt);
  const { nBitLength: u, nByteLength: c } = Uy(r, s);
  if (c > 2048) throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let l;
  const d = Object.freeze({ ORDER: r, isLE: t, BITS: u, BYTES: c, MASK: Qs(u), ZERO: Vt, ONE: zt, allowedLengths: a, create: (h) => Jt(h, r), isValid: (h) => {
    if (typeof h != "bigint") throw new Error("invalid field element: expected bigint, got " + typeof h);
    return Vt <= h && h < r;
  }, is0: (h) => h === Vt, isValidNot0: (h) => !d.is0(h) && d.isValid(h), isOdd: (h) => (h & zt) === zt, neg: (h) => Jt(-h, r), eql: (h, f) => h === f, sqr: (h) => Jt(h * h, r), add: (h, f) => Jt(h + f, r), sub: (h, f) => Jt(h - f, r), mul: (h, f) => Jt(h * f, r), pow: (h, f) => UO(d, h, f), div: (h, f) => Jt(h * cf(f, r), r), sqrN: (h) => h * h, addN: (h, f) => h + f, subN: (h, f) => h - f, mulN: (h, f) => h * f, inv: (h) => cf(h, r), sqrt: i || ((h) => (l || (l = LO(r)), l(d, h))), toBytes: (h) => t ? Bl(h, c) : Pl(h, c), fromBytes: (h, f = true) => {
    if (a) {
      if (!a.includes(h.length) || h.length > c) throw new Error("Field.fromBytes: expected " + a + " bytes, got " + h.length);
      const p = new Uint8Array(c);
      p.set(h, t ? 0 : p.length - h.length), h = p;
    }
    if (h.length !== c) throw new Error("Field.fromBytes: expected " + c + " bytes, got " + h.length);
    let g = t ? Ko(h) : Wa(h);
    if (o && (g = Jt(g, r)), !f && !d.isValid(g)) throw new Error("invalid field element: outside of range 0..ORDER");
    return g;
  }, invertBatch: (h) => ky(d, h), cmov: (h, f, g) => g ? f : h });
  return Object.freeze(d);
}
function Py(r) {
  if (typeof r != "bigint") throw new Error("field order must be bigint");
  const e = r.toString(2).length;
  return Math.ceil(e / 8);
}
function By(r) {
  const e = Py(r);
  return e + Math.ceil(e / 2);
}
function PO(r, e, t = false) {
  const n = r.length, s = Py(e), i = By(e);
  if (n < 16 || n < i || n > 1024) throw new Error("expected " + i + "-1024 bytes of input, got " + n);
  const o = t ? Ko(r) : Wa(r), a = Jt(o, e - zt) + zt;
  return t ? Bl(a, s) : Pl(a, s);
}
var Bi = BigInt(0);
var Zn = BigInt(1);
function Xo(r, e) {
  const t = e.negate();
  return r ? t : e;
}
function Qc(r, e) {
  const t = ky(r.Fp, e.map((n) => n.Z));
  return e.map((n, s) => r.fromAffine(n.toAffine(t[s])));
}
function Ry(r, e) {
  if (!Number.isSafeInteger(r) || r <= 0 || r > e) throw new Error("invalid window size, expected [1.." + e + "], got W=" + r);
}
function qc(r, e) {
  Ry(r, e);
  const t = Math.ceil(e / r) + 1, n = 2 ** (r - 1), s = 2 ** r, i = Qs(r), o = BigInt(r);
  return { windows: t, windowSize: n, mask: i, maxNumber: s, shiftBy: o };
}
function lf(r, e, t) {
  const { windowSize: n, mask: s, maxNumber: i, shiftBy: o } = t;
  let a = Number(r & s), u = r >> o;
  a > n && (a -= i, u += Zn);
  const c = e * n, l = c + Math.abs(a) - 1, d = a === 0, h = a < 0, f = e % 2 !== 0;
  return { nextN: u, offset: l, isZero: d, isNeg: h, isNegF: f, offsetF: c };
}
function BO(r, e) {
  if (!Array.isArray(r)) throw new Error("array expected");
  r.forEach((t, n) => {
    if (!(t instanceof e)) throw new Error("invalid point at index " + n);
  });
}
function RO(r, e) {
  if (!Array.isArray(r)) throw new Error("array of scalars expected");
  r.forEach((t, n) => {
    if (!e.isValid(t)) throw new Error("invalid scalar at index " + n);
  });
}
var Yc = /* @__PURE__ */ new WeakMap();
var $y = /* @__PURE__ */ new WeakMap();
function Vc(r) {
  return $y.get(r) || 1;
}
function df(r) {
  if (r !== Bi) throw new Error("invalid wNAF");
}
var $O = class {
  constructor(e, t) {
    this.BASE = e.BASE, this.ZERO = e.ZERO, this.Fn = e.Fn, this.bits = t;
  }
  _unsafeLadder(e, t, n = this.ZERO) {
    let s = e;
    for (; t > Bi; ) t & Zn && (n = n.add(s)), s = s.double(), t >>= Zn;
    return n;
  }
  precomputeWindow(e, t) {
    const { windows: n, windowSize: s } = qc(t, this.bits), i = [];
    let o = e, a = o;
    for (let u = 0; u < n; u++) {
      a = o, i.push(a);
      for (let c = 1; c < s; c++) a = a.add(o), i.push(a);
      o = a.double();
    }
    return i;
  }
  wNAF(e, t, n) {
    if (!this.Fn.isValid(n)) throw new Error("invalid scalar");
    let s = this.ZERO, i = this.BASE;
    const o = qc(e, this.bits);
    for (let a = 0; a < o.windows; a++) {
      const { nextN: u, offset: c, isZero: l, isNeg: d, isNegF: h, offsetF: f } = lf(n, a, o);
      n = u, l ? i = i.add(Xo(h, t[f])) : s = s.add(Xo(d, t[c]));
    }
    return df(n), { p: s, f: i };
  }
  wNAFUnsafe(e, t, n, s = this.ZERO) {
    const i = qc(e, this.bits);
    for (let o = 0; o < i.windows && n !== Bi; o++) {
      const { nextN: a, offset: u, isZero: c, isNeg: l } = lf(n, o, i);
      if (n = a, !c) {
        const d = t[u];
        s = s.add(l ? d.negate() : d);
      }
    }
    return df(n), s;
  }
  getPrecomputes(e, t, n) {
    let s = Yc.get(t);
    return s || (s = this.precomputeWindow(t, e), e !== 1 && (typeof n == "function" && (s = n(s)), Yc.set(t, s))), s;
  }
  cached(e, t, n) {
    const s = Vc(e);
    return this.wNAF(s, this.getPrecomputes(s, e, n), t);
  }
  unsafe(e, t, n, s) {
    const i = Vc(e);
    return i === 1 ? this._unsafeLadder(e, t, s) : this.wNAFUnsafe(i, this.getPrecomputes(i, e, n), t, s);
  }
  createCache(e, t) {
    Ry(t, this.bits), $y.set(e, t), Yc.delete(e);
  }
  hasCache(e) {
    return Vc(e) !== 1;
  }
};
function FO(r, e, t, n) {
  let s = e, i = r.ZERO, o = r.ZERO;
  for (; t > Bi || n > Bi; ) t & Zn && (i = i.add(s)), n & Zn && (o = o.add(s)), s = s.double(), t >>= Zn, n >>= Zn;
  return { p1: i, p2: o };
}
function QO(r, e, t, n) {
  BO(t, r), RO(n, e);
  const s = t.length, i = n.length;
  if (s !== i) throw new Error("arrays of points and scalars must have equal length");
  const o = r.ZERO, a = Ty(BigInt(s));
  let u = 1;
  a > 12 ? u = a - 3 : a > 4 ? u = a - 2 : a > 0 && (u = 2);
  const c = Qs(u), l = new Array(Number(c) + 1).fill(o), d = Math.floor((e.BITS - 1) / u) * u;
  let h = o;
  for (let f = d; f >= 0; f -= u) {
    l.fill(o);
    for (let p = 0; p < i; p++) {
      const b = n[p], _ = Number(b >> BigInt(f) & c);
      l[_] = l[_].add(t[p]);
    }
    let g = o;
    for (let p = l.length - 1, b = o; p > 0; p--) b = b.add(l[p]), g = g.add(b);
    if (h = h.add(g), f !== 0) for (let p = 0; p < u; p++) h = h.double();
  }
  return h;
}
function hf(r, e, t) {
  if (e) {
    if (e.ORDER !== r) throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
    return kO(e), e;
  } else return jn(r, { isLE: t });
}
function qO(r, e, t = {}, n) {
  if (n === void 0 && (n = r === "edwards"), !e || typeof e != "object") throw new Error(`expected valid ${r} CURVE object`);
  for (const a of ["p", "n", "h"]) {
    const u = e[a];
    if (!(typeof u == "bigint" && u > Bi)) throw new Error(`CURVE.${a} must be positive bigint`);
  }
  const s = hf(e.p, t.Fp, n), i = hf(e.n, t.Fn, n), o = ["Gx", "Gy", "a", "b"];
  for (const a of o) if (!s.isValid(e[a])) throw new Error(`CURVE.${a} must be valid field element of CURVE.Fp`);
  return e = Object.freeze(Object.assign({}, e)), { CURVE: e, Fp: s, Fn: i };
}
BigInt(0), BigInt(1), BigInt(2), BigInt(8), dy("HashToScalar-");
var as = BigInt(0);
var vi = BigInt(1);
var mo = BigInt(2);
function YO(r) {
  return Ka(r, { adjustScalarBytes: "function", powPminus2: "function" }), Object.freeze({ ...r });
}
function VO(r) {
  const e = YO(r), { P: t, type: n, adjustScalarBytes: s, powPminus2: i, randomBytes: o } = e, a = n === "x25519";
  if (!a && n !== "x448") throw new Error("invalid type");
  const u = o || hi, c = a ? 255 : 448, l = a ? 32 : 56, d = BigInt(a ? 9 : 5), h = BigInt(a ? 121665 : 39081), f = a ? mo ** BigInt(254) : mo ** BigInt(447), g = a ? BigInt(8) * mo ** BigInt(251) - vi : BigInt(4) * mo ** BigInt(445) - vi, p = f + g + vi, b = (H) => Jt(H, t), _ = D(d);
  function D(H) {
    return Bl(b(H), l);
  }
  function v(H) {
    const R = jt("u coordinate", H, l);
    return a && (R[31] &= 127), b(Ko(R));
  }
  function E(H) {
    return Ko(s(jt("scalar", H, l)));
  }
  function A(H, R) {
    const z = P(v(R), E(H));
    if (z === as) throw new Error("invalid private or public key received");
    return D(z);
  }
  function k(H) {
    return A(H, _);
  }
  function U(H, R, z) {
    const j = b(H * (R - z));
    return R = b(R - j), z = b(z + j), { x_2: R, x_3: z };
  }
  function P(H, R) {
    zu("u", H, as, t), zu("scalar", R, f, p);
    const z = R, j = H;
    let I = vi, y = as, m = H, N = vi, T = as;
    for (let L = BigInt(c - 1); L >= as; L--) {
      const V = z >> L & vi;
      T ^= V, { x_2: I, x_3: m } = U(T, I, m), { x_2: y, x_3: N } = U(T, y, N), T = V;
      const q = I + y, K = b(q * q), Z = I - y, re = b(Z * Z), ne = K - re, se = m + N, ue = m - N, he = b(ue * q), Q = b(se * Z), X = he + Q, Y = he - Q;
      m = b(X * X), N = b(j * b(Y * Y)), I = b(K * re), y = b(ne * (K + b(h * ne)));
    }
    ({ x_2: I, x_3: m } = U(T, I, m)), { x_2: y, x_3: N } = U(T, y, N);
    const x = i(y);
    return b(I * x);
  }
  const $ = { secretKey: l, publicKey: l, seed: l }, ee = (H = u(l)) => (Mr(H, $.seed), H);
  function G(H) {
    const R = ee(H);
    return { secretKey: R, publicKey: k(R) };
  }
  return { keygen: G, getSharedSecret: (H, R) => A(H, R), getPublicKey: (H) => k(H), scalarMult: A, scalarMultBase: k, utils: { randomSecretKey: ee, randomPrivateKey: ee }, GuBytes: _.slice(), lengths: $ };
}
var HO = BigInt(1);
var ff = BigInt(2);
var GO = BigInt(3);
var WO = BigInt(5);
BigInt(8);
var Fy = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed");
var KO = { p: Fy, n: BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"), a: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"), d: BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"), Gx: BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"), Gy: BigInt("0x6666666666666666666666666666666666666666666666666666666666666658") };
function XO(r) {
  const e = BigInt(10), t = BigInt(20), n = BigInt(40), s = BigInt(80), i = Fy, o = r * r % i * r % i, a = wr(o, ff, i) * o % i, u = wr(a, HO, i) * r % i, c = wr(u, WO, i) * u % i, l = wr(c, e, i) * c % i, d = wr(l, t, i) * l % i, h = wr(d, n, i) * d % i, f = wr(h, s, i) * h % i, g = wr(f, s, i) * h % i, p = wr(g, e, i) * c % i;
  return { pow_p_5_8: wr(p, ff, i) * r % i, b2: o };
}
function ZO(r) {
  return r[0] &= 248, r[31] &= 127, r[31] |= 64, r;
}
var JO = jn(KO.p, { isLE: true });
var ku = (() => {
  const r = JO.ORDER;
  return VO({ P: r, type: "x25519", powPminus2: (e) => {
    const { pow_p_5_8: t, b2: n } = XO(e);
    return Jt(wr(t, GO, r) * n, r);
  }, adjustScalarBytes: ZO });
})();
var pf = (r, e) => (r + (r >= 0 ? e : -e) / Qy) / e;
function eS(r, e, t) {
  const [[n, s], [i, o]] = e, a = pf(o * r, t), u = pf(-s * r, t);
  let c = r - a * n - u * i, l = -a * s - u * o;
  const d = c < Kr, h = l < Kr;
  d && (c = -c), h && (l = -l);
  const f = Qs(Math.ceil(Ty(t) / 2)) + ji;
  if (c < Kr || c >= f || l < Kr || l >= f) throw new Error("splitScalar (endomorphism): failed, k=" + r);
  return { k1neg: d, k1: c, k2neg: h, k2: l };
}
function Uu(r) {
  if (!["compact", "recovered", "der"].includes(r)) throw new Error('Signature format must be "compact", "recovered", or "der"');
  return r;
}
function Hc(r, e) {
  const t = {};
  for (let n of Object.keys(e)) t[n] = r[n] === void 0 ? e[n] : r[n];
  return Wo(t.lowS, "lowS"), Wo(t.prehash, "prehash"), t.format !== void 0 && Uu(t.format), t;
}
var tS = class extends Error {
  constructor(e = "") {
    super(e);
  }
};
var Hr = { Err: tS, _tlv: { encode: (r, e) => {
  const { Err: t } = Hr;
  if (r < 0 || r > 256) throw new t("tlv.encode: wrong tag");
  if (e.length & 1) throw new t("tlv.encode: unpadded data");
  const n = e.length / 2, s = wo(n);
  if (s.length / 2 & 128) throw new t("tlv.encode: long form length too big");
  const i = n > 127 ? wo(s.length / 2 | 128) : "";
  return wo(r) + i + s + e;
}, decode(r, e) {
  const { Err: t } = Hr;
  let n = 0;
  if (r < 0 || r > 256) throw new t("tlv.encode: wrong tag");
  if (e.length < 2 || e[n++] !== r) throw new t("tlv.decode: wrong tlv");
  const s = e[n++], i = !!(s & 128);
  let o = 0;
  if (!i) o = s;
  else {
    const u = s & 127;
    if (!u) throw new t("tlv.decode(long): indefinite length not supported");
    if (u > 4) throw new t("tlv.decode(long): byte length is too big");
    const c = e.subarray(n, n + u);
    if (c.length !== u) throw new t("tlv.decode: length bytes not complete");
    if (c[0] === 0) throw new t("tlv.decode(long): zero leftmost byte");
    for (const l of c) o = o << 8 | l;
    if (n += u, o < 128) throw new t("tlv.decode(long): not minimal encoding");
  }
  const a = e.subarray(n, n + o);
  if (a.length !== o) throw new t("tlv.decode: wrong value length");
  return { v: a, l: e.subarray(n + o) };
} }, _int: { encode(r) {
  const { Err: e } = Hr;
  if (r < Kr) throw new e("integer: negative integers are not allowed");
  let t = wo(r);
  if (Number.parseInt(t[0], 16) & 8 && (t = "00" + t), t.length & 1) throw new e("unexpected DER parsing assertion: unpadded hex");
  return t;
}, decode(r) {
  const { Err: e } = Hr;
  if (r[0] & 128) throw new e("invalid signature integer: negative");
  if (r[0] === 0 && !(r[1] & 128)) throw new e("invalid signature integer: unnecessary leading zero");
  return Wa(r);
} }, toSig(r) {
  const { Err: e, _int: t, _tlv: n } = Hr, s = jt("signature", r), { v: i, l: o } = n.decode(48, s);
  if (o.length) throw new e("invalid signature: left bytes after parsing");
  const { v: a, l: u } = n.decode(2, i), { v: c, l } = n.decode(2, u);
  if (l.length) throw new e("invalid signature: left bytes after parsing");
  return { r: t.decode(a), s: t.decode(c) };
}, hexFromSig(r) {
  const { _tlv: e, _int: t } = Hr, n = e.encode(2, t.encode(r.r)), s = e.encode(2, t.encode(r.s)), i = n + s;
  return e.encode(48, i);
} };
var Kr = BigInt(0);
var ji = BigInt(1);
var Qy = BigInt(2);
var bo = BigInt(3);
var rS = BigInt(4);
function _i(r, e) {
  const { BYTES: t } = r;
  let n;
  if (typeof e == "bigint") n = e;
  else {
    let s = jt("private key", e);
    try {
      n = r.fromBytes(s);
    } catch {
      throw new Error(`invalid private key: expected ui8a of size ${t}, got ${typeof e}`);
    }
  }
  if (!r.isValidNot0(n)) throw new Error("invalid private key: out of range [1..N-1]");
  return n;
}
function nS(r, e = {}) {
  const t = qO("weierstrass", r, e), { Fp: n, Fn: s } = t;
  let i = t.CURVE;
  const { h: o, n: a } = i;
  Ka(e, {}, { allowInfinityPoint: "boolean", clearCofactor: "function", isTorsionFree: "function", fromBytes: "function", toBytes: "function", endo: "object", wrapPrivateKey: "boolean" });
  const { endo: u } = e;
  if (u && (!n.is0(i.a) || typeof u.beta != "bigint" || !Array.isArray(u.basises))) throw new Error('invalid endo: expected "beta": bigint and "basises": array');
  const c = Yy(n, s);
  function l() {
    if (!n.isOdd) throw new Error("compression is not supported: Field does not have .isOdd()");
  }
  function d(H, R, z) {
    const { x: j, y: I } = R.toAffine(), y = n.toBytes(j);
    if (Wo(z, "isCompressed"), z) {
      l();
      const m = !n.isOdd(I);
      return En(qy(m), y);
    } else return En(Uint8Array.of(4), y, n.toBytes(I));
  }
  function h(H) {
    Kn(H, void 0, "Point");
    const { publicKey: R, publicKeyUncompressed: z } = c, j = H.length, I = H[0], y = H.subarray(1);
    if (j === R && (I === 2 || I === 3)) {
      const m = n.fromBytes(y);
      if (!n.isValid(m)) throw new Error("bad point: is not on curve, wrong x");
      const N = p(m);
      let T;
      try {
        T = n.sqrt(N);
      } catch (L) {
        const V = L instanceof Error ? ": " + L.message : "";
        throw new Error("bad point: is not on curve, sqrt error" + V);
      }
      l();
      const x = n.isOdd(T);
      return (I & 1) === 1 !== x && (T = n.neg(T)), { x: m, y: T };
    } else if (j === z && I === 4) {
      const m = n.BYTES, N = n.fromBytes(y.subarray(0, m)), T = n.fromBytes(y.subarray(m, m * 2));
      if (!b(N, T)) throw new Error("bad point: is not on curve");
      return { x: N, y: T };
    } else throw new Error(`bad point: got length ${j}, expected compressed=${R} or uncompressed=${z}`);
  }
  const f = e.toBytes || d, g = e.fromBytes || h;
  function p(H) {
    const R = n.sqr(H), z = n.mul(R, H);
    return n.add(n.add(z, n.mul(H, i.a)), i.b);
  }
  function b(H, R) {
    const z = n.sqr(R), j = p(H);
    return n.eql(z, j);
  }
  if (!b(i.Gx, i.Gy)) throw new Error("bad curve params: generator point");
  const _ = n.mul(n.pow(i.a, bo), rS), D = n.mul(n.sqr(i.b), BigInt(27));
  if (n.is0(n.add(_, D))) throw new Error("bad curve params: a or b");
  function v(H, R, z = false) {
    if (!n.isValid(R) || z && n.is0(R)) throw new Error(`bad point coordinate ${H}`);
    return R;
  }
  function E(H) {
    if (!(H instanceof $)) throw new Error("ProjectivePoint expected");
  }
  function A(H) {
    if (!u || !u.basises) throw new Error("no endo");
    return eS(H, u.basises, s.ORDER);
  }
  const k = af((H, R) => {
    const { X: z, Y: j, Z: I } = H;
    if (n.eql(I, n.ONE)) return { x: z, y: j };
    const y = H.is0();
    R == null && (R = y ? n.ONE : n.inv(I));
    const m = n.mul(z, R), N = n.mul(j, R), T = n.mul(I, R);
    if (y) return { x: n.ZERO, y: n.ZERO };
    if (!n.eql(T, n.ONE)) throw new Error("invZ was invalid");
    return { x: m, y: N };
  }), U = af((H) => {
    if (H.is0()) {
      if (e.allowInfinityPoint && !n.is0(H.Y)) return;
      throw new Error("bad point: ZERO");
    }
    const { x: R, y: z } = H.toAffine();
    if (!n.isValid(R) || !n.isValid(z)) throw new Error("bad point: x or y not field elements");
    if (!b(R, z)) throw new Error("bad point: equation left != right");
    if (!H.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup");
    return true;
  });
  function P(H, R, z, j, I) {
    return z = new $(n.mul(z.X, H), z.Y, z.Z), R = Xo(j, R), z = Xo(I, z), R.add(z);
  }
  class $ {
    constructor(R, z, j) {
      this.X = v("x", R), this.Y = v("y", z, true), this.Z = v("z", j), Object.freeze(this);
    }
    static CURVE() {
      return i;
    }
    static fromAffine(R) {
      const { x: z, y: j } = R || {};
      if (!R || !n.isValid(z) || !n.isValid(j)) throw new Error("invalid affine point");
      if (R instanceof $) throw new Error("projective point not allowed");
      return n.is0(z) && n.is0(j) ? $.ZERO : new $(z, j, n.ONE);
    }
    static fromBytes(R) {
      const z = $.fromAffine(g(Kn(R, void 0, "point")));
      return z.assertValidity(), z;
    }
    static fromHex(R) {
      return $.fromBytes(jt("pointHex", R));
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    precompute(R = 8, z = true) {
      return G.createCache(this, R), z || this.multiply(bo), this;
    }
    assertValidity() {
      U(this);
    }
    hasEvenY() {
      const { y: R } = this.toAffine();
      if (!n.isOdd) throw new Error("Field doesn't support isOdd");
      return !n.isOdd(R);
    }
    equals(R) {
      E(R);
      const { X: z, Y: j, Z: I } = this, { X: y, Y: m, Z: N } = R, T = n.eql(n.mul(z, N), n.mul(y, I)), x = n.eql(n.mul(j, N), n.mul(m, I));
      return T && x;
    }
    negate() {
      return new $(this.X, n.neg(this.Y), this.Z);
    }
    double() {
      const { a: R, b: z } = i, j = n.mul(z, bo), { X: I, Y: y, Z: m } = this;
      let N = n.ZERO, T = n.ZERO, x = n.ZERO, L = n.mul(I, I), V = n.mul(y, y), q = n.mul(m, m), K = n.mul(I, y);
      return K = n.add(K, K), x = n.mul(I, m), x = n.add(x, x), N = n.mul(R, x), T = n.mul(j, q), T = n.add(N, T), N = n.sub(V, T), T = n.add(V, T), T = n.mul(N, T), N = n.mul(K, N), x = n.mul(j, x), q = n.mul(R, q), K = n.sub(L, q), K = n.mul(R, K), K = n.add(K, x), x = n.add(L, L), L = n.add(x, L), L = n.add(L, q), L = n.mul(L, K), T = n.add(T, L), q = n.mul(y, m), q = n.add(q, q), L = n.mul(q, K), N = n.sub(N, L), x = n.mul(q, V), x = n.add(x, x), x = n.add(x, x), new $(N, T, x);
    }
    add(R) {
      E(R);
      const { X: z, Y: j, Z: I } = this, { X: y, Y: m, Z: N } = R;
      let T = n.ZERO, x = n.ZERO, L = n.ZERO;
      const V = i.a, q = n.mul(i.b, bo);
      let K = n.mul(z, y), Z = n.mul(j, m), re = n.mul(I, N), ne = n.add(z, j), se = n.add(y, m);
      ne = n.mul(ne, se), se = n.add(K, Z), ne = n.sub(ne, se), se = n.add(z, I);
      let ue = n.add(y, N);
      return se = n.mul(se, ue), ue = n.add(K, re), se = n.sub(se, ue), ue = n.add(j, I), T = n.add(m, N), ue = n.mul(ue, T), T = n.add(Z, re), ue = n.sub(ue, T), L = n.mul(V, se), T = n.mul(q, re), L = n.add(T, L), T = n.sub(Z, L), L = n.add(Z, L), x = n.mul(T, L), Z = n.add(K, K), Z = n.add(Z, K), re = n.mul(V, re), se = n.mul(q, se), Z = n.add(Z, re), re = n.sub(K, re), re = n.mul(V, re), se = n.add(se, re), K = n.mul(Z, se), x = n.add(x, K), K = n.mul(ue, se), T = n.mul(ne, T), T = n.sub(T, K), K = n.mul(ne, Z), L = n.mul(ue, L), L = n.add(L, K), new $(T, x, L);
    }
    subtract(R) {
      return this.add(R.negate());
    }
    is0() {
      return this.equals($.ZERO);
    }
    multiply(R) {
      const { endo: z } = e;
      if (!s.isValidNot0(R)) throw new Error("invalid scalar: out of range");
      let j, I;
      const y = (m) => G.cached(this, m, (N) => Qc($, N));
      if (z) {
        const { k1neg: m, k1: N, k2neg: T, k2: x } = A(R), { p: L, f: V } = y(N), { p: q, f: K } = y(x);
        I = V.add(K), j = P(z.beta, L, q, m, T);
      } else {
        const { p: m, f: N } = y(R);
        j = m, I = N;
      }
      return Qc($, [j, I])[0];
    }
    multiplyUnsafe(R) {
      const { endo: z } = e, j = this;
      if (!s.isValid(R)) throw new Error("invalid scalar: out of range");
      if (R === Kr || j.is0()) return $.ZERO;
      if (R === ji) return j;
      if (G.hasCache(this)) return this.multiply(R);
      if (z) {
        const { k1neg: I, k1: y, k2neg: m, k2: N } = A(R), { p1: T, p2: x } = FO($, j, y, N);
        return P(z.beta, T, x, I, m);
      } else return G.unsafe(j, R);
    }
    multiplyAndAddUnsafe(R, z, j) {
      const I = this.multiplyUnsafe(z).add(R.multiplyUnsafe(j));
      return I.is0() ? void 0 : I;
    }
    toAffine(R) {
      return k(this, R);
    }
    isTorsionFree() {
      const { isTorsionFree: R } = e;
      return o === ji ? true : R ? R($, this) : G.unsafe(this, a).is0();
    }
    clearCofactor() {
      const { clearCofactor: R } = e;
      return o === ji ? this : R ? R($, this) : this.multiplyUnsafe(o);
    }
    isSmallOrder() {
      return this.multiplyUnsafe(o).is0();
    }
    toBytes(R = true) {
      return Wo(R, "isCompressed"), this.assertValidity(), f($, this, R);
    }
    toHex(R = true) {
      return Si(this.toBytes(R));
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
    get px() {
      return this.X;
    }
    get py() {
      return this.X;
    }
    get pz() {
      return this.Z;
    }
    toRawBytes(R = true) {
      return this.toBytes(R);
    }
    _setWindowSize(R) {
      this.precompute(R);
    }
    static normalizeZ(R) {
      return Qc($, R);
    }
    static msm(R, z) {
      return QO($, s, R, z);
    }
    static fromPrivateKey(R) {
      return $.BASE.multiply(_i(s, R));
    }
  }
  $.BASE = new $(i.Gx, i.Gy, n.ONE), $.ZERO = new $(n.ZERO, n.ONE, n.ZERO), $.Fp = n, $.Fn = s;
  const ee = s.BITS, G = new $O($, e.endo ? Math.ceil(ee / 2) : ee);
  return $.BASE.precompute(8), $;
}
function qy(r) {
  return Uint8Array.of(r ? 2 : 3);
}
function Yy(r, e) {
  return { secretKey: e.BYTES, publicKey: 1 + r.BYTES, publicKeyUncompressed: 1 + 2 * r.BYTES, publicKeyHasPrefix: true, signature: 2 * e.BYTES };
}
function iS(r, e = {}) {
  const { Fn: t } = r, n = e.randomBytes || hi, s = Object.assign(Yy(r.Fp, t), { seed: By(t.ORDER) });
  function i(h) {
    try {
      return !!_i(t, h);
    } catch {
      return false;
    }
  }
  function o(h, f) {
    const { publicKey: g, publicKeyUncompressed: p } = s;
    try {
      const b = h.length;
      return f === true && b !== g || f === false && b !== p ? false : !!r.fromBytes(h);
    } catch {
      return false;
    }
  }
  function a(h = n(s.seed)) {
    return PO(Kn(h, s.seed, "seed"), t.ORDER);
  }
  function u(h, f = true) {
    return r.BASE.multiply(_i(t, h)).toBytes(f);
  }
  function c(h) {
    const f = a(h);
    return { secretKey: f, publicKey: u(f) };
  }
  function l(h) {
    if (typeof h == "bigint") return false;
    if (h instanceof r) return true;
    const { secretKey: f, publicKey: g, publicKeyUncompressed: p } = s;
    if (t.allowedLengths || f === g) return;
    const b = jt("key", h).length;
    return b === g || b === p;
  }
  function d(h, f, g = true) {
    if (l(h) === true) throw new Error("first arg must be private key");
    if (l(f) === false) throw new Error("second arg must be public key");
    const p = _i(t, h);
    return r.fromHex(f).multiply(p).toBytes(g);
  }
  return Object.freeze({ getPublicKey: u, getSharedSecret: d, keygen: c, Point: r, utils: { isValidSecretKey: i, isValidPublicKey: o, randomSecretKey: a, isValidPrivateKey: i, randomPrivateKey: a, normPrivateKeyToScalar: (h) => _i(t, h), precompute(h = 8, f = r.BASE) {
    return f.precompute(h, false);
  } }, lengths: s });
}
function sS(r, e, t = {}) {
  qa(e), Ka(t, {}, { hmac: "function", lowS: "boolean", randomBytes: "function", bits2int: "function", bits2int_modN: "function" });
  const n = t.randomBytes || hi, s = t.hmac || ((z, ...j) => Ha(e, z, En(...j))), { Fp: i, Fn: o } = r, { ORDER: a, BITS: u } = o, { keygen: c, getPublicKey: l, getSharedSecret: d, utils: h, lengths: f } = iS(r, t), g = { prehash: false, lowS: typeof t.lowS == "boolean" ? t.lowS : false, format: void 0, extraEntropy: false }, p = "compact";
  function b(z) {
    const j = a >> ji;
    return z > j;
  }
  function _(z, j) {
    if (!o.isValidNot0(j)) throw new Error(`invalid signature ${z}: out of range 1..Point.Fn.ORDER`);
    return j;
  }
  function D(z, j) {
    Uu(j);
    const I = f.signature, y = j === "compact" ? I : j === "recovered" ? I + 1 : void 0;
    return Kn(z, y, `${j} signature`);
  }
  class v {
    constructor(j, I, y) {
      this.r = _("r", j), this.s = _("s", I), y != null && (this.recovery = y), Object.freeze(this);
    }
    static fromBytes(j, I = p) {
      D(j, I);
      let y;
      if (I === "der") {
        const { r: x, s: L } = Hr.toSig(Kn(j));
        return new v(x, L);
      }
      I === "recovered" && (y = j[0], I = "compact", j = j.subarray(1));
      const m = o.BYTES, N = j.subarray(0, m), T = j.subarray(m, m * 2);
      return new v(o.fromBytes(N), o.fromBytes(T), y);
    }
    static fromHex(j, I) {
      return this.fromBytes(Ho(j), I);
    }
    addRecoveryBit(j) {
      return new v(this.r, this.s, j);
    }
    recoverPublicKey(j) {
      const I = i.ORDER, { r: y, s: m, recovery: N } = this;
      if (N == null || ![0, 1, 2, 3].includes(N)) throw new Error("recovery id invalid");
      if (a * Qy < I && N > 1) throw new Error("recovery id is ambiguous for h>1 curve");
      const T = N === 2 || N === 3 ? y + a : y;
      if (!i.isValid(T)) throw new Error("recovery id 2 or 3 invalid");
      const x = i.toBytes(T), L = r.fromBytes(En(qy((N & 1) === 0), x)), V = o.inv(T), q = A(jt("msgHash", j)), K = o.create(-q * V), Z = o.create(m * V), re = r.BASE.multiplyUnsafe(K).add(L.multiplyUnsafe(Z));
      if (re.is0()) throw new Error("point at infinify");
      return re.assertValidity(), re;
    }
    hasHighS() {
      return b(this.s);
    }
    toBytes(j = p) {
      if (Uu(j), j === "der") return Ho(Hr.hexFromSig(this));
      const I = o.toBytes(this.r), y = o.toBytes(this.s);
      if (j === "recovered") {
        if (this.recovery == null) throw new Error("recovery bit must be present");
        return En(Uint8Array.of(this.recovery), I, y);
      }
      return En(I, y);
    }
    toHex(j) {
      return Si(this.toBytes(j));
    }
    assertValidity() {
    }
    static fromCompact(j) {
      return v.fromBytes(jt("sig", j), "compact");
    }
    static fromDER(j) {
      return v.fromBytes(jt("sig", j), "der");
    }
    normalizeS() {
      return this.hasHighS() ? new v(this.r, o.neg(this.s), this.recovery) : this;
    }
    toDERRawBytes() {
      return this.toBytes("der");
    }
    toDERHex() {
      return Si(this.toBytes("der"));
    }
    toCompactRawBytes() {
      return this.toBytes("compact");
    }
    toCompactHex() {
      return Si(this.toBytes("compact"));
    }
  }
  const E = t.bits2int || function(z) {
    if (z.length > 8192) throw new Error("input is too large");
    const j = Wa(z), I = z.length * 8 - u;
    return I > 0 ? j >> BigInt(I) : j;
  }, A = t.bits2int_modN || function(z) {
    return o.create(E(z));
  }, k = Qs(u);
  function U(z) {
    return zu("num < 2^" + u, z, Kr, k), o.toBytes(z);
  }
  function P(z, j) {
    return Kn(z, void 0, "message"), j ? Kn(e(z), void 0, "prehashed message") : z;
  }
  function $(z, j, I) {
    if (["recovered", "canonical"].some((Z) => Z in I)) throw new Error("sign() legacy options not supported");
    const { lowS: y, prehash: m, extraEntropy: N } = Hc(I, g);
    z = P(z, m);
    const T = A(z), x = _i(o, j), L = [U(x), U(T)];
    if (N != null && N !== false) {
      const Z = N === true ? n(f.secretKey) : N;
      L.push(jt("extraEntropy", Z));
    }
    const V = En(...L), q = T;
    function K(Z) {
      const re = E(Z);
      if (!o.isValidNot0(re)) return;
      const ne = o.inv(re), se = r.BASE.multiply(re).toAffine(), ue = o.create(se.x);
      if (ue === Kr) return;
      const he = o.create(ne * o.create(q + ue * x));
      if (he === Kr) return;
      let Q = (se.x === ue ? 0 : 2) | Number(se.y & ji), X = he;
      return y && b(he) && (X = o.neg(he), Q ^= 1), new v(ue, X, Q);
    }
    return { seed: V, k2sig: K };
  }
  function ee(z, j, I = {}) {
    z = jt("message", z);
    const { seed: y, k2sig: m } = $(z, j, I);
    return AO(e.outputLen, o.BYTES, s)(y, m);
  }
  function G(z) {
    let j;
    const I = typeof z == "string" || Qa(z), y = !I && z !== null && typeof z == "object" && typeof z.r == "bigint" && typeof z.s == "bigint";
    if (!I && !y) throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
    if (y) j = new v(z.r, z.s);
    else if (I) {
      try {
        j = v.fromBytes(jt("sig", z), "der");
      } catch (m) {
        if (!(m instanceof Hr.Err)) throw m;
      }
      if (!j) try {
        j = v.fromBytes(jt("sig", z), "compact");
      } catch {
        return false;
      }
    }
    return j || false;
  }
  function H(z, j, I, y = {}) {
    const { lowS: m, prehash: N, format: T } = Hc(y, g);
    if (I = jt("publicKey", I), j = P(jt("message", j), N), "strict" in y) throw new Error("options.strict was renamed to lowS");
    const x = T === void 0 ? G(z) : v.fromBytes(jt("sig", z), T);
    if (x === false) return false;
    try {
      const L = r.fromBytes(I);
      if (m && x.hasHighS()) return false;
      const { r: V, s: q } = x, K = A(j), Z = o.inv(q), re = o.create(K * Z), ne = o.create(V * Z), se = r.BASE.multiplyUnsafe(re).add(L.multiplyUnsafe(ne));
      return se.is0() ? false : o.create(se.x) === V;
    } catch {
      return false;
    }
  }
  function R(z, j, I = {}) {
    const { prehash: y } = Hc(I, g);
    return j = P(j, y), v.fromBytes(z, "recovered").recoverPublicKey(j).toBytes();
  }
  return Object.freeze({ keygen: c, getPublicKey: l, getSharedSecret: d, utils: h, lengths: f, Point: r, sign: ee, verify: H, recoverPublicKey: R, Signature: v, hash: e });
}
function oS(r) {
  const e = { a: r.a, b: r.b, p: r.Fp.ORDER, n: r.n, h: r.h, Gx: r.Gx, Gy: r.Gy }, t = r.Fp;
  let n = r.allowedPrivateKeyLengths ? Array.from(new Set(r.allowedPrivateKeyLengths.map((o) => Math.ceil(o / 2)))) : void 0;
  const s = jn(e.n, { BITS: r.nBitLength, allowedLengths: n, modFromBytes: r.wrapPrivateKey }), i = { Fp: t, Fn: s, allowInfinityPoint: r.allowInfinityPoint, endo: r.endo, isTorsionFree: r.isTorsionFree, clearCofactor: r.clearCofactor, fromBytes: r.fromBytes, toBytes: r.toBytes };
  return { CURVE: e, curveOpts: i };
}
function aS(r) {
  const { CURVE: e, curveOpts: t } = oS(r), n = { hmac: r.hmac, randomBytes: r.randomBytes, lowS: r.lowS, bits2int: r.bits2int, bits2int_modN: r.bits2int_modN };
  return { CURVE: e, curveOpts: t, hash: r.hash, ecdsaOpts: n };
}
function cS(r, e) {
  const t = e.Point;
  return Object.assign({}, e, { ProjectivePoint: t, CURVE: Object.assign({}, r, Uy(t.Fn.ORDER, t.Fn.BITS)) });
}
function uS(r) {
  const { CURVE: e, curveOpts: t, hash: n, ecdsaOpts: s } = aS(r), i = nS(e, t), o = sS(i, n, s);
  return cS(r, o);
}
function Pu(r, e) {
  const t = (n) => uS({ ...r, hash: n });
  return { ...t(e), create: t };
}
var Vy = { p: BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff"), n: BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"), h: BigInt(1), a: BigInt("0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc"), b: BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"), Gx: BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"), Gy: BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5") };
var Hy = { p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff"), n: BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973"), h: BigInt(1), a: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000fffffffc"), b: BigInt("0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef"), Gx: BigInt("0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7"), Gy: BigInt("0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f") };
var Gy = { p: BigInt("0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), n: BigInt("0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409"), h: BigInt(1), a: BigInt("0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc"), b: BigInt("0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00"), Gx: BigInt("0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66"), Gy: BigInt("0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650") };
var lS = jn(Vy.p);
var dS = jn(Hy.p);
var hS = jn(Gy.p);
var fS = Pu({ ...Vy, Fp: lS, lowS: false }, Va);
Pu({ ...Hy, Fp: dS, lowS: false }, v4), Pu({ ...Gy, Fp: hS, lowS: false, allowedPrivateKeyLengths: [130, 131, 132] }, b4);
var pS = fS;
var Wy = "base10";
var kt = "base16";
var qt = "base64pad";
var Nn = "base64url";
var qs = "utf8";
var Ky = 0;
var Zr = 1;
var Ys = 2;
var gS = 0;
var gf = 1;
var bs = 12;
var $l = 32;
function yS() {
  const r = ku.utils.randomPrivateKey(), e = ku.getPublicKey(r);
  return { privateKey: Ht(r, kt), publicKey: Ht(e, kt) };
}
function Bu() {
  const r = hi($l);
  return Ht(r, kt);
}
function wS(r, e) {
  const t = ku.getSharedSecret(dr(r, kt), dr(e, kt)), n = DO(Ga, t, void 0, void 0, $l);
  return Ht(n, kt);
}
function Ao(r) {
  const e = Ga(dr(r, kt));
  return Ht(e, kt);
}
function ur(r) {
  const e = Ga(dr(r, qs));
  return Ht(e, kt);
}
function Xy(r) {
  return dr(`${r}`, Wy);
}
function si(r) {
  return Number(Ht(r, Wy));
}
function Zy(r) {
  return r.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function Jy(r) {
  const e = r.replace(/-/g, "+").replace(/_/g, "/"), t = (4 - e.length % 4) % 4;
  return e + "=".repeat(t);
}
function mS(r) {
  const e = Xy(typeof r.type < "u" ? r.type : Ky);
  if (si(e) === Zr && typeof r.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
  const t = typeof r.senderPublicKey < "u" ? dr(r.senderPublicKey, kt) : void 0, n = typeof r.iv < "u" ? dr(r.iv, kt) : hi(bs), s = dr(r.symKey, kt), i = Iy(s, n).encrypt(dr(r.message, qs)), o = ew({ type: e, sealed: i, iv: n, senderPublicKey: t });
  return r.encoding === Nn ? Zy(o) : o;
}
function bS(r) {
  const e = dr(r.symKey, kt), { sealed: t, iv: n } = Ss({ encoded: r.encoded, encoding: r.encoding }), s = Iy(e, n).decrypt(t);
  if (s === null) throw new Error("Failed to decrypt");
  return Ht(s, qs);
}
function vS(r, e) {
  const t = Xy(Ys), n = hi(bs), s = dr(r, qs), i = ew({ type: t, sealed: s, iv: n });
  return e === Nn ? Zy(i) : i;
}
function MS(r, e) {
  const { sealed: t } = Ss({ encoded: r, encoding: e });
  return Ht(t, qs);
}
function ew(r) {
  if (si(r.type) === Ys) return Ht(ms([r.type, r.sealed]), qt);
  if (si(r.type) === Zr) {
    if (typeof r.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
    return Ht(ms([r.type, r.senderPublicKey, r.iv, r.sealed]), qt);
  }
  return Ht(ms([r.type, r.iv, r.sealed]), qt);
}
function Ss(r) {
  const e = (r.encoding || qt) === Nn ? Jy(r.encoded) : r.encoded, t = dr(e, qt), n = t.slice(gS, gf), s = gf;
  if (si(n) === Zr) {
    const u = s + $l, c = u + bs, l = t.slice(s, u), d = t.slice(u, c), h = t.slice(c);
    return { type: n, sealed: h, iv: d, senderPublicKey: l };
  }
  if (si(n) === Ys) {
    const u = t.slice(s), c = hi(bs);
    return { type: n, sealed: u, iv: c };
  }
  const i = s + bs, o = t.slice(s, i), a = t.slice(i);
  return { type: n, sealed: a, iv: o };
}
function ES(r, e) {
  const t = Ss({ encoded: r, encoding: e == null ? void 0 : e.encoding });
  return tw({ type: si(t.type), senderPublicKey: typeof t.senderPublicKey < "u" ? Ht(t.senderPublicKey, kt) : void 0, receiverPublicKey: e == null ? void 0 : e.receiverPublicKey });
}
function tw(r) {
  const e = (r == null ? void 0 : r.type) || Ky;
  if (e === Zr) {
    if (typeof (r == null ? void 0 : r.senderPublicKey) > "u") throw new Error("missing sender public key");
    if (typeof (r == null ? void 0 : r.receiverPublicKey) > "u") throw new Error("missing receiver public key");
  }
  return { type: e, senderPublicKey: r == null ? void 0 : r.senderPublicKey, receiverPublicKey: r == null ? void 0 : r.receiverPublicKey };
}
function yf(r) {
  return r.type === Zr && typeof r.senderPublicKey == "string" && typeof r.receiverPublicKey == "string";
}
function wf(r) {
  return r.type === Ys;
}
function NS(r) {
  const e = Buffer.from(r.x, "base64"), t = Buffer.from(r.y, "base64");
  return ms([new Uint8Array([4]), e, t]);
}
function xS(r, e) {
  const [t, n, s] = r.split("."), i = Buffer.from(Jy(s), "base64");
  if (i.length !== 64) throw new Error("Invalid signature length");
  const o = i.slice(0, 32), a = i.slice(32, 64), u = `${t}.${n}`, c = Ga(u), l = NS(e);
  if (!pS.verify(ms([o, a]), c, l)) throw new Error("Invalid signature");
  return wu(r).payload;
}
var IS = "irn";
function Zo(r) {
  return (r == null ? void 0 : r.relay) || { protocol: IS };
}
function Di(r) {
  const e = eA[r];
  if (typeof e > "u") throw new Error(`Relay Protocol not supported: ${r}`);
  return e;
}
var _S = Object.defineProperty;
var DS = Object.defineProperties;
var TS = Object.getOwnPropertyDescriptors;
var mf = Object.getOwnPropertySymbols;
var AS = Object.prototype.hasOwnProperty;
var OS = Object.prototype.propertyIsEnumerable;
var bf = (r, e, t) => e in r ? _S(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;
var Gc = (r, e) => {
  for (var t in e || (e = {})) AS.call(e, t) && bf(r, t, e[t]);
  if (mf) for (var t of mf(e)) OS.call(e, t) && bf(r, t, e[t]);
  return r;
};
var SS = (r, e) => DS(r, TS(e));
function jS(r, e = "-") {
  const t = {}, n = "relay" + e;
  return Object.keys(r).forEach((s) => {
    if (s.startsWith(n)) {
      const i = s.replace(n, ""), o = r[s];
      t[i] = o;
    }
  }), t;
}
function vf(r) {
  if (!r.includes("wc:")) {
    const c = sy(r);
    c != null && c.includes("wc:") && (r = c);
  }
  r = r.includes("wc://") ? r.replace("wc://", "") : r, r = r.includes("wc:") ? r.replace("wc:", "") : r;
  const e = r.indexOf(":"), t = r.indexOf("?") !== -1 ? r.indexOf("?") : void 0, n = r.substring(0, e), s = r.substring(e + 1, t).split("@"), i = typeof t < "u" ? r.substring(t) : "", o = new URLSearchParams(i), a = Object.fromEntries(o.entries()), u = typeof a.methods == "string" ? a.methods.split(",") : void 0;
  return { protocol: n, topic: CS(s[0]), version: parseInt(s[1], 10), symKey: a.symKey, relay: jS(a), methods: u, expiryTimestamp: a.expiryTimestamp ? parseInt(a.expiryTimestamp, 10) : void 0 };
}
function CS(r) {
  return r.startsWith("//") ? r.substring(2) : r;
}
function LS(r, e = "-") {
  const t = "relay", n = {};
  return Object.keys(r).forEach((s) => {
    const i = s, o = t + e + i;
    r[i] && (n[o] = r[i]);
  }), n;
}
function Mf(r) {
  const e = new URLSearchParams(), t = Gc(Gc(SS(Gc({}, LS(r.relay)), { symKey: r.symKey }), r.expiryTimestamp && { expiryTimestamp: r.expiryTimestamp.toString() }), r.methods && { methods: r.methods.join(",") });
  return Object.entries(t).sort(([n], [s]) => n.localeCompare(s)).forEach(([n, s]) => {
    s !== void 0 && e.append(n, String(s));
  }), `${r.protocol}:${r.topic}@${r.version}?${e}`;
}
function vo(r, e, t) {
  return `${r}?wc_ev=${t}&topic=${e}`;
}
var zS = Object.defineProperty;
var kS = Object.defineProperties;
var US = Object.getOwnPropertyDescriptors;
var Ef = Object.getOwnPropertySymbols;
var PS = Object.prototype.hasOwnProperty;
var BS = Object.prototype.propertyIsEnumerable;
var Nf = (r, e, t) => e in r ? zS(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;
var RS = (r, e) => {
  for (var t in e || (e = {})) PS.call(e, t) && Nf(r, t, e[t]);
  if (Ef) for (var t of Ef(e)) BS.call(e, t) && Nf(r, t, e[t]);
  return r;
};
var $S = (r, e) => kS(r, US(e));
function Yi(r) {
  const e = [];
  return r.forEach((t) => {
    const [n, s] = t.split(":");
    e.push(`${n}:${s}`);
  }), e;
}
function FS(r) {
  const e = [];
  return Object.values(r).forEach((t) => {
    e.push(...Yi(t.accounts));
  }), e;
}
function QS(r, e) {
  const t = [];
  return Object.values(r).forEach((n) => {
    Yi(n.accounts).includes(e) && t.push(...n.methods);
  }), t;
}
function qS(r, e) {
  const t = [];
  return Object.values(r).forEach((n) => {
    Yi(n.accounts).includes(e) && t.push(...n.events);
  }), t;
}
function rw(r) {
  return r.includes(":");
}
function YS(r) {
  return rw(r) ? r.split(":")[0] : r;
}
function xf(r) {
  var e, t, n;
  const s = {};
  if (!js(r)) return s;
  for (const [i, o] of Object.entries(r)) {
    const a = rw(i) ? [i] : o.chains, u = o.methods || [], c = o.events || [], l = YS(i);
    s[l] = $S(RS({}, s[l]), { chains: ei(a, (e = s[l]) == null ? void 0 : e.chains), methods: ei(u, (t = s[l]) == null ? void 0 : t.methods), events: ei(c, (n = s[l]) == null ? void 0 : n.events) });
  }
  return s;
}
function VS(r) {
  const e = {};
  return r == null || r.forEach((t) => {
    var n;
    const [s, i] = t.split(":");
    e[s] || (e[s] = { accounts: [], chains: [], events: [], methods: [] }), e[s].accounts.push(t), (n = e[s].chains) == null || n.push(`${s}:${i}`);
  }), e;
}
function If(r, e) {
  e = e.map((n) => n.replace("did:pkh:", ""));
  const t = VS(e);
  for (const [n, s] of Object.entries(t)) s.methods ? s.methods = ei(s.methods, r) : s.methods = r, s.events = ["chainChanged", "accountsChanged"];
  return t;
}
function HS(r, e) {
  var t, n, s, i, o, a;
  const u = xf(r), c = xf(e), l = {}, d = Object.keys(u).concat(Object.keys(c));
  for (const h of d) l[h] = { chains: ei((t = u[h]) == null ? void 0 : t.chains, (n = c[h]) == null ? void 0 : n.chains), methods: ei((s = u[h]) == null ? void 0 : s.methods, (i = c[h]) == null ? void 0 : i.methods), events: ei((o = u[h]) == null ? void 0 : o.events, (a = c[h]) == null ? void 0 : a.events) };
  return l;
}
var GS = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } };
var WS = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
function ae(r, e) {
  const { message: t, code: n } = WS[r];
  return { message: e ? `${t} ${e}` : t, code: n };
}
function Je(r, e) {
  const { message: t, code: n } = GS[r];
  return { message: e ? `${t} ${e}` : t, code: n };
}
function Ri(r, e) {
  return Array.isArray(r) ? typeof e < "u" && r.length ? r.every(e) : true : false;
}
function js(r) {
  return Object.getPrototypeOf(r) === Object.prototype && Object.keys(r).length;
}
function ut(r) {
  return typeof r > "u";
}
function it(r, e) {
  return e && ut(r) ? true : typeof r == "string" && !!r.trim().length;
}
function Fl(r, e) {
  return e && ut(r) ? true : typeof r == "number" && !isNaN(r);
}
function KS(r, e) {
  const { requiredNamespaces: t } = e, n = Object.keys(r.namespaces), s = Object.keys(t);
  let i = true;
  return Wn(s, n) ? (n.forEach((o) => {
    const { accounts: a, methods: u, events: c } = r.namespaces[o], l = Yi(a), d = t[o];
    (!Wn(ey(o, d), l) || !Wn(d.methods, u) || !Wn(d.events, c)) && (i = false);
  }), i) : false;
}
function Jo(r) {
  return it(r, false) && r.includes(":") ? r.split(":").length === 2 : false;
}
function XS(r) {
  if (it(r, false) && r.includes(":")) {
    const e = r.split(":");
    if (e.length === 3) {
      const t = e[0] + ":" + e[1];
      return !!e[2] && Jo(t);
    }
  }
  return false;
}
function ZS(r) {
  function e(t) {
    try {
      return typeof new URL(t) < "u";
    } catch {
      return false;
    }
  }
  try {
    if (it(r, false)) {
      if (e(r)) return true;
      const t = sy(r);
      return e(t);
    }
  } catch {
  }
  return false;
}
function JS(r) {
  var e;
  return (e = r == null ? void 0 : r.proposer) == null ? void 0 : e.publicKey;
}
function e3(r) {
  return r == null ? void 0 : r.topic;
}
function t3(r, e) {
  let t = null;
  return it(r == null ? void 0 : r.publicKey, false) || (t = ae("MISSING_OR_INVALID", `${e} controller public key should be a string`)), t;
}
function _f(r) {
  let e = true;
  return Ri(r) ? r.length && (e = r.every((t) => it(t, false))) : e = false, e;
}
function r3(r, e, t) {
  let n = null;
  return Ri(e) && e.length ? e.forEach((s) => {
    n || Jo(s) || (n = Je("UNSUPPORTED_CHAINS", `${t}, chain ${s} should be a string and conform to "namespace:chainId" format`));
  }) : Jo(r) || (n = Je("UNSUPPORTED_CHAINS", `${t}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)), n;
}
function n3(r, e, t) {
  let n = null;
  return Object.entries(r).forEach(([s, i]) => {
    if (n) return;
    const o = r3(s, ey(s, i), `${e} ${t}`);
    o && (n = o);
  }), n;
}
function i3(r, e) {
  let t = null;
  return Ri(r) ? r.forEach((n) => {
    t || XS(n) || (t = Je("UNSUPPORTED_ACCOUNTS", `${e}, account ${n} should be a string and conform to "namespace:chainId:address" format`));
  }) : t = Je("UNSUPPORTED_ACCOUNTS", `${e}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), t;
}
function s3(r, e) {
  let t = null;
  return Object.values(r).forEach((n) => {
    if (t) return;
    const s = i3(n == null ? void 0 : n.accounts, `${e} namespace`);
    s && (t = s);
  }), t;
}
function o3(r, e) {
  let t = null;
  return _f(r == null ? void 0 : r.methods) ? _f(r == null ? void 0 : r.events) || (t = Je("UNSUPPORTED_EVENTS", `${e}, events should be an array of strings or empty array for no events`)) : t = Je("UNSUPPORTED_METHODS", `${e}, methods should be an array of strings or empty array for no methods`), t;
}
function nw(r, e) {
  let t = null;
  return Object.values(r).forEach((n) => {
    if (t) return;
    const s = o3(n, `${e}, namespace`);
    s && (t = s);
  }), t;
}
function a3(r, e, t) {
  let n = null;
  if (r && js(r)) {
    const s = nw(r, e);
    s && (n = s);
    const i = n3(r, e, t);
    i && (n = i);
  } else n = ae("MISSING_OR_INVALID", `${e}, ${t} should be an object with data`);
  return n;
}
function Wc(r, e) {
  let t = null;
  if (r && js(r)) {
    const n = nw(r, e);
    n && (t = n);
    const s = s3(r, e);
    s && (t = s);
  } else t = ae("MISSING_OR_INVALID", `${e}, namespaces should be an object with data`);
  return t;
}
function iw(r) {
  return it(r.protocol, true);
}
function c3(r, e) {
  let t = false;
  return r ? r && Ri(r) && r.length && r.forEach((n) => {
    t = iw(n);
  }) : t = true, t;
}
function u3(r) {
  return typeof r == "number";
}
function $t(r) {
  return typeof r < "u" && typeof r !== null;
}
function l3(r) {
  return !(!r || typeof r != "object" || !r.code || !Fl(r.code, false) || !r.message || !it(r.message, false));
}
function d3(r) {
  return !(ut(r) || !it(r.method, false));
}
function h3(r) {
  return !(ut(r) || ut(r.result) && ut(r.error) || !Fl(r.id, false) || !it(r.jsonrpc, false));
}
function f3(r) {
  return !(ut(r) || !it(r.name, false));
}
function Df(r, e) {
  return !(!Jo(e) || !FS(r).includes(e));
}
function p3(r, e, t) {
  return it(t, false) ? QS(r, e).includes(t) : false;
}
function g3(r, e, t) {
  return it(t, false) ? qS(r, e).includes(t) : false;
}
function Tf(r, e, t) {
  let n = null;
  const s = y3(r), i = w3(e), o = Object.keys(s), a = Object.keys(i), u = Af(Object.keys(r)), c = Af(Object.keys(e)), l = u.filter((d) => !c.includes(d));
  return l.length && (n = ae("NON_CONFORMING_NAMESPACES", `${t} namespaces keys don't satisfy requiredNamespaces.
      Required: ${l.toString()}
      Received: ${Object.keys(e).toString()}`)), Wn(o, a) || (n = ae("NON_CONFORMING_NAMESPACES", `${t} namespaces chains don't satisfy required namespaces.
      Required: ${o.toString()}
      Approved: ${a.toString()}`)), Object.keys(e).forEach((d) => {
    if (!d.includes(":") || n) return;
    const h = Yi(e[d].accounts);
    h.includes(d) || (n = ae("NON_CONFORMING_NAMESPACES", `${t} namespaces accounts don't satisfy namespace accounts for ${d}
        Required: ${d}
        Approved: ${h.toString()}`));
  }), o.forEach((d) => {
    n || (Wn(s[d].methods, i[d].methods) ? Wn(s[d].events, i[d].events) || (n = ae("NON_CONFORMING_NAMESPACES", `${t} namespaces events don't satisfy namespace events for ${d}`)) : n = ae("NON_CONFORMING_NAMESPACES", `${t} namespaces methods don't satisfy namespace methods for ${d}`));
  }), n;
}
function y3(r) {
  const e = {};
  return Object.keys(r).forEach((t) => {
    var n;
    t.includes(":") ? e[t] = r[t] : (n = r[t].chains) == null || n.forEach((s) => {
      e[s] = { methods: r[t].methods, events: r[t].events };
    });
  }), e;
}
function Af(r) {
  return [...new Set(r.map((e) => e.includes(":") ? e.split(":")[0] : e))];
}
function w3(r) {
  const e = {};
  return Object.keys(r).forEach((t) => {
    if (t.includes(":")) e[t] = r[t];
    else {
      const n = Yi(r[t].accounts);
      n == null || n.forEach((s) => {
        e[s] = { accounts: r[t].accounts.filter((i) => i.includes(`${s}:`)), methods: r[t].methods, events: r[t].events };
      });
    }
  }), e;
}
function m3(r, e) {
  return Fl(r, false) && r <= e.max && r >= e.min;
}
function Of() {
  const r = $s();
  return new Promise((e) => {
    switch (r) {
      case er.browser:
        e(b3());
        break;
      case er.reactNative:
        e(v3());
        break;
      case er.node:
        e(M3());
        break;
      default:
        e(true);
    }
  });
}
function b3() {
  return qi() && (navigator == null ? void 0 : navigator.onLine);
}
async function v3() {
  if (Sn() && typeof global < "u" && global != null && global.NetInfo) {
    const r = await (global == null ? void 0 : global.NetInfo.fetch());
    return r == null ? void 0 : r.isConnected;
  }
  return true;
}
function M3() {
  return true;
}
function E3(r) {
  switch ($s()) {
    case er.browser:
      N3(r);
      break;
    case er.reactNative:
      x3(r);
      break;
  }
}
function N3(r) {
  !Sn() && qi() && (window.addEventListener("online", () => r(true)), window.addEventListener("offline", () => r(false)));
}
function x3(r) {
  Sn() && typeof global < "u" && global != null && global.NetInfo && (global == null || global.NetInfo.addEventListener((e) => r(e == null ? void 0 : e.isConnected)));
}
function I3() {
  var r;
  return qi() && ri() ? ((r = ri()) == null ? void 0 : r.visibilityState) === "visible" : true;
}
var Kc = {};
var cs = class {
  static get(e) {
    return Kc[e];
  }
  static set(e, t) {
    Kc[e] = t;
  }
  static delete(e) {
    delete Kc[e];
  }
};
function _3(r) {
  const e = Bs.decode(r);
  if (e.length < 33) throw new Error("Too short to contain a public key");
  return e.slice(1, 33);
}
function D3({ publicKey: r, signature: e, payload: t }) {
  var n;
  const s = Ru(t.method), i = 128 | parseInt(((n = t.version) == null ? void 0 : n.toString()) || "4"), o = O3(t.address), a = t.era === "00" ? new Uint8Array([0]) : Ru(t.era);
  if (a.length !== 1 && a.length !== 2) throw new Error("Invalid era length");
  const u = parseInt(t.nonce, 16), c = new Uint8Array([u & 255, u >> 8 & 255]), l = BigInt(`0x${A3(t.tip)}`), d = j3(l), h = new Uint8Array([0, ...r, o, ...e, ...a, ...c, ...d, ...s]), f = S3(h.length + 1);
  return new Uint8Array([...f, i, ...h]);
}
function T3(r) {
  const e = Ru(r), t = hA.blake2b(e, void 0, 32);
  return "0x" + Buffer.from(t).toString("hex");
}
function Ru(r) {
  return new Uint8Array(r.replace(/^0x/, "").match(/.{1,2}/g).map((e) => parseInt(e, 16)));
}
function A3(r) {
  return r.startsWith("0x") ? r.slice(2) : r;
}
function O3(r) {
  const e = Bs.decode(r)[0];
  return e === 42 ? 0 : e === 60 ? 2 : 1;
}
function S3(r) {
  if (r < 64) return new Uint8Array([r << 2]);
  if (r < 16384) {
    const e = r << 2 | 1;
    return new Uint8Array([e & 255, e >> 8 & 255]);
  } else if (r < 1 << 30) {
    const e = r << 2 | 2;
    return new Uint8Array([e & 255, e >> 8 & 255, e >> 16 & 255, e >> 24 & 255]);
  } else throw new Error("Compact encoding > 2^30 not supported");
}
function j3(r) {
  if (r < BigInt(1) << BigInt(6)) return new Uint8Array([Number(r << BigInt(2))]);
  if (r < BigInt(1) << BigInt(14)) {
    const e = r << BigInt(2) | BigInt(1);
    return new Uint8Array([Number(e & BigInt(255)), Number(e >> BigInt(8) & BigInt(255))]);
  } else if (r < BigInt(1) << BigInt(30)) {
    const e = r << BigInt(2) | BigInt(2);
    return new Uint8Array([Number(e & BigInt(255)), Number(e >> BigInt(8) & BigInt(255)), Number(e >> BigInt(16) & BigInt(255)), Number(e >> BigInt(24) & BigInt(255))]);
  } else throw new Error("BigInt compact encoding not supported > 2^30");
}
function C3(r) {
  const e = Uint8Array.from(Buffer.from(r.signature, "hex")), t = _3(r.transaction.address), n = D3({ publicKey: t, signature: e, payload: r.transaction }), s = Buffer.from(n).toString("hex");
  return T3(s);
}
function sw({ logger: r, name: e }) {
  const t = typeof r == "string" ? yg({ opts: { level: r, name: e } }).logger : r;
  return t.level = typeof r == "string" ? r : r.level, t;
}
var L3 = "PARSE_ERROR";
var z3 = "INVALID_REQUEST";
var k3 = "METHOD_NOT_FOUND";
var U3 = "INVALID_PARAMS";
var ow = "INTERNAL_ERROR";
var Ql = "SERVER_ERROR";
var P3 = [-32700, -32600, -32601, -32602, -32603];
var vs = {
  [L3]: { code: -32700, message: "Parse error" },
  [z3]: { code: -32600, message: "Invalid Request" },
  [k3]: { code: -32601, message: "Method not found" },
  [U3]: { code: -32602, message: "Invalid params" },
  [ow]: { code: -32603, message: "Internal error" },
  [Ql]: { code: -32e3, message: "Server error" }
};
var aw = Ql;
function B3(r) {
  return P3.includes(r);
}
function Sf(r) {
  return Object.keys(vs).includes(r) ? vs[r] : vs[aw];
}
function R3(r) {
  const e = Object.values(vs).find((t) => t.code === r);
  return e || vs[aw];
}
function $3(r, e, t) {
  return r.message.includes("getaddrinfo ENOTFOUND") || r.message.includes("connect ECONNREFUSED") ? new Error(`Unavailable ${t} RPC url at ${e}`) : r;
}
var cw = {};
var Rr = {};
var jf;
function F3() {
  if (jf) return Rr;
  jf = 1, Object.defineProperty(Rr, "__esModule", { value: true }), Rr.isBrowserCryptoAvailable = Rr.getSubtleCrypto = Rr.getBrowerCrypto = void 0;
  function r() {
    return (B == null ? void 0 : B.crypto) || (B == null ? void 0 : B.msCrypto) || {};
  }
  Rr.getBrowerCrypto = r;
  function e() {
    const n = r();
    return n.subtle || n.webkitSubtle;
  }
  Rr.getSubtleCrypto = e;
  function t() {
    return !!r() && !!e();
  }
  return Rr.isBrowserCryptoAvailable = t, Rr;
}
var $r = {};
var Cf;
function Q3() {
  if (Cf) return $r;
  Cf = 1, Object.defineProperty($r, "__esModule", { value: true }), $r.isBrowser = $r.isNode = $r.isReactNative = void 0;
  function r() {
    return typeof document > "u" && typeof navigator < "u" && navigator.product === "ReactNative";
  }
  $r.isReactNative = r;
  function e() {
    return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
  }
  $r.isNode = e;
  function t() {
    return !r() && !e();
  }
  return $r.isBrowser = t, $r;
}
(function(r) {
  Object.defineProperty(r, "__esModule", { value: true });
  const e = Ls;
  e.__exportStar(F3(), r), e.__exportStar(Q3(), r);
})(cw);
function Or(r = 3) {
  const e = Date.now() * Math.pow(10, r), t = Math.floor(Math.random() * Math.pow(10, r));
  return e + t;
}
function _n(r = 6) {
  return BigInt(Or(r));
}
function Gr(r, e, t) {
  return {
    id: t || Or(),
    jsonrpc: "2.0",
    method: r,
    params: e
  };
}
function ea(r, e) {
  return {
    id: r,
    jsonrpc: "2.0",
    result: e
  };
}
function ql(r, e, t) {
  return {
    id: r,
    jsonrpc: "2.0",
    error: q3(e)
  };
}
function q3(r, e) {
  return typeof r > "u" ? Sf(ow) : (typeof r == "string" && (r = Object.assign(Object.assign({}, Sf(Ql)), { message: r })), B3(r.code) && (r = R3(r.code)), r);
}
var Y3 = class {
};
var V3 = class extends Y3 {
  constructor() {
    super();
  }
};
var H3 = class extends V3 {
  constructor(e) {
    super();
  }
};
var G3 = "^wss?:";
function W3(r) {
  const e = r.match(new RegExp(/^\w+:/, "gi"));
  if (!(!e || !e.length))
    return e[0];
}
function K3(r, e) {
  const t = W3(r);
  return typeof t > "u" ? false : new RegExp(e).test(t);
}
function Lf(r) {
  return K3(r, G3);
}
function X3(r) {
  return new RegExp("wss?://localhost(:d{2,5})?").test(r);
}
function uw(r) {
  return typeof r == "object" && "id" in r && "jsonrpc" in r && r.jsonrpc === "2.0";
}
function Yl(r) {
  return uw(r) && "method" in r;
}
function Xa(r) {
  return uw(r) && (Sr(r) || lr(r));
}
function Sr(r) {
  return "result" in r;
}
function lr(r) {
  return "error" in r;
}
var Z3 = class extends H3 {
  constructor(e) {
    super(e), this.events = new Gt.EventEmitter(), this.hasRegisteredEventListeners = false, this.connection = this.setConnection(e), this.connection.connected && this.registerEventListeners();
  }
  async connect(e = this.connection) {
    await this.open(e);
  }
  async disconnect() {
    await this.close();
  }
  on(e, t) {
    this.events.on(e, t);
  }
  once(e, t) {
    this.events.once(e, t);
  }
  off(e, t) {
    this.events.off(e, t);
  }
  removeListener(e, t) {
    this.events.removeListener(e, t);
  }
  async request(e, t) {
    return this.requestStrict(Gr(e.method, e.params || [], e.id || _n().toString()), t);
  }
  async requestStrict(e, t) {
    return new Promise(async (n, s) => {
      if (!this.connection.connected) try {
        await this.open();
      } catch (i) {
        s(i);
      }
      this.events.on(`${e.id}`, (i) => {
        lr(i) ? s(i.error) : n(i.result);
      });
      try {
        await this.connection.send(e, t);
      } catch (i) {
        s(i);
      }
    });
  }
  setConnection(e = this.connection) {
    return e;
  }
  onPayload(e) {
    this.events.emit("payload", e), Xa(e) ? this.events.emit(`${e.id}`, e) : this.events.emit("message", { type: e.method, data: e.params });
  }
  onClose(e) {
    e && e.code === 3e3 && this.events.emit("error", new Error(`WebSocket connection closed abnormally with code: ${e.code} ${e.reason ? `(${e.reason})` : ""}`)), this.events.emit("disconnect");
  }
  async open(e = this.connection) {
    this.connection === e && this.connection.connected || (this.connection.connected && this.close(), typeof e == "string" && (await this.connection.open(e), e = this.connection), this.connection = this.setConnection(e), await this.connection.open(), this.registerEventListeners(), this.events.emit("connect"));
  }
  async close() {
    await this.connection.close();
  }
  registerEventListeners() {
    this.hasRegisteredEventListeners || (this.connection.on("payload", (e) => this.onPayload(e)), this.connection.on("close", (e) => this.onClose(e)), this.connection.on("error", (e) => this.events.emit("error", e)), this.connection.on("register_error", (e) => this.onClose()), this.hasRegisteredEventListeners = true);
  }
};
var J3 = () => typeof WebSocket < "u" ? WebSocket : typeof global < "u" && typeof global.WebSocket < "u" ? global.WebSocket : typeof window < "u" && typeof window.WebSocket < "u" ? window.WebSocket : typeof self < "u" && typeof self.WebSocket < "u" ? self.WebSocket : require_browser();
var ej = () => typeof WebSocket < "u" || typeof global < "u" && typeof global.WebSocket < "u" || typeof window < "u" && typeof window.WebSocket < "u" || typeof self < "u" && typeof self.WebSocket < "u";
var zf = (r) => r.split("?")[0];
var kf = 10;
var tj = J3();
var rj = class {
  constructor(e) {
    if (this.url = e, this.events = new Gt.EventEmitter(), this.registering = false, !Lf(e)) throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);
    this.url = e;
  }
  get connected() {
    return typeof this.socket < "u";
  }
  get connecting() {
    return this.registering;
  }
  on(e, t) {
    this.events.on(e, t);
  }
  once(e, t) {
    this.events.once(e, t);
  }
  off(e, t) {
    this.events.off(e, t);
  }
  removeListener(e, t) {
    this.events.removeListener(e, t);
  }
  async open(e = this.url) {
    await this.register(e);
  }
  async close() {
    return new Promise((e, t) => {
      if (typeof this.socket > "u") {
        t(new Error("Connection already closed"));
        return;
      }
      this.socket.onclose = (n) => {
        this.onClose(n), e();
      }, this.socket.close();
    });
  }
  async send(e) {
    typeof this.socket > "u" && (this.socket = await this.register());
    try {
      this.socket.send(ti(e));
    } catch (t) {
      this.onError(e.id, t);
    }
  }
  register(e = this.url) {
    if (!Lf(e)) throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);
    if (this.registering) {
      const t = this.events.getMaxListeners();
      return (this.events.listenerCount("register_error") >= t || this.events.listenerCount("open") >= t) && this.events.setMaxListeners(t + 1), new Promise((n, s) => {
        this.events.once("register_error", (i) => {
          this.resetMaxListeners(), s(i);
        }), this.events.once("open", () => {
          if (this.resetMaxListeners(), typeof this.socket > "u") return s(new Error("WebSocket connection is missing or invalid"));
          n(this.socket);
        });
      });
    }
    return this.url = e, this.registering = true, new Promise((t, n) => {
      const s = cw.isReactNative() ? void 0 : { rejectUnauthorized: !X3(e) }, i = new tj(e, [], s);
      ej() ? i.onerror = (o) => {
        const a = o;
        n(this.emitError(a.error));
      } : i.on("error", (o) => {
        n(this.emitError(o));
      }), i.onopen = () => {
        this.onOpen(i), t(i);
      };
    });
  }
  onOpen(e) {
    e.onmessage = (t) => this.onPayload(t), e.onclose = (t) => this.onClose(t), this.socket = e, this.registering = false, this.events.emit("open");
  }
  onClose(e) {
    this.socket = void 0, this.registering = false, this.events.emit("close", e);
  }
  onPayload(e) {
    if (typeof e.data > "u") return;
    const t = typeof e.data == "string" ? zi(e.data) : e.data;
    this.events.emit("payload", t);
  }
  onError(e, t) {
    const n = this.parseError(t), s = n.message || n.toString(), i = ql(e, s);
    this.events.emit("payload", i);
  }
  parseError(e, t = this.url) {
    return $3(e, zf(t), "WS");
  }
  resetMaxListeners() {
    this.events.getMaxListeners() > kf && this.events.setMaxListeners(kf);
  }
  emitError(e) {
    const t = this.parseError(new Error((e == null ? void 0 : e.message) || `WebSocket connection failed for host: ${zf(this.url)}`));
    return this.events.emit("register_error", t), t;
  }
};
var lw = "wc";
var dw = 2;
var $u = "core";
var Lr = `${lw}@2:${$u}:`;
var nj = { logger: "error" };
var ij = { database: ":memory:" };
var sj = "crypto";
var Uf = "client_ed25519_seed";
var oj = ce.ONE_DAY;
var aj = "keychain";
var cj = "0.3";
var uj = "messages";
var lj = "0.3";
var dj = ce.SIX_HOURS;
var hj = "publisher";
var hw = "irn";
var fj = "error";
var fw = "wss://relay.walletconnect.org";
var pj = "relayer";
var tt = { message: "relayer_message", message_ack: "relayer_message_ack", connect: "relayer_connect", disconnect: "relayer_disconnect", error: "relayer_error", connection_stalled: "relayer_connection_stalled", transport_closed: "relayer_transport_closed", publish: "relayer_publish" };
var gj = "_subscription";
var ir = { payload: "payload", connect: "connect", disconnect: "disconnect", error: "error" };
var yj = 0.1;
var Fu = "2.22.3";
var Ye = { link_mode: "link_mode", relay: "relay" };
var Oo = { inbound: "inbound", outbound: "outbound" };
var wj = "0.3";
var mj = "WALLETCONNECT_CLIENT_ID";
var Pf = "WALLETCONNECT_LINK_MODE_APPS";
var Xt = { created: "subscription_created", deleted: "subscription_deleted", expired: "subscription_expired", disabled: "subscription_disabled", sync: "subscription_sync", resubscribed: "subscription_resubscribed" };
var bj = "subscription";
var vj = "0.3";
var Mj = "pairing";
var Ej = "0.3";
var us = { wc_pairingDelete: { req: { ttl: ce.ONE_DAY, prompt: false, tag: 1e3 }, res: { ttl: ce.ONE_DAY, prompt: false, tag: 1001 } }, wc_pairingPing: { req: { ttl: ce.THIRTY_SECONDS, prompt: false, tag: 1002 }, res: { ttl: ce.THIRTY_SECONDS, prompt: false, tag: 1003 } }, unregistered_method: { req: { ttl: ce.ONE_DAY, prompt: false, tag: 0 }, res: { ttl: ce.ONE_DAY, prompt: false, tag: 0 } } };
var Vn = { create: "pairing_create", expire: "pairing_expire", delete: "pairing_delete", ping: "pairing_ping" };
var gr = { created: "history_created", updated: "history_updated", deleted: "history_deleted", sync: "history_sync" };
var Nj = "history";
var xj = "0.3";
var Ij = "expirer";
var or = { created: "expirer_created", deleted: "expirer_deleted", expired: "expirer_expired", sync: "expirer_sync" };
var _j = "0.3";
var Dj = "verify-api";
var Tj = "https://verify.walletconnect.com";
var pw = "https://verify.walletconnect.org";
var Ms = pw;
var Aj = `${Ms}/v3`;
var Oj = [Tj, pw];
var Sj = "echo";
var jj = "https://echo.walletconnect.com";
var Ar = { pairing_started: "pairing_started", pairing_uri_validation_success: "pairing_uri_validation_success", pairing_uri_not_expired: "pairing_uri_not_expired", store_new_pairing: "store_new_pairing", subscribing_pairing_topic: "subscribing_pairing_topic", subscribe_pairing_topic_success: "subscribe_pairing_topic_success", existing_pairing: "existing_pairing", pairing_not_expired: "pairing_not_expired", emit_inactive_pairing: "emit_inactive_pairing", emit_session_proposal: "emit_session_proposal", subscribing_to_pairing_topic: "subscribing_to_pairing_topic" };
var qr = { no_wss_connection: "no_wss_connection", no_internet_connection: "no_internet_connection", malformed_pairing_uri: "malformed_pairing_uri", active_pairing_already_exists: "active_pairing_already_exists", subscribe_pairing_topic_failure: "subscribe_pairing_topic_failure", pairing_expired: "pairing_expired", proposal_expired: "proposal_expired", proposal_listener_not_found: "proposal_listener_not_found" };
var yr = { session_approve_started: "session_approve_started", proposal_not_expired: "proposal_not_expired", session_namespaces_validation_success: "session_namespaces_validation_success", create_session_topic: "create_session_topic", subscribing_session_topic: "subscribing_session_topic", subscribe_session_topic_success: "subscribe_session_topic_success", publishing_session_approve: "publishing_session_approve", session_approve_publish_success: "session_approve_publish_success", store_session: "store_session", publishing_session_settle: "publishing_session_settle", session_settle_publish_success: "session_settle_publish_success", session_request_response_started: "session_request_response_started", session_request_response_validation_success: "session_request_response_validation_success", session_request_response_publish_started: "session_request_response_publish_started" };
var Rn = { no_internet_connection: "no_internet_connection", no_wss_connection: "no_wss_connection", proposal_expired: "proposal_expired", subscribe_session_topic_failure: "subscribe_session_topic_failure", session_approve_publish_failure: "session_approve_publish_failure", session_settle_publish_failure: "session_settle_publish_failure", session_approve_namespace_validation_failure: "session_approve_namespace_validation_failure", proposal_not_found: "proposal_not_found", session_request_response_validation_failure: "session_request_response_validation_failure", session_request_response_publish_failure: "session_request_response_publish_failure" };
var $n = { authenticated_session_approve_started: "authenticated_session_approve_started", create_authenticated_session_topic: "create_authenticated_session_topic", cacaos_verified: "cacaos_verified", store_authenticated_session: "store_authenticated_session", subscribing_authenticated_session_topic: "subscribing_authenticated_session_topic", subscribe_authenticated_session_topic_success: "subscribe_authenticated_session_topic_success", publishing_authenticated_session_approve: "publishing_authenticated_session_approve" };
var ls = { no_internet_connection: "no_internet_connection", invalid_cacao: "invalid_cacao", subscribe_authenticated_session_topic_failure: "subscribe_authenticated_session_topic_failure", authenticated_session_approve_publish_failure: "authenticated_session_approve_publish_failure", authenticated_session_pending_request_not_found: "authenticated_session_pending_request_not_found" };
var Cj = 0.1;
var Lj = "event-client";
var zj = 86400;
var kj = "https://pulse.walletconnect.org/batch";
function Uj(r, e) {
  if (r.length >= 255) throw new TypeError("Alphabet too long");
  for (var t = new Uint8Array(256), n = 0; n < t.length; n++) t[n] = 255;
  for (var s = 0; s < r.length; s++) {
    var i = r.charAt(s), o = i.charCodeAt(0);
    if (t[o] !== 255) throw new TypeError(i + " is ambiguous");
    t[o] = s;
  }
  var a = r.length, u = r.charAt(0), c = Math.log(a) / Math.log(256), l = Math.log(256) / Math.log(a);
  function d(g) {
    if (g instanceof Uint8Array || (ArrayBuffer.isView(g) ? g = new Uint8Array(g.buffer, g.byteOffset, g.byteLength) : Array.isArray(g) && (g = Uint8Array.from(g))), !(g instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (g.length === 0) return "";
    for (var p = 0, b = 0, _ = 0, D = g.length; _ !== D && g[_] === 0; ) _++, p++;
    for (var v = (D - _) * l + 1 >>> 0, E = new Uint8Array(v); _ !== D; ) {
      for (var A = g[_], k = 0, U = v - 1; (A !== 0 || k < b) && U !== -1; U--, k++) A += 256 * E[U] >>> 0, E[U] = A % a >>> 0, A = A / a >>> 0;
      if (A !== 0) throw new Error("Non-zero carry");
      b = k, _++;
    }
    for (var P = v - b; P !== v && E[P] === 0; ) P++;
    for (var $ = u.repeat(p); P < v; ++P) $ += r.charAt(E[P]);
    return $;
  }
  function h(g) {
    if (typeof g != "string") throw new TypeError("Expected String");
    if (g.length === 0) return new Uint8Array();
    var p = 0;
    if (g[p] !== " ") {
      for (var b = 0, _ = 0; g[p] === u; ) b++, p++;
      for (var D = (g.length - p) * c + 1 >>> 0, v = new Uint8Array(D); g[p]; ) {
        var E = t[g.charCodeAt(p)];
        if (E === 255) return;
        for (var A = 0, k = D - 1; (E !== 0 || A < _) && k !== -1; k--, A++) E += a * v[k] >>> 0, v[k] = E % 256 >>> 0, E = E / 256 >>> 0;
        if (E !== 0) throw new Error("Non-zero carry");
        _ = A, p++;
      }
      if (g[p] !== " ") {
        for (var U = D - _; U !== D && v[U] === 0; ) U++;
        for (var P = new Uint8Array(b + (D - U)), $ = b; U !== D; ) P[$++] = v[U++];
        return P;
      }
    }
  }
  function f(g) {
    var p = h(g);
    if (p) return p;
    throw new Error(`Non-${e} character`);
  }
  return { encode: d, decodeUnsafe: h, decode: f };
}
var Pj = Uj;
var Bj = Pj;
var gw = (r) => {
  if (r instanceof Uint8Array && r.constructor.name === "Uint8Array") return r;
  if (r instanceof ArrayBuffer) return new Uint8Array(r);
  if (ArrayBuffer.isView(r)) return new Uint8Array(r.buffer, r.byteOffset, r.byteLength);
  throw new Error("Unknown type, must be binary type");
};
var Rj = (r) => new TextEncoder().encode(r);
var $j = (r) => new TextDecoder().decode(r);
var Fj = class {
  constructor(e, t, n) {
    this.name = e, this.prefix = t, this.baseEncode = n;
  }
  encode(e) {
    if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
};
var Qj = class {
  constructor(e, t, n) {
    if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
    this.prefixCodePoint = t.codePointAt(0), this.baseDecode = n;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else throw Error("Can only multibase decode strings");
  }
  or(e) {
    return yw(this, e);
  }
};
var qj = class {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return yw(this, e);
  }
  decode(e) {
    const t = e[0], n = this.decoders[t];
    if (n) return n.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
var yw = (r, e) => new qj({ ...r.decoders || { [r.prefix]: r }, ...e.decoders || { [e.prefix]: e } });
var Yj = class {
  constructor(e, t, n, s) {
    this.name = e, this.prefix = t, this.baseEncode = n, this.baseDecode = s, this.encoder = new Fj(e, t, n), this.decoder = new Qj(e, t, s);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
};
var Za = ({ name: r, prefix: e, encode: t, decode: n }) => new Yj(r, e, t, n);
var Vs = ({ prefix: r, name: e, alphabet: t }) => {
  const { encode: n, decode: s } = Bj(t, e);
  return Za({ prefix: r, name: e, encode: n, decode: (i) => gw(s(i)) });
};
var Vj = (r, e, t, n) => {
  const s = {};
  for (let l = 0; l < e.length; ++l) s[e[l]] = l;
  let i = r.length;
  for (; r[i - 1] === "="; ) --i;
  const o = new Uint8Array(i * t / 8 | 0);
  let a = 0, u = 0, c = 0;
  for (let l = 0; l < i; ++l) {
    const d = s[r[l]];
    if (d === void 0) throw new SyntaxError(`Non-${n} character`);
    u = u << t | d, a += t, a >= 8 && (a -= 8, o[c++] = 255 & u >> a);
  }
  if (a >= t || 255 & u << 8 - a) throw new SyntaxError("Unexpected end of data");
  return o;
};
var Hj = (r, e, t) => {
  const n = e[e.length - 1] === "=", s = (1 << t) - 1;
  let i = "", o = 0, a = 0;
  for (let u = 0; u < r.length; ++u) for (a = a << 8 | r[u], o += 8; o > t; ) o -= t, i += e[s & a >> o];
  if (o && (i += e[s & a << t - o]), n) for (; i.length * t & 7; ) i += "=";
  return i;
};
var Nt = ({ name: r, prefix: e, bitsPerChar: t, alphabet: n }) => Za({ prefix: e, name: r, encode(s) {
  return Hj(s, n, t);
}, decode(s) {
  return Vj(s, n, t, r);
} });
var Gj = Za({ prefix: "\0", name: "identity", encode: (r) => $j(r), decode: (r) => Rj(r) });
var Wj = Object.freeze({ __proto__: null, identity: Gj });
var Kj = Nt({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var Xj = Object.freeze({ __proto__: null, base2: Kj });
var Zj = Nt({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var Jj = Object.freeze({ __proto__: null, base8: Zj });
var eC = Vs({ prefix: "9", name: "base10", alphabet: "0123456789" });
var tC = Object.freeze({ __proto__: null, base10: eC });
var rC = Nt({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 });
var nC = Nt({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var iC = Object.freeze({ __proto__: null, base16: rC, base16upper: nC });
var sC = Nt({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
var oC = Nt({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 });
var aC = Nt({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 });
var cC = Nt({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 });
var uC = Nt({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 });
var lC = Nt({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 });
var dC = Nt({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 });
var hC = Nt({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 });
var fC = Nt({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var pC = Object.freeze({ __proto__: null, base32: sC, base32upper: oC, base32pad: aC, base32padupper: cC, base32hex: uC, base32hexupper: lC, base32hexpad: dC, base32hexpadupper: hC, base32z: fC });
var gC = Vs({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" });
var yC = Vs({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var wC = Object.freeze({ __proto__: null, base36: gC, base36upper: yC });
var mC = Vs({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
var bC = Vs({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var vC = Object.freeze({ __proto__: null, base58btc: mC, base58flickr: bC });
var MC = Nt({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 });
var EC = Nt({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 });
var NC = Nt({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 });
var xC = Nt({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var IC = Object.freeze({ __proto__: null, base64: MC, base64pad: EC, base64url: NC, base64urlpad: xC });
var ww = Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂");
var _C = ww.reduce((r, e, t) => (r[t] = e, r), []);
var DC = ww.reduce((r, e, t) => (r[e.codePointAt(0)] = t, r), []);
function TC(r) {
  return r.reduce((e, t) => (e += _C[t], e), "");
}
function AC(r) {
  const e = [];
  for (const t of r) {
    const n = DC[t.codePointAt(0)];
    if (n === void 0) throw new Error(`Non-base256emoji character: ${t}`);
    e.push(n);
  }
  return new Uint8Array(e);
}
var OC = Za({ prefix: "🚀", name: "base256emoji", encode: TC, decode: AC });
var SC = Object.freeze({ __proto__: null, base256emoji: OC });
var jC = mw;
var Bf = 128;
var CC = -128;
var LC = Math.pow(2, 31);
function mw(r, e, t) {
  e = e || [], t = t || 0;
  for (var n = t; r >= LC; ) e[t++] = r & 255 | Bf, r /= 128;
  for (; r & CC; ) e[t++] = r & 255 | Bf, r >>>= 7;
  return e[t] = r | 0, mw.bytes = t - n + 1, e;
}
var zC = Qu;
var kC = 128;
var Rf = 127;
function Qu(r, n) {
  var t = 0, n = n || 0, s = 0, i = n, o, a = r.length;
  do {
    if (i >= a) throw Qu.bytes = 0, new RangeError("Could not decode varint");
    o = r[i++], t += s < 28 ? (o & Rf) << s : (o & Rf) * Math.pow(2, s), s += 7;
  } while (o >= kC);
  return Qu.bytes = i - n, t;
}
var UC = Math.pow(2, 7);
var PC = Math.pow(2, 14);
var BC = Math.pow(2, 21);
var RC = Math.pow(2, 28);
var $C = Math.pow(2, 35);
var FC = Math.pow(2, 42);
var QC = Math.pow(2, 49);
var qC = Math.pow(2, 56);
var YC = Math.pow(2, 63);
var VC = function(r) {
  return r < UC ? 1 : r < PC ? 2 : r < BC ? 3 : r < RC ? 4 : r < $C ? 5 : r < FC ? 6 : r < QC ? 7 : r < qC ? 8 : r < YC ? 9 : 10;
};
var HC = { encode: jC, decode: zC, encodingLength: VC };
var bw = HC;
var $f = (r, e, t = 0) => (bw.encode(r, e, t), e);
var Ff = (r) => bw.encodingLength(r);
var qu = (r, e) => {
  const t = e.byteLength, n = Ff(r), s = n + Ff(t), i = new Uint8Array(s + t);
  return $f(r, i, 0), $f(t, i, n), i.set(e, s), new GC(r, t, e, i);
};
var GC = class {
  constructor(e, t, n, s) {
    this.code = e, this.size = t, this.digest = n, this.bytes = s;
  }
};
var vw = ({ name: r, code: e, encode: t }) => new WC(r, e, t);
var WC = class {
  constructor(e, t, n) {
    this.name = e, this.code = t, this.encode = n;
  }
  digest(e) {
    if (e instanceof Uint8Array) {
      const t = this.encode(e);
      return t instanceof Uint8Array ? qu(this.code, t) : t.then((n) => qu(this.code, n));
    } else throw Error("Unknown type, must be binary type");
  }
};
var Mw = (r) => async (e) => new Uint8Array(await crypto.subtle.digest(r, e));
var KC = vw({ name: "sha2-256", code: 18, encode: Mw("SHA-256") });
var XC = vw({ name: "sha2-512", code: 19, encode: Mw("SHA-512") });
var ZC = Object.freeze({ __proto__: null, sha256: KC, sha512: XC });
var Ew = 0;
var JC = "identity";
var Nw = gw;
var e5 = (r) => qu(Ew, Nw(r));
var t5 = { code: Ew, name: JC, encode: Nw, digest: e5 };
var r5 = Object.freeze({ __proto__: null, identity: t5 });
new TextEncoder(), new TextDecoder();
var Qf = { ...Wj, ...Xj, ...Jj, ...tC, ...iC, ...pC, ...wC, ...vC, ...IC, ...SC };
({ ...ZC, ...r5 });
function xw(r) {
  return globalThis.Buffer != null ? new Uint8Array(r.buffer, r.byteOffset, r.byteLength) : r;
}
function n5(r = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? xw(globalThis.Buffer.allocUnsafe(r)) : new Uint8Array(r);
}
function Iw(r, e, t, n) {
  return { name: r, prefix: e, encoder: { name: r, prefix: e, encode: t }, decoder: { decode: n } };
}
var qf = Iw("utf8", "u", (r) => "u" + new TextDecoder("utf8").decode(r), (r) => new TextEncoder().encode(r.substring(1)));
var Xc = Iw("ascii", "a", (r) => {
  let e = "a";
  for (let t = 0; t < r.length; t++) e += String.fromCharCode(r[t]);
  return e;
}, (r) => {
  r = r.substring(1);
  const e = n5(r.length);
  for (let t = 0; t < r.length; t++) e[t] = r.charCodeAt(t);
  return e;
});
var i5 = { utf8: qf, "utf-8": qf, hex: Qf.base16, latin1: Xc, ascii: Xc, binary: Xc, ...Qf };
function s5(r, e = "utf8") {
  const t = i5[e];
  if (!t) throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? xw(globalThis.Buffer.from(r, "utf-8")) : t.decoder.decode(`${t.prefix}${r}`);
}
var o5 = Object.defineProperty;
var a5 = (r, e, t) => e in r ? o5(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;
var _r = (r, e, t) => a5(r, typeof e != "symbol" ? e + "" : e, t);
var c5 = class {
  constructor(e, t) {
    this.core = e, this.logger = t, _r(this, "keychain", /* @__PURE__ */ new Map()), _r(this, "name", aj), _r(this, "version", cj), _r(this, "initialized", false), _r(this, "storagePrefix", Lr), _r(this, "init", async () => {
      if (!this.initialized) {
        const n = await this.getKeyChain();
        typeof n < "u" && (this.keychain = n), this.initialized = true;
      }
    }), _r(this, "has", (n) => (this.isInitialized(), this.keychain.has(n))), _r(this, "set", async (n, s) => {
      this.isInitialized(), this.keychain.set(n, s), await this.persist();
    }), _r(this, "get", (n) => {
      this.isInitialized();
      const s = this.keychain.get(n);
      if (typeof s > "u") {
        const { message: i } = ae("NO_MATCHING_KEY", `${this.name}: ${n}`);
        throw new Error(i);
      }
      return s;
    }), _r(this, "del", async (n) => {
      this.isInitialized(), this.keychain.delete(n), await this.persist();
    }), this.core = e, this.logger = tr(t, this.name);
  }
  get context() {
    return Wt(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setKeyChain(e) {
    await this.core.storage.setItem(this.storageKey, Du(e));
  }
  async getKeyChain() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? Tu(e) : void 0;
  }
  async persist() {
    await this.setKeyChain(this.keychain);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ae("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var u5 = Object.defineProperty;
var l5 = (r, e, t) => e in r ? u5(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;
var dt = (r, e, t) => l5(r, typeof e != "symbol" ? e + "" : e, t);
var d5 = class {
  constructor(e, t, n) {
    this.core = e, this.logger = t, dt(this, "name", sj), dt(this, "keychain"), dt(this, "randomSessionIdentifier", Bu()), dt(this, "initialized", false), dt(this, "clientId"), dt(this, "init", async () => {
      this.initialized || (await this.keychain.init(), this.initialized = true);
    }), dt(this, "hasKeys", (s) => (this.isInitialized(), this.keychain.has(s))), dt(this, "getClientId", async () => {
      if (this.isInitialized(), this.clientId) return this.clientId;
      const s = await this.getClientSeed(), i = sh(s), o = Yg(i.publicKey);
      return this.clientId = o, o;
    }), dt(this, "generateKeyPair", () => {
      this.isInitialized();
      const s = yS();
      return this.setPrivateKey(s.publicKey, s.privateKey);
    }), dt(this, "signJWT", async (s) => {
      this.isInitialized();
      const i = await this.getClientSeed(), o = sh(i), a = this.randomSessionIdentifier;
      return await Fx(a, s, oj, o);
    }), dt(this, "generateSharedKey", (s, i, o) => {
      this.isInitialized();
      const a = this.getPrivateKey(s), u = wS(a, i);
      return this.setSymKey(u, o);
    }), dt(this, "setSymKey", async (s, i) => {
      this.isInitialized();
      const o = i || Ao(s);
      return await this.keychain.set(o, s), o;
    }), dt(this, "deleteKeyPair", async (s) => {
      this.isInitialized(), await this.keychain.del(s);
    }), dt(this, "deleteSymKey", async (s) => {
      this.isInitialized(), await this.keychain.del(s);
    }), dt(this, "encode", async (s, i, o) => {
      this.isInitialized();
      const a = tw(o), u = ti(i);
      if (wf(a)) return vS(u, o == null ? void 0 : o.encoding);
      if (yf(a)) {
        const h = a.senderPublicKey, f = a.receiverPublicKey;
        s = await this.generateSharedKey(h, f);
      }
      const c = this.getSymKey(s), { type: l, senderPublicKey: d } = a;
      return mS({ type: l, symKey: c, message: u, senderPublicKey: d, encoding: o == null ? void 0 : o.encoding });
    }), dt(this, "decode", async (s, i, o) => {
      this.isInitialized();
      const a = ES(i, o);
      if (wf(a)) {
        const u = MS(i, o == null ? void 0 : o.encoding);
        return zi(u);
      }
      if (yf(a)) {
        const u = a.receiverPublicKey, c = a.senderPublicKey;
        s = await this.generateSharedKey(u, c);
      }
      try {
        const u = this.getSymKey(s), c = bS({ symKey: u, encoded: i, encoding: o == null ? void 0 : o.encoding });
        return zi(c);
      } catch (u) {
        this.logger.error(`Failed to decode message from topic: '${s}', clientId: '${await this.getClientId()}'`), this.logger.error(u);
      }
    }), dt(this, "getPayloadType", (s, i = qt) => {
      const o = Ss({ encoded: s, encoding: i });
      return si(o.type);
    }), dt(this, "getPayloadSenderPublicKey", (s, i = qt) => {
      const o = Ss({ encoded: s, encoding: i });
      return o.senderPublicKey ? Ht(o.senderPublicKey, kt) : void 0;
    }), this.core = e, this.logger = tr(t, this.name), this.keychain = n || new c5(this.core, this.logger);
  }
  get context() {
    return Wt(this.logger);
  }
  async setPrivateKey(e, t) {
    return await this.keychain.set(e, t), e;
  }
  getPrivateKey(e) {
    return this.keychain.get(e);
  }
  async getClientSeed() {
    let e = "";
    try {
      e = this.keychain.get(Uf);
    } catch {
      e = Bu(), await this.keychain.set(Uf, e);
    }
    return s5(e, "base16");
  }
  getSymKey(e) {
    return this.keychain.get(e);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ae("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var h5 = Object.defineProperty;
var f5 = Object.defineProperties;
var p5 = Object.getOwnPropertyDescriptors;
var Yf = Object.getOwnPropertySymbols;
var g5 = Object.prototype.hasOwnProperty;
var y5 = Object.prototype.propertyIsEnumerable;
var Yu = (r, e, t) => e in r ? h5(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;
var w5 = (r, e) => {
  for (var t in e || (e = {})) g5.call(e, t) && Yu(r, t, e[t]);
  if (Yf) for (var t of Yf(e)) y5.call(e, t) && Yu(r, t, e[t]);
  return r;
};
var m5 = (r, e) => f5(r, p5(e));
var Kt = (r, e, t) => Yu(r, typeof e != "symbol" ? e + "" : e, t);
var b5 = class extends RE {
  constructor(e, t) {
    super(e, t), this.logger = e, this.core = t, Kt(this, "messages", /* @__PURE__ */ new Map()), Kt(this, "messagesWithoutClientAck", /* @__PURE__ */ new Map()), Kt(this, "name", uj), Kt(this, "version", lj), Kt(this, "initialized", false), Kt(this, "storagePrefix", Lr), Kt(this, "init", async () => {
      if (!this.initialized) {
        this.logger.trace("Initialized");
        try {
          const n = await this.getRelayerMessages();
          typeof n < "u" && (this.messages = n);
          const s = await this.getRelayerMessagesWithoutClientAck();
          typeof s < "u" && (this.messagesWithoutClientAck = s), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
        } catch (n) {
          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(n);
        } finally {
          this.initialized = true;
        }
      }
    }), Kt(this, "set", async (n, s, i) => {
      this.isInitialized();
      const o = ur(s);
      let a = this.messages.get(n);
      if (typeof a > "u" && (a = {}), typeof a[o] < "u") return o;
      if (a[o] = s, this.messages.set(n, a), i === Oo.inbound) {
        const u = this.messagesWithoutClientAck.get(n) || {};
        this.messagesWithoutClientAck.set(n, m5(w5({}, u), { [o]: s }));
      }
      return await this.persist(), o;
    }), Kt(this, "get", (n) => {
      this.isInitialized();
      let s = this.messages.get(n);
      return typeof s > "u" && (s = {}), s;
    }), Kt(this, "getWithoutAck", (n) => {
      this.isInitialized();
      const s = {};
      for (const i of n) {
        const o = this.messagesWithoutClientAck.get(i) || {};
        s[i] = Object.values(o);
      }
      return s;
    }), Kt(this, "has", (n, s) => {
      this.isInitialized();
      const i = this.get(n), o = ur(s);
      return typeof i[o] < "u";
    }), Kt(this, "ack", async (n, s) => {
      this.isInitialized();
      const i = this.messagesWithoutClientAck.get(n);
      if (typeof i > "u") return;
      const o = ur(s);
      delete i[o], Object.keys(i).length === 0 ? this.messagesWithoutClientAck.delete(n) : this.messagesWithoutClientAck.set(n, i), await this.persist();
    }), Kt(this, "del", async (n) => {
      this.isInitialized(), this.messages.delete(n), this.messagesWithoutClientAck.delete(n), await this.persist();
    }), this.logger = tr(e, this.name), this.core = t;
  }
  get context() {
    return Wt(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get storageKeyWithoutClientAck() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name + "_withoutClientAck";
  }
  async setRelayerMessages(e) {
    await this.core.storage.setItem(this.storageKey, Du(e));
  }
  async setRelayerMessagesWithoutClientAck(e) {
    await this.core.storage.setItem(this.storageKeyWithoutClientAck, Du(e));
  }
  async getRelayerMessages() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? Tu(e) : void 0;
  }
  async getRelayerMessagesWithoutClientAck() {
    const e = await this.core.storage.getItem(this.storageKeyWithoutClientAck);
    return typeof e < "u" ? Tu(e) : void 0;
  }
  async persist() {
    await this.setRelayerMessages(this.messages), await this.setRelayerMessagesWithoutClientAck(this.messagesWithoutClientAck);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ae("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var v5 = Object.defineProperty;
var M5 = Object.defineProperties;
var E5 = Object.getOwnPropertyDescriptors;
var Vf = Object.getOwnPropertySymbols;
var N5 = Object.prototype.hasOwnProperty;
var x5 = Object.prototype.propertyIsEnumerable;
var Vu = (r, e, t) => e in r ? v5(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;
var Mi = (r, e) => {
  for (var t in e || (e = {})) N5.call(e, t) && Vu(r, t, e[t]);
  if (Vf) for (var t of Vf(e)) x5.call(e, t) && Vu(r, t, e[t]);
  return r;
};
var Hf = (r, e) => M5(r, E5(e));
var sr = (r, e, t) => Vu(r, typeof e != "symbol" ? e + "" : e, t);
var I5 = class extends $E {
  constructor(e, t) {
    super(e, t), this.relayer = e, this.logger = t, sr(this, "events", new Gt.EventEmitter()), sr(this, "name", hj), sr(this, "queue", /* @__PURE__ */ new Map()), sr(this, "publishTimeout", ce.toMiliseconds(ce.ONE_MINUTE)), sr(this, "initialPublishTimeout", ce.toMiliseconds(ce.ONE_SECOND * 15)), sr(this, "needsTransportRestart", false), sr(this, "publish", async (n, s, i) => {
      var o, a, u, c, l;
      this.logger.debug("Publishing Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: n, message: s, opts: i } });
      const d = (i == null ? void 0 : i.ttl) || dj, h = (i == null ? void 0 : i.prompt) || false, f = (i == null ? void 0 : i.tag) || 0, g = (i == null ? void 0 : i.id) || _n().toString(), p = Di(Zo().protocol), b = { id: g, method: (i == null ? void 0 : i.publishMethod) || p.publish, params: Mi({ topic: n, message: s, ttl: d, prompt: h, tag: f, attestation: i == null ? void 0 : i.attestation }, i == null ? void 0 : i.tvf) }, _ = `Failed to publish payload, please try again. id:${g} tag:${f}`;
      try {
        ut((o = b.params) == null ? void 0 : o.prompt) && ((a = b.params) == null || delete a.prompt), ut((u = b.params) == null ? void 0 : u.tag) && ((c = b.params) == null || delete c.tag);
        const D = new Promise(async (v) => {
          const E = ({ id: k }) => {
            var U;
            ((U = b.id) == null ? void 0 : U.toString()) === k.toString() && (this.removeRequestFromQueue(k), this.relayer.events.removeListener(tt.publish, E), v());
          };
          this.relayer.events.on(tt.publish, E);
          const A = Cr(new Promise((k, U) => {
            this.rpcPublish(b, i).then(k).catch((P) => {
              this.logger.warn(P, P == null ? void 0 : P.message), U(P);
            });
          }), this.initialPublishTimeout, `Failed initial publish, retrying.... id:${g} tag:${f}`);
          try {
            await A, this.events.removeListener(tt.publish, E);
          } catch (k) {
            this.queue.set(g, { request: b, opts: i, attempt: 1 }), this.logger.warn(k, k == null ? void 0 : k.message);
          }
        });
        this.logger.trace({ type: "method", method: "publish", params: { id: g, topic: n, message: s, opts: i } }), await Cr(D, this.publishTimeout, _);
      } catch (D) {
        if (this.logger.debug("Failed to Publish Payload"), this.logger.error(D), (l = i == null ? void 0 : i.internal) != null && l.throwOnFailedPublish) throw D;
      } finally {
        this.queue.delete(g);
      }
    }), sr(this, "publishCustom", async (n) => {
      var s, i, o, a, u;
      this.logger.debug("Publishing custom payload"), this.logger.trace({ type: "method", method: "publishCustom", params: n });
      const { payload: c, opts: l = {} } = n, { attestation: d, tvf: h, publishMethod: f, prompt: g, tag: p, ttl: b = ce.FIVE_MINUTES } = l, _ = l.id || _n().toString(), D = Di(Zo().protocol), v = f || D.publish, E = { id: _, method: v, params: Mi(Hf(Mi({}, c), { ttl: b, prompt: g, tag: p, attestation: d }), h) }, A = `Failed to publish custom payload, please try again. id:${_} tag:${p}`;
      try {
        ut((s = E.params) == null ? void 0 : s.prompt) && ((i = E.params) == null || delete i.prompt), ut((o = E.params) == null ? void 0 : o.tag) && ((a = E.params) == null || delete a.tag);
        const k = new Promise(async (U) => {
          const P = ({ id: ee }) => {
            var G;
            ((G = E.id) == null ? void 0 : G.toString()) === ee.toString() && (this.removeRequestFromQueue(ee), this.relayer.events.removeListener(tt.publish, P), U());
          };
          this.relayer.events.on(tt.publish, P);
          const $ = Cr(new Promise((ee, G) => {
            this.rpcPublish(E, l).then(ee).catch((H) => {
              this.logger.warn(H, H == null ? void 0 : H.message), G(H);
            });
          }), this.initialPublishTimeout, `Failed initial custom payload publish, retrying.... method:${v} id:${_} tag:${p}`);
          try {
            await $, this.events.removeListener(tt.publish, P);
          } catch (ee) {
            this.queue.set(_, { request: E, opts: l, attempt: 1 }), this.logger.warn(ee, ee == null ? void 0 : ee.message);
          }
        });
        this.logger.trace({ type: "method", method: "publish", params: { id: _, payload: c, opts: l } }), await Cr(k, this.publishTimeout, A);
      } catch (k) {
        if (this.logger.debug("Failed to Publish Payload"), this.logger.error(k), (u = l == null ? void 0 : l.internal) != null && u.throwOnFailedPublish) throw k;
      } finally {
        this.queue.delete(_);
      }
    }), sr(this, "on", (n, s) => {
      this.events.on(n, s);
    }), sr(this, "once", (n, s) => {
      this.events.once(n, s);
    }), sr(this, "off", (n, s) => {
      this.events.off(n, s);
    }), sr(this, "removeListener", (n, s) => {
      this.events.removeListener(n, s);
    }), this.relayer = e, this.logger = tr(t, this.name), this.registerEventListeners();
  }
  get context() {
    return Wt(this.logger);
  }
  async rpcPublish(e, t) {
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "message", direction: "outgoing", request: e });
    const n = await this.relayer.request(e);
    return this.relayer.events.emit(tt.publish, Mi(Mi({}, e), t)), this.logger.debug("Successfully Published Payload"), n;
  }
  removeRequestFromQueue(e) {
    this.queue.delete(e);
  }
  checkQueue() {
    this.queue.forEach(async (e, t) => {
      var n;
      const s = e.attempt + 1;
      this.queue.set(t, Hf(Mi({}, e), { attempt: s })), this.logger.warn({}, `Publisher: queue->publishing: ${e.request.id}, tag: ${(n = e.request.params) == null ? void 0 : n.tag}, attempt: ${s}`), await this.rpcPublish(e.request, e.opts), this.logger.warn({}, `Publisher: queue->published: ${e.request.id}`);
    });
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(ui.pulse, () => {
      if (this.needsTransportRestart) {
        this.needsTransportRestart = false, this.relayer.events.emit(tt.connection_stalled);
        return;
      }
      this.checkQueue();
    }), this.relayer.on(tt.message_ack, (e) => {
      this.removeRequestFromQueue(e.id.toString());
    });
  }
};
var _5 = Object.defineProperty;
var D5 = (r, e, t) => e in r ? _5(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;
var Ei = (r, e, t) => D5(r, typeof e != "symbol" ? e + "" : e, t);
var T5 = class {
  constructor() {
    Ei(this, "map", /* @__PURE__ */ new Map()), Ei(this, "set", (e, t) => {
      const n = this.get(e);
      this.exists(e, t) || this.map.set(e, [...n, t]);
    }), Ei(this, "get", (e) => this.map.get(e) || []), Ei(this, "exists", (e, t) => this.get(e).includes(t)), Ei(this, "delete", (e, t) => {
      if (typeof t > "u") {
        this.map.delete(e);
        return;
      }
      if (!this.map.has(e)) return;
      const n = this.get(e);
      if (!this.exists(e, t)) return;
      const s = n.filter((i) => i !== t);
      if (!s.length) {
        this.map.delete(e);
        return;
      }
      this.map.set(e, s);
    }), Ei(this, "clear", () => {
      this.map.clear();
    });
  }
  get topics() {
    return Array.from(this.map.keys());
  }
};
var A5 = Object.defineProperty;
var O5 = Object.defineProperties;
var S5 = Object.getOwnPropertyDescriptors;
var Gf = Object.getOwnPropertySymbols;
var j5 = Object.prototype.hasOwnProperty;
var C5 = Object.prototype.propertyIsEnumerable;
var Hu = (r, e, t) => e in r ? A5(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;
var ds = (r, e) => {
  for (var t in e || (e = {})) j5.call(e, t) && Hu(r, t, e[t]);
  if (Gf) for (var t of Gf(e)) C5.call(e, t) && Hu(r, t, e[t]);
  return r;
};
var Zc = (r, e) => O5(r, S5(e));
var $e = (r, e, t) => Hu(r, typeof e != "symbol" ? e + "" : e, t);
var L5 = class extends qE {
  constructor(e, t) {
    super(e, t), this.relayer = e, this.logger = t, $e(this, "subscriptions", /* @__PURE__ */ new Map()), $e(this, "topicMap", new T5()), $e(this, "events", new Gt.EventEmitter()), $e(this, "name", bj), $e(this, "version", vj), $e(this, "pending", /* @__PURE__ */ new Map()), $e(this, "cached", []), $e(this, "initialized", false), $e(this, "storagePrefix", Lr), $e(this, "subscribeTimeout", ce.toMiliseconds(ce.ONE_MINUTE)), $e(this, "initialSubscribeTimeout", ce.toMiliseconds(ce.ONE_SECOND * 15)), $e(this, "clientId"), $e(this, "batchSubscribeTopicsLimit", 500), $e(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), await this.restore()), this.initialized = true;
    }), $e(this, "subscribe", async (n, s) => {
      var i;
      this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: n, opts: s } });
      try {
        const o = Zo(s), a = { topic: n, relay: o, transportType: s == null ? void 0 : s.transportType };
        (i = s == null ? void 0 : s.internal) != null && i.skipSubscribe || this.pending.set(n, a);
        const u = await this.rpcSubscribe(n, o, s);
        return typeof u == "string" && (this.onSubscribe(u, a), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: n, opts: s } })), u;
      } catch (o) {
        throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(o), o;
      }
    }), $e(this, "unsubscribe", async (n, s) => {
      this.isInitialized(), typeof (s == null ? void 0 : s.id) < "u" ? await this.unsubscribeById(n, s.id, s) : await this.unsubscribeByTopic(n, s);
    }), $e(this, "isSubscribed", (n) => new Promise((s) => {
      s(this.topicMap.topics.includes(n));
    })), $e(this, "isKnownTopic", (n) => new Promise((s) => {
      s(this.topicMap.topics.includes(n) || this.pending.has(n) || this.cached.some((i) => i.topic === n));
    })), $e(this, "on", (n, s) => {
      this.events.on(n, s);
    }), $e(this, "once", (n, s) => {
      this.events.once(n, s);
    }), $e(this, "off", (n, s) => {
      this.events.off(n, s);
    }), $e(this, "removeListener", (n, s) => {
      this.events.removeListener(n, s);
    }), $e(this, "start", async () => {
      await this.onConnect();
    }), $e(this, "stop", async () => {
      await this.onDisconnect();
    }), $e(this, "restart", async () => {
      await this.restore(), await this.onRestart();
    }), $e(this, "checkPending", async () => {
      if (this.pending.size === 0 && (!this.initialized || !this.relayer.connected)) return;
      const n = [];
      this.pending.forEach((s) => {
        n.push(s);
      }), await this.batchSubscribe(n);
    }), $e(this, "registerEventListeners", () => {
      this.relayer.core.heartbeat.on(ui.pulse, async () => {
        await this.checkPending();
      }), this.events.on(Xt.created, async (n) => {
        const s = Xt.created;
        this.logger.info(`Emitting ${s}`), this.logger.debug({ type: "event", event: s, data: n }), await this.persist();
      }), this.events.on(Xt.deleted, async (n) => {
        const s = Xt.deleted;
        this.logger.info(`Emitting ${s}`), this.logger.debug({ type: "event", event: s, data: n }), await this.persist();
      });
    }), this.relayer = e, this.logger = tr(t, this.name), this.clientId = "";
  }
  get context() {
    return Wt(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.subscriptions.size;
  }
  get ids() {
    return Array.from(this.subscriptions.keys());
  }
  get values() {
    return Array.from(this.subscriptions.values());
  }
  get topics() {
    return this.topicMap.topics;
  }
  get hasAnyTopics() {
    return this.topicMap.topics.length > 0 || this.pending.size > 0 || this.cached.length > 0 || this.subscriptions.size > 0;
  }
  hasSubscription(e, t) {
    let n = false;
    try {
      n = this.getSubscription(e).topic === t;
    } catch {
    }
    return n;
  }
  reset() {
    this.cached = [], this.initialized = true;
  }
  onDisable() {
    this.values.length > 0 && (this.cached = this.values), this.subscriptions.clear(), this.topicMap.clear();
  }
  async unsubscribeByTopic(e, t) {
    const n = this.topicMap.get(e);
    await Promise.all(n.map(async (s) => await this.unsubscribeById(e, s, t)));
  }
  async unsubscribeById(e, t, n) {
    this.logger.debug("Unsubscribing Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: t, opts: n } });
    try {
      const s = Zo(n);
      await this.restartToComplete({ topic: e, id: t, relay: s }), await this.rpcUnsubscribe(e, t, s);
      const i = Je("USER_DISCONNECTED", `${this.name}, ${e}`);
      await this.onUnsubscribe(e, t, i), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: t, opts: n } });
    } catch (s) {
      throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(s), s;
    }
  }
  async rpcSubscribe(e, t, n) {
    var s, i;
    const o = await this.getSubscriptionId(e);
    if ((s = n == null ? void 0 : n.internal) != null && s.skipSubscribe) return o;
    (!n || (n == null ? void 0 : n.transportType) === Ye.relay) && await this.restartToComplete({ topic: e, id: e, relay: t });
    const a = { method: Di(t.protocol).subscribe, params: { topic: e } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: a });
    const u = (i = n == null ? void 0 : n.internal) == null ? void 0 : i.throwOnFailedPublish;
    try {
      if ((n == null ? void 0 : n.transportType) === Ye.link_mode) return setTimeout(() => {
        (this.relayer.connected || this.relayer.connecting) && this.relayer.request(a).catch((d) => this.logger.warn(d));
      }, ce.toMiliseconds(ce.ONE_SECOND)), o;
      const c = new Promise(async (d) => {
        const h = (f) => {
          f.topic === e && (this.events.removeListener(Xt.created, h), d(f.id));
        };
        this.events.on(Xt.created, h);
        try {
          const f = await Cr(new Promise((g, p) => {
            this.relayer.request(a).catch((b) => {
              this.logger.warn(b, b == null ? void 0 : b.message), p(b);
            }).then(g);
          }), this.initialSubscribeTimeout, `Subscribing to ${e} failed, please try again`);
          this.events.removeListener(Xt.created, h), d(f);
        } catch {
        }
      }), l = await Cr(c, this.subscribeTimeout, `Subscribing to ${e} failed, please try again`);
      if (!l && u) throw new Error(`Subscribing to ${e} failed, please try again`);
      return l ? o : null;
    } catch (c) {
      if (this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(tt.connection_stalled), u) throw c;
    }
    return null;
  }
  async rpcBatchSubscribe(e) {
    if (!e.length) return;
    const t = e[0].relay, n = { method: Di(t.protocol).batchSubscribe, params: { topics: e.map((s) => s.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: n });
    try {
      await await Cr(new Promise((s) => {
        this.relayer.request(n).catch((i) => this.logger.warn(i)).then(s);
      }), this.subscribeTimeout, "rpcBatchSubscribe failed, please try again");
    } catch {
      this.relayer.events.emit(tt.connection_stalled);
    }
  }
  async rpcBatchFetchMessages(e) {
    if (!e.length) return;
    const t = e[0].relay, n = { method: Di(t.protocol).batchFetchMessages, params: { topics: e.map((i) => i.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: n });
    let s;
    try {
      s = await await Cr(new Promise((i, o) => {
        this.relayer.request(n).catch((a) => {
          this.logger.warn(a), o(a);
        }).then(i);
      }), this.subscribeTimeout, "rpcBatchFetchMessages failed, please try again");
    } catch {
      this.relayer.events.emit(tt.connection_stalled);
    }
    return s;
  }
  rpcUnsubscribe(e, t, n) {
    const s = { method: Di(n.protocol).unsubscribe, params: { topic: e, id: t } };
    return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s }), this.relayer.request(s);
  }
  onSubscribe(e, t) {
    this.setSubscription(e, Zc(ds({}, t), { id: e })), this.pending.delete(t.topic);
  }
  onBatchSubscribe(e) {
    e.length && e.forEach((t) => {
      this.setSubscription(t.id, ds({}, t)), this.pending.delete(t.topic);
    });
  }
  async onUnsubscribe(e, t, n) {
    this.events.removeAllListeners(t), this.hasSubscription(t, e) && this.deleteSubscription(t, n), await this.relayer.messages.del(e);
  }
  async setRelayerSubscriptions(e) {
    await this.relayer.core.storage.setItem(this.storageKey, e);
  }
  async getRelayerSubscriptions() {
    return await this.relayer.core.storage.getItem(this.storageKey);
  }
  setSubscription(e, t) {
    this.logger.debug("Setting subscription"), this.logger.trace({ type: "method", method: "setSubscription", id: e, subscription: t }), this.addSubscription(e, t);
  }
  addSubscription(e, t) {
    this.subscriptions.set(e, ds({}, t)), this.topicMap.set(t.topic, e), this.events.emit(Xt.created, t);
  }
  getSubscription(e) {
    this.logger.debug("Getting subscription"), this.logger.trace({ type: "method", method: "getSubscription", id: e });
    const t = this.subscriptions.get(e);
    if (!t) {
      const { message: n } = ae("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(n);
    }
    return t;
  }
  deleteSubscription(e, t) {
    this.logger.debug("Deleting subscription"), this.logger.trace({ type: "method", method: "deleteSubscription", id: e, reason: t });
    const n = this.getSubscription(e);
    this.subscriptions.delete(e), this.topicMap.delete(n.topic, e), this.events.emit(Xt.deleted, Zc(ds({}, n), { reason: t }));
  }
  async persist() {
    await this.setRelayerSubscriptions(this.values), this.events.emit(Xt.sync);
  }
  async onRestart() {
    if (this.cached.length) {
      const e = [...this.cached], t = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
      for (let n = 0; n < t; n++) {
        const s = e.splice(0, this.batchSubscribeTopicsLimit);
        await this.batchSubscribe(s);
      }
    }
    this.events.emit(Xt.resubscribed);
  }
  async restore() {
    try {
      const e = await this.getRelayerSubscriptions();
      if (typeof e > "u" || !e.length) return;
      if (this.subscriptions.size && !e.every((t) => {
        var n;
        return t.topic === ((n = this.subscriptions.get(t.id)) == null ? void 0 : n.topic);
      })) {
        const { message: t } = ae("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e);
    }
  }
  async batchSubscribe(e) {
    e.length && (await this.rpcBatchSubscribe(e), this.onBatchSubscribe(await Promise.all(e.map(async (t) => Zc(ds({}, t), { id: await this.getSubscriptionId(t.topic) })))));
  }
  async batchFetchMessages(e) {
    if (!e.length) return;
    this.logger.trace(`Fetching batch messages for ${e.length} subscriptions`);
    const t = await this.rpcBatchFetchMessages(e);
    t && t.messages && (await PA(ce.toMiliseconds(ce.ONE_SECOND)), await this.relayer.handleBatchMessageEvents(t.messages));
  }
  async onConnect() {
    await this.restart(), this.reset();
  }
  onDisconnect() {
    this.onDisable();
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ae("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async restartToComplete(e) {
    !this.relayer.connected && !this.relayer.connecting && (this.cached.push(e), await this.relayer.transportOpen());
  }
  async getClientId() {
    return this.clientId || (this.clientId = await this.relayer.core.crypto.getClientId()), this.clientId;
  }
  async getSubscriptionId(e) {
    return ur(e + await this.getClientId());
  }
};
var z5 = Object.defineProperty;
var Wf = Object.getOwnPropertySymbols;
var k5 = Object.prototype.hasOwnProperty;
var U5 = Object.prototype.propertyIsEnumerable;
var Gu = (r, e, t) => e in r ? z5(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;
var Kf = (r, e) => {
  for (var t in e || (e = {})) k5.call(e, t) && Gu(r, t, e[t]);
  if (Wf) for (var t of Wf(e)) U5.call(e, t) && Gu(r, t, e[t]);
  return r;
};
var Se = (r, e, t) => Gu(r, typeof e != "symbol" ? e + "" : e, t);
var P5 = class extends FE {
  constructor(e) {
    var t;
    super(e), Se(this, "protocol", "wc"), Se(this, "version", 2), Se(this, "core"), Se(this, "logger"), Se(this, "events", new Gt.EventEmitter()), Se(this, "provider"), Se(this, "messages"), Se(this, "subscriber"), Se(this, "publisher"), Se(this, "name", pj), Se(this, "transportExplicitlyClosed", false), Se(this, "initialized", false), Se(this, "connectionAttemptInProgress", false), Se(this, "relayUrl"), Se(this, "projectId"), Se(this, "packageName"), Se(this, "bundleId"), Se(this, "hasExperiencedNetworkDisruption", false), Se(this, "pingTimeout"), Se(this, "heartBeatTimeout", ce.toMiliseconds(ce.THIRTY_SECONDS + ce.FIVE_SECONDS)), Se(this, "reconnectTimeout"), Se(this, "connectPromise"), Se(this, "reconnectInProgress", false), Se(this, "requestsInFlight", []), Se(this, "connectTimeout", ce.toMiliseconds(ce.ONE_SECOND * 15)), Se(this, "request", async (n) => {
      var s, i;
      this.logger.debug("Publishing Request Payload");
      const o = n.id || _n().toString();
      await this.toEstablishConnection();
      try {
        this.logger.trace({ id: o, method: n.method, topic: (s = n.params) == null ? void 0 : s.topic }, "relayer.request - publishing...");
        const a = `${o}:${((i = n.params) == null ? void 0 : i.tag) || ""}`;
        this.requestsInFlight.push(a);
        const u = await this.provider.request(n);
        return this.requestsInFlight = this.requestsInFlight.filter((c) => c !== a), u;
      } catch (a) {
        throw this.logger.debug(`Failed to Publish Request: ${o}`), a;
      }
    }), Se(this, "resetPingTimeout", () => {
      Vo() && (clearTimeout(this.pingTimeout), this.pingTimeout = setTimeout(() => {
        var n, s, i, o;
        try {
          this.logger.debug({}, "pingTimeout: Connection stalled, terminating..."), (o = (i = (s = (n = this.provider) == null ? void 0 : n.connection) == null ? void 0 : s.socket) == null ? void 0 : i.terminate) == null || o.call(i);
        } catch (a) {
          this.logger.warn(a, a == null ? void 0 : a.message);
        }
      }, this.heartBeatTimeout));
    }), Se(this, "onPayloadHandler", (n) => {
      this.onProviderPayload(n), this.resetPingTimeout();
    }), Se(this, "onConnectHandler", () => {
      this.logger.warn({}, "Relayer connected 🛜"), this.startPingTimeout(), this.events.emit(tt.connect);
    }), Se(this, "onDisconnectHandler", () => {
      this.logger.warn({}, "Relayer disconnected 🛑"), this.requestsInFlight = [], this.onProviderDisconnect();
    }), Se(this, "onProviderErrorHandler", (n) => {
      this.logger.fatal(`Fatal socket error: ${n.message}`), this.events.emit(tt.error, n), this.logger.fatal("Fatal socket error received, closing transport"), this.transportClose();
    }), Se(this, "registerProviderListeners", () => {
      this.provider.on(ir.payload, this.onPayloadHandler), this.provider.on(ir.connect, this.onConnectHandler), this.provider.on(ir.disconnect, this.onDisconnectHandler), this.provider.on(ir.error, this.onProviderErrorHandler);
    }), this.core = e.core, this.logger = sw({ logger: (t = e.logger) != null ? t : fj, name: this.name }), this.messages = new b5(this.logger, e.core), this.subscriber = new L5(this, this.logger), this.publisher = new I5(this, this.logger), this.projectId = e == null ? void 0 : e.projectId, this.relayUrl = (e == null ? void 0 : e.relayUrl) || fw, EA() ? this.packageName = Uh() : NA() && (this.bundleId = Uh()), this.provider = {};
  }
  async init() {
    this.logger.trace("Initialized"), this.registerEventListeners(), await Promise.all([this.messages.init(), this.subscriber.init()]), this.initialized = true, this.transportOpen().catch((e) => this.logger.warn(e, e == null ? void 0 : e.message));
  }
  get context() {
    return Wt(this.logger);
  }
  get connected() {
    var e, t, n;
    return ((n = (t = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : t.socket) == null ? void 0 : n.readyState) === 1 || false;
  }
  get connecting() {
    var e, t, n;
    return ((n = (t = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : t.socket) == null ? void 0 : n.readyState) === 0 || this.connectPromise !== void 0 || false;
  }
  async publish(e, t, n) {
    this.isInitialized(), await this.publisher.publish(e, t, n), await this.recordMessageEvent({ topic: e, message: t, publishedAt: Date.now(), transportType: Ye.relay }, Oo.outbound);
  }
  async publishCustom(e) {
    this.isInitialized(), await this.publisher.publishCustom(e);
  }
  async subscribe(e, t) {
    var n, s, i;
    this.isInitialized(), (!(t != null && t.transportType) || (t == null ? void 0 : t.transportType) === "relay") && await this.toEstablishConnection();
    const o = typeof ((n = t == null ? void 0 : t.internal) == null ? void 0 : n.throwOnFailedPublish) > "u" ? true : (s = t == null ? void 0 : t.internal) == null ? void 0 : s.throwOnFailedPublish;
    let a = ((i = this.subscriber.topicMap.get(e)) == null ? void 0 : i[0]) || "", u;
    const c = (l) => {
      l.topic === e && (this.subscriber.off(Xt.created, c), u());
    };
    return await Promise.all([new Promise((l) => {
      u = l, this.subscriber.on(Xt.created, c);
    }), new Promise(async (l, d) => {
      a = await this.subscriber.subscribe(e, Kf({ internal: { throwOnFailedPublish: o } }, t)).catch((h) => {
        o && d(h);
      }) || a, l();
    })]), a;
  }
  async unsubscribe(e, t) {
    this.isInitialized(), await this.subscriber.unsubscribe(e, t);
  }
  on(e, t) {
    this.events.on(e, t);
  }
  once(e, t) {
    this.events.once(e, t);
  }
  off(e, t) {
    this.events.off(e, t);
  }
  removeListener(e, t) {
    this.events.removeListener(e, t);
  }
  async transportDisconnect() {
    this.provider.disconnect && (this.hasExperiencedNetworkDisruption || this.connected) ? await Cr(this.provider.disconnect(), 2e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.onProviderDisconnect();
  }
  async transportClose() {
    this.transportExplicitlyClosed = true, await this.transportDisconnect();
  }
  async transportOpen(e) {
    if (!this.subscriber.hasAnyTopics) {
      this.logger.info("Starting WS connection skipped because the client has no topics to work with.");
      return;
    }
    if (this.connectPromise ? (this.logger.debug({}, "Waiting for existing connection attempt to resolve..."), await this.connectPromise, this.logger.debug({}, "Existing connection attempt resolved")) : (this.connectPromise = new Promise(async (t, n) => {
      await this.connect(e).then(t).catch(n).finally(() => {
        this.connectPromise = void 0;
      });
    }), await this.connectPromise), !this.connected) throw new Error(`Couldn't establish socket connection to the relay server: ${this.relayUrl}`);
  }
  async restartTransport(e) {
    this.logger.debug({}, "Restarting transport..."), !this.connectionAttemptInProgress && (this.relayUrl = e || this.relayUrl, await this.confirmOnlineStateOrThrow(), await this.transportClose(), await this.transportOpen());
  }
  async confirmOnlineStateOrThrow() {
    if (!await Of()) throw new Error("No internet connection detected. Please restart your network and try again.");
  }
  async handleBatchMessageEvents(e) {
    if ((e == null ? void 0 : e.length) === 0) {
      this.logger.trace("Batch message events is empty. Ignoring...");
      return;
    }
    const t = e.sort((n, s) => n.publishedAt - s.publishedAt);
    this.logger.debug(`Batch of ${t.length} message events sorted`);
    for (const n of t) try {
      await this.onMessageEvent(n);
    } catch (s) {
      this.logger.warn(s, "Error while processing batch message event: " + (s == null ? void 0 : s.message));
    }
    this.logger.trace(`Batch of ${t.length} message events processed`);
  }
  async onLinkMessageEvent(e, t) {
    const { topic: n } = e;
    if (!t.sessionExists) {
      const s = ot(ce.FIVE_MINUTES), i = { topic: n, expiry: s, relay: { protocol: "irn" }, active: false };
      await this.core.pairing.pairings.set(n, i);
    }
    this.events.emit(tt.message, e), await this.recordMessageEvent(e, Oo.inbound);
  }
  async connect(e) {
    await this.confirmOnlineStateOrThrow(), e && e !== this.relayUrl && (this.relayUrl = e, await this.transportDisconnect()), this.connectionAttemptInProgress = true, this.transportExplicitlyClosed = false;
    let t = 1;
    for (; t < 6; ) {
      try {
        if (this.transportExplicitlyClosed) break;
        this.logger.debug({}, `Connecting to ${this.relayUrl}, attempt: ${t}...`), await this.createProvider(), await new Promise(async (n, s) => {
          const i = () => {
            s(new Error("Connection interrupted while trying to connect"));
          };
          this.provider.once(ir.disconnect, i), await Cr(new Promise((o, a) => {
            this.provider.connect().then(o).catch(a);
          }), this.connectTimeout, `Socket stalled when trying to connect to ${this.relayUrl}`).catch((o) => {
            s(o);
          }).finally(() => {
            this.provider.off(ir.disconnect, i), clearTimeout(this.reconnectTimeout);
          }), await new Promise(async (o, a) => {
            const u = () => {
              s(new Error("Connection interrupted while trying to subscribe"));
            };
            this.provider.once(ir.disconnect, u), await this.subscriber.start().then(o).catch(a).finally(() => {
              this.provider.off(ir.disconnect, u);
            });
          }), this.hasExperiencedNetworkDisruption = false, n();
        });
      } catch (n) {
        await this.subscriber.stop();
        const s = n;
        this.logger.warn({}, s.message), this.hasExperiencedNetworkDisruption = true;
      } finally {
        this.connectionAttemptInProgress = false;
      }
      if (this.connected) {
        this.logger.debug({}, `Connected to ${this.relayUrl} successfully on attempt: ${t}`);
        break;
      }
      await new Promise((n) => setTimeout(n, ce.toMiliseconds(t * 1))), t++;
    }
  }
  startPingTimeout() {
    var e, t, n, s, i;
    if (Vo()) try {
      (t = (e = this.provider) == null ? void 0 : e.connection) != null && t.socket && ((i = (s = (n = this.provider) == null ? void 0 : n.connection) == null ? void 0 : s.socket) == null || i.on("ping", () => {
        this.resetPingTimeout();
      })), this.resetPingTimeout();
    } catch (o) {
      this.logger.warn(o, o == null ? void 0 : o.message);
    }
  }
  async createProvider() {
    this.provider.connection && this.unregisterProviderListeners();
    const e = await this.core.crypto.signJWT(this.relayUrl);
    this.provider = new Z3(new rj(TA({ sdkVersion: Fu, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: e, useOnCloseEvent: true, bundleId: this.bundleId, packageName: this.packageName }))), this.registerProviderListeners();
  }
  async recordMessageEvent(e, t) {
    const { topic: n, message: s } = e;
    await this.messages.set(n, s, t);
  }
  async shouldIgnoreMessageEvent(e) {
    const { topic: t, message: n } = e;
    if (!n || n.length === 0) return this.logger.warn(`Ignoring invalid/empty message: ${n}`), true;
    if (!await this.subscriber.isKnownTopic(t)) return this.logger.warn(`Ignoring message for unknown topic ${t}`), true;
    const s = this.messages.has(t, n);
    return s && this.logger.warn(`Ignoring duplicate message: ${n}`), s;
  }
  async onProviderPayload(e) {
    if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({ type: "payload", direction: "incoming", payload: e }), Yl(e)) {
      if (!e.method.endsWith(gj)) return;
      const t = e.params, { topic: n, message: s, publishedAt: i, attestation: o } = t.data, a = { topic: n, message: s, publishedAt: i, transportType: Ye.relay, attestation: o };
      this.logger.debug("Emitting Relayer Payload"), this.logger.trace(Kf({ type: "event", event: t.id }, a)), this.events.emit(t.id, a), await this.acknowledgePayload(e), await this.onMessageEvent(a);
    } else Xa(e) && this.events.emit(tt.message_ack, e);
  }
  async onMessageEvent(e) {
    await this.shouldIgnoreMessageEvent(e) || (await this.recordMessageEvent(e, Oo.inbound), this.events.emit(tt.message, e));
  }
  async acknowledgePayload(e) {
    const t = ea(e.id, true);
    await this.provider.connection.send(t);
  }
  unregisterProviderListeners() {
    this.provider.off(ir.payload, this.onPayloadHandler), this.provider.off(ir.connect, this.onConnectHandler), this.provider.off(ir.disconnect, this.onDisconnectHandler), this.provider.off(ir.error, this.onProviderErrorHandler), clearTimeout(this.pingTimeout);
  }
  async registerEventListeners() {
    let e = await Of();
    E3(async (t) => {
      e !== t && (e = t, t ? await this.transportOpen().catch((n) => this.logger.error(n, n == null ? void 0 : n.message)) : (this.hasExperiencedNetworkDisruption = true, await this.transportDisconnect(), this.transportExplicitlyClosed = false));
    }), this.core.heartbeat.on(ui.pulse, async () => {
      if (!this.transportExplicitlyClosed && !this.connected && I3()) try {
        await this.confirmOnlineStateOrThrow(), await this.transportOpen();
      } catch (t) {
        this.logger.warn(t, t == null ? void 0 : t.message);
      }
    });
  }
  async onProviderDisconnect() {
    clearTimeout(this.pingTimeout), this.events.emit(tt.disconnect), this.connectionAttemptInProgress = false, !this.reconnectInProgress && (this.reconnectInProgress = true, await this.subscriber.stop(), this.subscriber.hasAnyTopics && (this.transportExplicitlyClosed || (this.reconnectTimeout = setTimeout(async () => {
      await this.transportOpen().catch((e) => this.logger.error(e, e == null ? void 0 : e.message)), this.reconnectTimeout = void 0, this.reconnectInProgress = false;
    }, ce.toMiliseconds(yj)))));
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ae("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async toEstablishConnection() {
    if (await this.confirmOnlineStateOrThrow(), !this.connected) {
      if (this.connectPromise) {
        await this.connectPromise;
        return;
      }
      await this.connect();
    }
  }
};
function B5(r, e) {
  return r === e || Number.isNaN(r) && Number.isNaN(e);
}
function Xf(r) {
  return Object.getOwnPropertySymbols(r).filter((e) => Object.prototype.propertyIsEnumerable.call(r, e));
}
function Zf(r) {
  return r == null ? r === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(r);
}
var R5 = "[object RegExp]";
var $5 = "[object String]";
var F5 = "[object Number]";
var Q5 = "[object Boolean]";
var Jf = "[object Arguments]";
var q5 = "[object Symbol]";
var Y5 = "[object Date]";
var V5 = "[object Map]";
var H5 = "[object Set]";
var G5 = "[object Array]";
var W5 = "[object Function]";
var K5 = "[object ArrayBuffer]";
var Jc = "[object Object]";
var X5 = "[object Error]";
var Z5 = "[object DataView]";
var J5 = "[object Uint8Array]";
var eL = "[object Uint8ClampedArray]";
var tL = "[object Uint16Array]";
var rL = "[object Uint32Array]";
var nL = "[object BigUint64Array]";
var iL = "[object Int8Array]";
var sL = "[object Int16Array]";
var oL = "[object Int32Array]";
var aL = "[object BigInt64Array]";
var cL = "[object Float32Array]";
var uL = "[object Float64Array]";
function lL() {
}
function ep(r) {
  if (!r || typeof r != "object") return false;
  const e = Object.getPrototypeOf(r);
  return e === null || e === Object.prototype || Object.getPrototypeOf(e) === null ? Object.prototype.toString.call(r) === "[object Object]" : false;
}
function dL(r, e, t) {
  return ys(r, e, void 0, void 0, void 0, void 0, t);
}
function ys(r, e, t, n, s, i, o) {
  const a = o(r, e, t, n, s, i);
  if (a !== void 0) return a;
  if (typeof r == typeof e) switch (typeof r) {
    case "bigint":
    case "string":
    case "boolean":
    case "symbol":
    case "undefined":
      return r === e;
    case "number":
      return r === e || Object.is(r, e);
    case "function":
      return r === e;
    case "object":
      return Es(r, e, i, o);
  }
  return Es(r, e, i, o);
}
function Es(r, e, t, n) {
  if (Object.is(r, e)) return true;
  let s = Zf(r), i = Zf(e);
  if (s === Jf && (s = Jc), i === Jf && (i = Jc), s !== i) return false;
  switch (s) {
    case $5:
      return r.toString() === e.toString();
    case F5: {
      const u = r.valueOf(), c = e.valueOf();
      return B5(u, c);
    }
    case Q5:
    case Y5:
    case q5:
      return Object.is(r.valueOf(), e.valueOf());
    case R5:
      return r.source === e.source && r.flags === e.flags;
    case W5:
      return r === e;
  }
  t = t ?? /* @__PURE__ */ new Map();
  const o = t.get(r), a = t.get(e);
  if (o != null && a != null) return o === e;
  t.set(r, e), t.set(e, r);
  try {
    switch (s) {
      case V5: {
        if (r.size !== e.size) return false;
        for (const [u, c] of r.entries()) if (!e.has(u) || !ys(c, e.get(u), u, r, e, t, n)) return false;
        return true;
      }
      case H5: {
        if (r.size !== e.size) return false;
        const u = Array.from(r.values()), c = Array.from(e.values());
        for (let l = 0; l < u.length; l++) {
          const d = u[l], h = c.findIndex((f) => ys(d, f, void 0, r, e, t, n));
          if (h === -1) return false;
          c.splice(h, 1);
        }
        return true;
      }
      case G5:
      case J5:
      case eL:
      case tL:
      case rL:
      case nL:
      case iL:
      case sL:
      case oL:
      case aL:
      case cL:
      case uL: {
        if (typeof Buffer < "u" && Buffer.isBuffer(r) !== Buffer.isBuffer(e) || r.length !== e.length) return false;
        for (let u = 0; u < r.length; u++) if (!ys(r[u], e[u], u, r, e, t, n)) return false;
        return true;
      }
      case K5:
        return r.byteLength !== e.byteLength ? false : Es(new Uint8Array(r), new Uint8Array(e), t, n);
      case Z5:
        return r.byteLength !== e.byteLength || r.byteOffset !== e.byteOffset ? false : Es(new Uint8Array(r), new Uint8Array(e), t, n);
      case X5:
        return r.name === e.name && r.message === e.message;
      case Jc: {
        if (!(Es(r.constructor, e.constructor, t, n) || ep(r) && ep(e))) return false;
        const u = [...Object.keys(r), ...Xf(r)], c = [...Object.keys(e), ...Xf(e)];
        if (u.length !== c.length) return false;
        for (let l = 0; l < u.length; l++) {
          const d = u[l], h = r[d];
          if (!Object.hasOwn(e, d)) return false;
          const f = e[d];
          if (!ys(h, f, d, r, e, t, n)) return false;
        }
        return true;
      }
      default:
        return false;
    }
  } finally {
    t.delete(r), t.delete(e);
  }
}
function hL(r, e) {
  return dL(r, e, lL);
}
var fL = Object.defineProperty;
var tp = Object.getOwnPropertySymbols;
var pL = Object.prototype.hasOwnProperty;
var gL = Object.prototype.propertyIsEnumerable;
var Wu = (r, e, t) => e in r ? fL(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;
var rp = (r, e) => {
  for (var t in e || (e = {})) pL.call(e, t) && Wu(r, t, e[t]);
  if (tp) for (var t of tp(e)) gL.call(e, t) && Wu(r, t, e[t]);
  return r;
};
var Pt = (r, e, t) => Wu(r, typeof e != "symbol" ? e + "" : e, t);
var fi = class extends QE {
  constructor(e, t, n, s = Lr, i = void 0) {
    super(e, t, n, s), this.core = e, this.logger = t, this.name = n, Pt(this, "map", /* @__PURE__ */ new Map()), Pt(this, "version", wj), Pt(this, "cached", []), Pt(this, "initialized", false), Pt(this, "getKey"), Pt(this, "storagePrefix", Lr), Pt(this, "recentlyDeleted", []), Pt(this, "recentlyDeletedLimit", 200), Pt(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((o) => {
        this.getKey && o !== null && !ut(o) ? this.map.set(this.getKey(o), o) : JS(o) ? this.map.set(o.id, o) : e3(o) && this.map.set(o.topic, o);
      }), this.cached = [], this.initialized = true);
    }), Pt(this, "set", async (o, a) => {
      this.isInitialized(), this.map.has(o) ? await this.update(o, a) : (this.logger.debug("Setting value"), this.logger.trace({ type: "method", method: "set", key: o, value: a }), this.map.set(o, a), await this.persist());
    }), Pt(this, "get", (o) => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({ type: "method", method: "get", key: o }), this.getData(o))), Pt(this, "getAll", (o) => (this.isInitialized(), o ? this.values.filter((a) => Object.keys(o).every((u) => hL(a[u], o[u]))) : this.values)), Pt(this, "update", async (o, a) => {
      this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({ type: "method", method: "update", key: o, update: a });
      const u = rp(rp({}, this.getData(o)), a);
      this.map.set(o, u), await this.persist();
    }), Pt(this, "delete", async (o, a) => {
      this.isInitialized(), this.map.has(o) && (this.logger.debug("Deleting value"), this.logger.trace({ type: "method", method: "delete", key: o, reason: a }), this.map.delete(o), this.addToRecentlyDeleted(o), await this.persist());
    }), this.logger = tr(t, this.name), this.storagePrefix = s, this.getKey = i;
  }
  get context() {
    return Wt(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.map.size;
  }
  get keys() {
    return Array.from(this.map.keys());
  }
  get values() {
    return Array.from(this.map.values());
  }
  addToRecentlyDeleted(e) {
    this.recentlyDeleted.push(e), this.recentlyDeleted.length >= this.recentlyDeletedLimit && this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2);
  }
  async setDataStore(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getDataStore() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getData(e) {
    const t = this.map.get(e);
    if (!t) {
      if (this.recentlyDeleted.includes(e)) {
        const { message: s } = ae("MISSING_OR_INVALID", `Record was recently deleted - ${this.name}: ${e}`);
        throw this.logger.error(s), new Error(s);
      }
      const { message: n } = ae("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.error(n), new Error(n);
    }
    return t;
  }
  async persist() {
    await this.setDataStore(this.values);
  }
  async restore() {
    try {
      const e = await this.getDataStore();
      if (typeof e > "u" || !e.length) return;
      if (this.map.size) {
        const { message: t } = ae("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: "method", method: "restore", value: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ae("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var yL = Object.defineProperty;
var wL = (r, e, t) => e in r ? yL(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;
var Te = (r, e, t) => wL(r, typeof e != "symbol" ? e + "" : e, t);
var mL = class {
  constructor(e, t) {
    this.core = e, this.logger = t, Te(this, "name", Mj), Te(this, "version", Ej), Te(this, "events", new xp()), Te(this, "pairings"), Te(this, "initialized", false), Te(this, "storagePrefix", Lr), Te(this, "ignoredPayloadTypes", [Zr]), Te(this, "registeredMethods", []), Te(this, "init", async () => {
      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = true, this.logger.trace("Initialized"));
    }), Te(this, "register", ({ methods: n }) => {
      this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...n])];
    }), Te(this, "create", async (n) => {
      this.isInitialized();
      const s = Bu(), i = await this.core.crypto.setSymKey(s), o = ot(ce.FIVE_MINUTES), a = { protocol: hw }, u = { topic: i, expiry: o, relay: a, active: false, methods: n == null ? void 0 : n.methods }, c = Mf({ protocol: this.core.protocol, version: this.core.version, topic: i, symKey: s, relay: a, expiryTimestamp: o, methods: n == null ? void 0 : n.methods });
      return this.events.emit(Vn.create, u), this.core.expirer.set(i, o), await this.pairings.set(i, u), await this.core.relayer.subscribe(i, { transportType: n == null ? void 0 : n.transportType, internal: n == null ? void 0 : n.internal }), { topic: i, uri: c };
    }), Te(this, "pair", async (n) => {
      this.isInitialized();
      const s = this.core.eventClient.createEvent({ properties: { topic: n == null ? void 0 : n.uri, trace: [Ar.pairing_started] } });
      this.isValidPair(n, s);
      const { topic: i, symKey: o, relay: a, expiryTimestamp: u, methods: c } = vf(n.uri);
      s.props.properties.topic = i, s.addTrace(Ar.pairing_uri_validation_success), s.addTrace(Ar.pairing_uri_not_expired);
      let l;
      if (this.pairings.keys.includes(i)) {
        if (l = this.pairings.get(i), s.addTrace(Ar.existing_pairing), l.active) throw s.setError(qr.active_pairing_already_exists), new Error(`Pairing already exists: ${i}. Please try again with a new connection URI.`);
        s.addTrace(Ar.pairing_not_expired);
      }
      const d = u || ot(ce.FIVE_MINUTES), h = { topic: i, relay: a, expiry: d, active: false, methods: c };
      this.core.expirer.set(i, d), await this.pairings.set(i, h), s.addTrace(Ar.store_new_pairing), n.activatePairing && await this.activate({ topic: i }), this.events.emit(Vn.create, h), s.addTrace(Ar.emit_inactive_pairing), this.core.crypto.keychain.has(i) || await this.core.crypto.setSymKey(o, i), s.addTrace(Ar.subscribing_pairing_topic);
      try {
        await this.core.relayer.confirmOnlineStateOrThrow();
      } catch {
        s.setError(qr.no_internet_connection);
      }
      try {
        await this.core.relayer.subscribe(i, { relay: a });
      } catch (f) {
        throw s.setError(qr.subscribe_pairing_topic_failure), f;
      }
      return s.addTrace(Ar.subscribe_pairing_topic_success), h;
    }), Te(this, "activate", async ({ topic: n }) => {
      this.isInitialized();
      const s = ot(ce.FIVE_MINUTES);
      this.core.expirer.set(n, s), await this.pairings.update(n, { active: true, expiry: s });
    }), Te(this, "ping", async (n) => {
      this.isInitialized(), await this.isValidPing(n), this.logger.warn("ping() is deprecated and will be removed in the next major release.");
      const { topic: s } = n;
      if (this.pairings.keys.includes(s)) {
        const i = await this.sendRequest(s, "wc_pairingPing", {}), { done: o, resolve: a, reject: u } = Qn();
        this.events.once(Le("pairing_ping", i), ({ error: c }) => {
          c ? u(c) : a();
        }), await o();
      }
    }), Te(this, "updateExpiry", async ({ topic: n, expiry: s }) => {
      this.isInitialized(), await this.pairings.update(n, { expiry: s });
    }), Te(this, "updateMetadata", async ({ topic: n, metadata: s }) => {
      this.isInitialized(), await this.pairings.update(n, { peerMetadata: s });
    }), Te(this, "getPairings", () => (this.isInitialized(), this.pairings.values)), Te(this, "disconnect", async (n) => {
      this.isInitialized(), await this.isValidDisconnect(n);
      const { topic: s } = n;
      this.pairings.keys.includes(s) && (await this.sendRequest(s, "wc_pairingDelete", Je("USER_DISCONNECTED")), await this.deletePairing(s));
    }), Te(this, "formatUriFromPairing", (n) => {
      this.isInitialized();
      const { topic: s, relay: i, expiry: o, methods: a } = n, u = this.core.crypto.keychain.get(s);
      return Mf({ protocol: this.core.protocol, version: this.core.version, topic: s, symKey: u, relay: i, expiryTimestamp: o, methods: a });
    }), Te(this, "sendRequest", async (n, s, i) => {
      const o = Gr(s, i), a = await this.core.crypto.encode(n, o), u = us[s].req;
      return this.core.history.set(n, o), this.core.relayer.publish(n, a, u), o.id;
    }), Te(this, "sendResult", async (n, s, i) => {
      const o = ea(n, i), a = await this.core.crypto.encode(s, o), u = (await this.core.history.get(s, n)).request.method, c = us[u].res;
      await this.core.relayer.publish(s, a, c), await this.core.history.resolve(o);
    }), Te(this, "sendError", async (n, s, i) => {
      const o = ql(n, i), a = await this.core.crypto.encode(s, o), u = (await this.core.history.get(s, n)).request.method, c = us[u] ? us[u].res : us.unregistered_method.res;
      await this.core.relayer.publish(s, a, c), await this.core.history.resolve(o);
    }), Te(this, "deletePairing", async (n, s) => {
      await this.core.relayer.unsubscribe(n), await Promise.all([this.pairings.delete(n, Je("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(n), s ? Promise.resolve() : this.core.expirer.del(n)]);
    }), Te(this, "cleanup", async () => {
      const n = this.pairings.getAll().filter((s) => wn(s.expiry));
      await Promise.all(n.map((s) => this.deletePairing(s.topic)));
    }), Te(this, "onRelayEventRequest", async (n) => {
      const { topic: s, payload: i } = n;
      switch (i.method) {
        case "wc_pairingPing":
          return await this.onPairingPingRequest(s, i);
        case "wc_pairingDelete":
          return await this.onPairingDeleteRequest(s, i);
        default:
          return await this.onUnknownRpcMethodRequest(s, i);
      }
    }), Te(this, "onRelayEventResponse", async (n) => {
      const { topic: s, payload: i } = n, o = (await this.core.history.get(s, i.id)).request.method;
      switch (o) {
        case "wc_pairingPing":
          return this.onPairingPingResponse(s, i);
        default:
          return this.onUnknownRpcMethodResponse(o);
      }
    }), Te(this, "onPairingPingRequest", async (n, s) => {
      const { id: i } = s;
      try {
        this.isValidPing({ topic: n }), await this.sendResult(i, n, true), this.events.emit(Vn.ping, { id: i, topic: n });
      } catch (o) {
        await this.sendError(i, n, o), this.logger.error(o);
      }
    }), Te(this, "onPairingPingResponse", (n, s) => {
      const { id: i } = s;
      setTimeout(() => {
        Sr(s) ? this.events.emit(Le("pairing_ping", i), {}) : lr(s) && this.events.emit(Le("pairing_ping", i), { error: s.error });
      }, 500);
    }), Te(this, "onPairingDeleteRequest", async (n, s) => {
      const { id: i } = s;
      try {
        this.isValidDisconnect({ topic: n }), await this.deletePairing(n), this.events.emit(Vn.delete, { id: i, topic: n });
      } catch (o) {
        await this.sendError(i, n, o), this.logger.error(o);
      }
    }), Te(this, "onUnknownRpcMethodRequest", async (n, s) => {
      const { id: i, method: o } = s;
      try {
        if (this.registeredMethods.includes(o)) return;
        const a = Je("WC_METHOD_UNSUPPORTED", o);
        await this.sendError(i, n, a), this.logger.error(a);
      } catch (a) {
        await this.sendError(i, n, a), this.logger.error(a);
      }
    }), Te(this, "onUnknownRpcMethodResponse", (n) => {
      this.registeredMethods.includes(n) || this.logger.error(Je("WC_METHOD_UNSUPPORTED", n));
    }), Te(this, "isValidPair", (n, s) => {
      var i;
      if (!$t(n)) {
        const { message: a } = ae("MISSING_OR_INVALID", `pair() params: ${n}`);
        throw s.setError(qr.malformed_pairing_uri), new Error(a);
      }
      if (!ZS(n.uri)) {
        const { message: a } = ae("MISSING_OR_INVALID", `pair() uri: ${n.uri}`);
        throw s.setError(qr.malformed_pairing_uri), new Error(a);
      }
      const o = vf(n == null ? void 0 : n.uri);
      if (!((i = o == null ? void 0 : o.relay) != null && i.protocol)) {
        const { message: a } = ae("MISSING_OR_INVALID", "pair() uri#relay-protocol");
        throw s.setError(qr.malformed_pairing_uri), new Error(a);
      }
      if (!(o != null && o.symKey)) {
        const { message: a } = ae("MISSING_OR_INVALID", "pair() uri#symKey");
        throw s.setError(qr.malformed_pairing_uri), new Error(a);
      }
      if (o != null && o.expiryTimestamp && ce.toMiliseconds(o == null ? void 0 : o.expiryTimestamp) < Date.now()) {
        s.setError(qr.pairing_expired);
        const { message: a } = ae("EXPIRED", "pair() URI has expired. Please try again with a new connection URI.");
        throw new Error(a);
      }
    }), Te(this, "isValidPing", async (n) => {
      if (!$t(n)) {
        const { message: i } = ae("MISSING_OR_INVALID", `ping() params: ${n}`);
        throw new Error(i);
      }
      const { topic: s } = n;
      await this.isValidPairingTopic(s);
    }), Te(this, "isValidDisconnect", async (n) => {
      if (!$t(n)) {
        const { message: i } = ae("MISSING_OR_INVALID", `disconnect() params: ${n}`);
        throw new Error(i);
      }
      const { topic: s } = n;
      await this.isValidPairingTopic(s);
    }), Te(this, "isValidPairingTopic", async (n) => {
      if (!it(n, false)) {
        const { message: s } = ae("MISSING_OR_INVALID", `pairing topic should be a string: ${n}`);
        throw new Error(s);
      }
      if (!this.pairings.keys.includes(n)) {
        const { message: s } = ae("NO_MATCHING_KEY", `pairing topic doesn't exist: ${n}`);
        throw new Error(s);
      }
      if (wn(this.pairings.get(n).expiry)) {
        await this.deletePairing(n);
        const { message: s } = ae("EXPIRED", `pairing topic: ${n}`);
        throw new Error(s);
      }
    }), this.core = e, this.logger = tr(t, this.name), this.pairings = new fi(this.core, this.logger, this.name, this.storagePrefix);
  }
  get context() {
    return Wt(this.logger);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ae("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  registerRelayerEvents() {
    this.core.relayer.on(tt.message, async (e) => {
      const { topic: t, message: n, transportType: s } = e;
      if (this.pairings.keys.includes(t) && s !== Ye.link_mode && !this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(n))) try {
        const i = await this.core.crypto.decode(t, n);
        Yl(i) ? (this.core.history.set(t, i), await this.onRelayEventRequest({ topic: t, payload: i })) : Xa(i) && (await this.core.history.resolve(i), await this.onRelayEventResponse({ topic: t, payload: i }), this.core.history.delete(t, i.id)), await this.core.relayer.messages.ack(t, n);
      } catch (i) {
        this.logger.error(i);
      }
    });
  }
  registerExpirerEvents() {
    this.core.expirer.on(or.expired, async (e) => {
      const { topic: t } = iy(e.target);
      t && this.pairings.keys.includes(t) && (await this.deletePairing(t, true), this.events.emit(Vn.expire, { topic: t }));
    });
  }
};
var bL = Object.defineProperty;
var vL = (r, e, t) => e in r ? bL(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;
var bt = (r, e, t) => vL(r, typeof e != "symbol" ? e + "" : e, t);
var ML = class extends BE {
  constructor(e, t) {
    super(e, t), this.core = e, this.logger = t, bt(this, "records", /* @__PURE__ */ new Map()), bt(this, "events", new Gt.EventEmitter()), bt(this, "name", Nj), bt(this, "version", xj), bt(this, "cached", []), bt(this, "initialized", false), bt(this, "storagePrefix", Lr), bt(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((n) => this.records.set(n.id, n)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }), bt(this, "set", (n, s, i) => {
      if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({ type: "method", method: "set", topic: n, request: s, chainId: i }), this.records.has(s.id)) return;
      const o = { id: s.id, topic: n, request: { method: s.method, params: s.params || null }, chainId: i, expiry: ot(ce.THIRTY_DAYS) };
      this.records.set(o.id, o), this.persist(), this.events.emit(gr.created, o);
    }), bt(this, "resolve", async (n) => {
      if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({ type: "method", method: "update", response: n }), !this.records.has(n.id)) return;
      const s = await this.getRecord(n.id);
      typeof s.response > "u" && (s.response = lr(n) ? { error: n.error } : { result: n.result }, this.records.set(s.id, s), this.persist(), this.events.emit(gr.updated, s));
    }), bt(this, "get", async (n, s) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({ type: "method", method: "get", topic: n, id: s }), await this.getRecord(s))), bt(this, "delete", (n, s) => {
      this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({ type: "method", method: "delete", id: s }), this.values.forEach((i) => {
        if (i.topic === n) {
          if (typeof s < "u" && i.id !== s) return;
          this.records.delete(i.id), this.events.emit(gr.deleted, i);
        }
      }), this.persist();
    }), bt(this, "exists", async (n, s) => (this.isInitialized(), this.records.has(s) ? (await this.getRecord(s)).topic === n : false)), bt(this, "on", (n, s) => {
      this.events.on(n, s);
    }), bt(this, "once", (n, s) => {
      this.events.once(n, s);
    }), bt(this, "off", (n, s) => {
      this.events.off(n, s);
    }), bt(this, "removeListener", (n, s) => {
      this.events.removeListener(n, s);
    }), this.logger = tr(t, this.name);
  }
  get context() {
    return Wt(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get size() {
    return this.records.size;
  }
  get keys() {
    return Array.from(this.records.keys());
  }
  get values() {
    return Array.from(this.records.values());
  }
  get pending() {
    const e = [];
    return this.values.forEach((t) => {
      if (typeof t.response < "u") return;
      const n = { topic: t.topic, request: Gr(t.request.method, t.request.params, t.id), chainId: t.chainId };
      return e.push(n);
    }), e;
  }
  async setJsonRpcRecords(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getJsonRpcRecords() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getRecord(e) {
    this.isInitialized();
    const t = this.records.get(e);
    if (!t) {
      const { message: n } = ae("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(n);
    }
    return t;
  }
  async persist() {
    await this.setJsonRpcRecords(this.values), this.events.emit(gr.sync);
  }
  async restore() {
    try {
      const e = await this.getJsonRpcRecords();
      if (typeof e > "u" || !e.length) return;
      if (this.records.size) {
        const { message: t } = ae("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", records: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e);
    }
  }
  registerEventListeners() {
    this.events.on(gr.created, (e) => {
      const t = gr.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e });
    }), this.events.on(gr.updated, (e) => {
      const t = gr.updated;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e });
    }), this.events.on(gr.deleted, (e) => {
      const t = gr.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e });
    }), this.core.heartbeat.on(ui.pulse, () => {
      this.cleanup();
    });
  }
  cleanup() {
    try {
      this.isInitialized();
      let e = false;
      this.records.forEach((t) => {
        ce.toMiliseconds(t.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${t.id}`), this.records.delete(t.id), this.events.emit(gr.deleted, t, false), e = true);
      }), e && this.persist();
    } catch (e) {
      this.logger.warn(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ae("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var EL = Object.defineProperty;
var NL = (r, e, t) => e in r ? EL(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;
var At = (r, e, t) => NL(r, typeof e != "symbol" ? e + "" : e, t);
var xL = class extends YE {
  constructor(e, t) {
    super(e, t), this.core = e, this.logger = t, At(this, "expirations", /* @__PURE__ */ new Map()), At(this, "events", new Gt.EventEmitter()), At(this, "name", Ij), At(this, "version", _j), At(this, "cached", []), At(this, "initialized", false), At(this, "storagePrefix", Lr), At(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((n) => this.expirations.set(n.target, n)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }), At(this, "has", (n) => {
      try {
        const s = this.formatTarget(n);
        return typeof this.getExpiration(s) < "u";
      } catch {
        return false;
      }
    }), At(this, "set", (n, s) => {
      this.isInitialized();
      const i = this.formatTarget(n), o = { target: i, expiry: s };
      this.expirations.set(i, o), this.checkExpiry(i, o), this.events.emit(or.created, { target: i, expiration: o });
    }), At(this, "get", (n) => {
      this.isInitialized();
      const s = this.formatTarget(n);
      return this.getExpiration(s);
    }), At(this, "del", (n) => {
      if (this.isInitialized(), this.has(n)) {
        const s = this.formatTarget(n), i = this.getExpiration(s);
        this.expirations.delete(s), this.events.emit(or.deleted, { target: s, expiration: i });
      }
    }), At(this, "on", (n, s) => {
      this.events.on(n, s);
    }), At(this, "once", (n, s) => {
      this.events.once(n, s);
    }), At(this, "off", (n, s) => {
      this.events.off(n, s);
    }), At(this, "removeListener", (n, s) => {
      this.events.removeListener(n, s);
    }), this.logger = tr(t, this.name);
  }
  get context() {
    return Wt(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.expirations.size;
  }
  get keys() {
    return Array.from(this.expirations.keys());
  }
  get values() {
    return Array.from(this.expirations.values());
  }
  formatTarget(e) {
    if (typeof e == "string") return AA(e);
    if (typeof e == "number") return OA(e);
    const { message: t } = ae("UNKNOWN_TYPE", `Target type: ${typeof e}`);
    throw new Error(t);
  }
  async setExpirations(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getExpirations() {
    return await this.core.storage.getItem(this.storageKey);
  }
  async persist() {
    await this.setExpirations(this.values), this.events.emit(or.sync);
  }
  async restore() {
    try {
      const e = await this.getExpirations();
      if (typeof e > "u" || !e.length) return;
      if (this.expirations.size) {
        const { message: t } = ae("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: "method", method: "restore", expirations: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e);
    }
  }
  getExpiration(e) {
    const t = this.expirations.get(e);
    if (!t) {
      const { message: n } = ae("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.warn(n), new Error(n);
    }
    return t;
  }
  checkExpiry(e, t) {
    const { expiry: n } = t;
    ce.toMiliseconds(n) - Date.now() <= 0 && this.expire(e, t);
  }
  expire(e, t) {
    this.expirations.delete(e), this.events.emit(or.expired, { target: e, expiration: t });
  }
  checkExpirations() {
    this.core.relayer.connected && this.expirations.forEach((e, t) => this.checkExpiry(t, e));
  }
  registerEventListeners() {
    this.core.heartbeat.on(ui.pulse, () => this.checkExpirations()), this.events.on(or.created, (e) => {
      const t = or.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    }), this.events.on(or.expired, (e) => {
      const t = or.expired;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    }), this.events.on(or.deleted, (e) => {
      const t = or.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ae("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var IL = Object.defineProperty;
var _L = (r, e, t) => e in r ? IL(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;
var nt = (r, e, t) => _L(r, typeof e != "symbol" ? e + "" : e, t);
var DL = class extends VE {
  constructor(e, t, n) {
    super(e, t, n), this.core = e, this.logger = t, this.store = n, nt(this, "name", Dj), nt(this, "abortController"), nt(this, "isDevEnv"), nt(this, "verifyUrlV3", Aj), nt(this, "storagePrefix", Lr), nt(this, "version", dw), nt(this, "publicKey"), nt(this, "fetchPromise"), nt(this, "init", async () => {
      var s;
      this.isDevEnv || (this.publicKey = await this.store.getItem(this.storeKey), this.publicKey && ce.toMiliseconds((s = this.publicKey) == null ? void 0 : s.expiresAt) < Date.now() && (this.logger.debug("verify v2 public key expired"), await this.removePublicKey()));
    }), nt(this, "register", async (s) => {
      if (!qi() || this.isDevEnv) return;
      const i = window.location.origin, { id: o, decryptedId: a } = s, u = `${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${i}&id=${o}&decryptedId=${a}`;
      try {
        const c = ri(), l = this.startAbortTimer(ce.ONE_SECOND * 5), d = await new Promise((h, f) => {
          const g = () => {
            window.removeEventListener("message", b), c.body.removeChild(p), f("attestation aborted");
          };
          this.abortController.signal.addEventListener("abort", g);
          const p = c.createElement("iframe");
          p.src = u, p.style.display = "none", p.addEventListener("error", g, { signal: this.abortController.signal });
          const b = (_) => {
            if (_.data && typeof _.data == "string") try {
              const D = JSON.parse(_.data);
              if (D.type === "verify_attestation") {
                if (wu(D.attestation).payload.id !== o) return;
                clearInterval(l), c.body.removeChild(p), this.abortController.signal.removeEventListener("abort", g), window.removeEventListener("message", b), h(D.attestation === null ? "" : D.attestation);
              }
            } catch (D) {
              this.logger.warn(D);
            }
          };
          c.body.appendChild(p), window.addEventListener("message", b, { signal: this.abortController.signal });
        });
        return this.logger.debug(d, "jwt attestation"), d;
      } catch (c) {
        this.logger.warn(c);
      }
      return "";
    }), nt(this, "resolve", async (s) => {
      if (this.isDevEnv) return "";
      const { attestationId: i, hash: o, encryptedId: a } = s;
      if (i === "") {
        this.logger.debug("resolve: attestationId is empty, skipping");
        return;
      }
      if (i) {
        if (wu(i).payload.id !== a) return;
        const c = await this.isValidJwtAttestation(i);
        if (c) {
          if (!c.isVerified) {
            this.logger.warn("resolve: jwt attestation: origin url not verified");
            return;
          }
          return c;
        }
      }
      if (!o) return;
      const u = this.getVerifyUrl(s == null ? void 0 : s.verifyUrl);
      return this.fetchAttestation(o, u);
    }), nt(this, "fetchAttestation", async (s, i) => {
      this.logger.debug(`resolving attestation: ${s} from url: ${i}`);
      const o = this.startAbortTimer(ce.ONE_SECOND * 5), a = await fetch(`${i}/attestation/${s}?v2Supported=true`, { signal: this.abortController.signal });
      return clearTimeout(o), a.status === 200 ? await a.json() : void 0;
    }), nt(this, "getVerifyUrl", (s) => {
      let i = s || Ms;
      return Oj.includes(i) || (this.logger.info(`verify url: ${i}, not included in trusted list, assigning default: ${Ms}`), i = Ms), i;
    }), nt(this, "fetchPublicKey", async () => {
      try {
        this.logger.debug(`fetching public key from: ${this.verifyUrlV3}`);
        const s = this.startAbortTimer(ce.FIVE_SECONDS), i = await fetch(`${this.verifyUrlV3}/public-key`, { signal: this.abortController.signal });
        return clearTimeout(s), await i.json();
      } catch (s) {
        this.logger.warn(s);
      }
    }), nt(this, "persistPublicKey", async (s) => {
      this.logger.debug(s, "persisting public key to local storage"), await this.store.setItem(this.storeKey, s), this.publicKey = s;
    }), nt(this, "removePublicKey", async () => {
      this.logger.debug("removing verify v2 public key from storage"), await this.store.removeItem(this.storeKey), this.publicKey = void 0;
    }), nt(this, "isValidJwtAttestation", async (s) => {
      const i = await this.getPublicKey();
      try {
        if (i) return this.validateAttestation(s, i);
      } catch (a) {
        this.logger.error(a), this.logger.warn("error validating attestation");
      }
      const o = await this.fetchAndPersistPublicKey();
      try {
        if (o) return this.validateAttestation(s, o);
      } catch (a) {
        this.logger.error(a), this.logger.warn("error validating attestation");
      }
    }), nt(this, "getPublicKey", async () => this.publicKey ? this.publicKey : await this.fetchAndPersistPublicKey()), nt(this, "fetchAndPersistPublicKey", async () => {
      if (this.fetchPromise) return await this.fetchPromise, this.publicKey;
      this.fetchPromise = new Promise(async (i) => {
        const o = await this.fetchPublicKey();
        o && (await this.persistPublicKey(o), i(o));
      });
      const s = await this.fetchPromise;
      return this.fetchPromise = void 0, s;
    }), nt(this, "validateAttestation", (s, i) => {
      const o = xS(s, i.publicKey), a = { hasExpired: ce.toMiliseconds(o.exp) < Date.now(), payload: o };
      if (a.hasExpired) throw this.logger.warn("resolve: jwt attestation expired"), new Error("JWT attestation expired");
      return { origin: a.payload.origin, isScam: a.payload.isScam, isVerified: a.payload.isVerified };
    }), this.logger = tr(t, this.name), this.abortController = new AbortController(), this.isDevEnv = Sl(), this.init();
  }
  get storeKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//verify:public:key";
  }
  get context() {
    return Wt(this.logger);
  }
  startAbortTimer(e) {
    return this.abortController = new AbortController(), setTimeout(() => this.abortController.abort(), ce.toMiliseconds(e));
  }
};
var TL = Object.defineProperty;
var AL = (r, e, t) => e in r ? TL(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;
var np = (r, e, t) => AL(r, typeof e != "symbol" ? e + "" : e, t);
var OL = class extends HE {
  constructor(e, t) {
    super(e, t), this.projectId = e, this.logger = t, np(this, "context", Sj), np(this, "registerDeviceToken", async (n) => {
      const { clientId: s, token: i, notificationType: o, enableEncrypted: a = false } = n, u = `${jj}/${this.projectId}/clients`;
      await fetch(u, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ client_id: s, type: o, token: i, always_raw: a }) });
    }), this.logger = tr(t, this.context);
  }
};
var SL = Object.defineProperty;
var ip = Object.getOwnPropertySymbols;
var jL = Object.prototype.hasOwnProperty;
var CL = Object.prototype.propertyIsEnumerable;
var Ku = (r, e, t) => e in r ? SL(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;
var hs = (r, e) => {
  for (var t in e || (e = {})) jL.call(e, t) && Ku(r, t, e[t]);
  if (ip) for (var t of ip(e)) CL.call(e, t) && Ku(r, t, e[t]);
  return r;
};
var ht = (r, e, t) => Ku(r, typeof e != "symbol" ? e + "" : e, t);
var LL = class extends GE {
  constructor(e, t, n = true) {
    super(e, t, n), this.core = e, this.logger = t, ht(this, "context", Lj), ht(this, "storagePrefix", Lr), ht(this, "storageVersion", Cj), ht(this, "events", /* @__PURE__ */ new Map()), ht(this, "shouldPersist", false), ht(this, "init", async () => {
      if (!Sl()) try {
        const s = { eventId: Bh(), timestamp: Date.now(), domain: this.getAppDomain(), props: { event: "INIT", type: "", properties: { client_id: await this.core.crypto.getClientId(), user_agent: ry(this.core.relayer.protocol, this.core.relayer.version, Fu) } } };
        await this.sendEvent([s]);
      } catch (s) {
        this.logger.warn(s);
      }
    }), ht(this, "createEvent", (s) => {
      const { event: i = "ERROR", type: o = "", properties: { topic: a, trace: u } } = s, c = Bh(), l = this.core.projectId || "", d = Date.now(), h = hs({ eventId: c, timestamp: d, props: { event: i, type: o, properties: { topic: a, trace: u } }, bundleId: l, domain: this.getAppDomain() }, this.setMethods(c));
      return this.telemetryEnabled && (this.events.set(c, h), this.shouldPersist = true), h;
    }), ht(this, "getEvent", (s) => {
      const { eventId: i, topic: o } = s;
      if (i) return this.events.get(i);
      const a = Array.from(this.events.values()).find((u) => u.props.properties.topic === o);
      if (a) return hs(hs({}, a), this.setMethods(a.eventId));
    }), ht(this, "deleteEvent", (s) => {
      const { eventId: i } = s;
      this.events.delete(i), this.shouldPersist = true;
    }), ht(this, "setEventListeners", () => {
      this.core.heartbeat.on(ui.pulse, async () => {
        this.shouldPersist && await this.persist(), this.events.forEach((s) => {
          ce.fromMiliseconds(Date.now()) - ce.fromMiliseconds(s.timestamp) > zj && (this.events.delete(s.eventId), this.shouldPersist = true);
        });
      });
    }), ht(this, "setMethods", (s) => ({ addTrace: (i) => this.addTrace(s, i), setError: (i) => this.setError(s, i) })), ht(this, "addTrace", (s, i) => {
      const o = this.events.get(s);
      o && (o.props.properties.trace.push(i), this.events.set(s, o), this.shouldPersist = true);
    }), ht(this, "setError", (s, i) => {
      const o = this.events.get(s);
      o && (o.props.type = i, o.timestamp = Date.now(), this.events.set(s, o), this.shouldPersist = true);
    }), ht(this, "persist", async () => {
      await this.core.storage.setItem(this.storageKey, Array.from(this.events.values())), this.shouldPersist = false;
    }), ht(this, "restore", async () => {
      try {
        const s = await this.core.storage.getItem(this.storageKey) || [];
        if (!s.length) return;
        s.forEach((i) => {
          this.events.set(i.eventId, hs(hs({}, i), this.setMethods(i.eventId)));
        });
      } catch (s) {
        this.logger.warn(s);
      }
    }), ht(this, "submit", async () => {
      if (!this.telemetryEnabled || this.events.size === 0) return;
      const s = [];
      for (const [i, o] of this.events) o.props.type && s.push(o);
      if (s.length !== 0) try {
        if ((await this.sendEvent(s)).ok) for (const i of s) this.events.delete(i.eventId), this.shouldPersist = true;
      } catch (i) {
        this.logger.warn(i);
      }
    }), ht(this, "sendEvent", async (s) => {
      const i = this.getAppDomain() ? "" : "&sp=desktop";
      return await fetch(`${kj}?projectId=${this.core.projectId}&st=events_sdk&sv=js-${Fu}${i}`, { method: "POST", body: JSON.stringify(s) });
    }), ht(this, "getAppDomain", () => ty().url), this.logger = tr(t, this.context), this.telemetryEnabled = n, n ? this.restore().then(async () => {
      await this.submit(), this.setEventListeners();
    }) : this.persist();
  }
  get storageKey() {
    return this.storagePrefix + this.storageVersion + this.core.customStoragePrefix + "//" + this.context;
  }
};
var zL = Object.defineProperty;
var sp = Object.getOwnPropertySymbols;
var kL = Object.prototype.hasOwnProperty;
var UL = Object.prototype.propertyIsEnumerable;
var Xu = (r, e, t) => e in r ? zL(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;
var op = (r, e) => {
  for (var t in e || (e = {})) kL.call(e, t) && Xu(r, t, e[t]);
  if (sp) for (var t of sp(e)) UL.call(e, t) && Xu(r, t, e[t]);
  return r;
};
var Qe = (r, e, t) => Xu(r, typeof e != "symbol" ? e + "" : e, t);
var Vl = class _Vl extends zE {
  constructor(e) {
    var t;
    super(e), Qe(this, "protocol", lw), Qe(this, "version", dw), Qe(this, "name", $u), Qe(this, "relayUrl"), Qe(this, "projectId"), Qe(this, "customStoragePrefix"), Qe(this, "events", new Gt.EventEmitter()), Qe(this, "logger"), Qe(this, "heartbeat"), Qe(this, "relayer"), Qe(this, "crypto"), Qe(this, "storage"), Qe(this, "history"), Qe(this, "expirer"), Qe(this, "pairing"), Qe(this, "verify"), Qe(this, "echoClient"), Qe(this, "linkModeSupportedApps"), Qe(this, "eventClient"), Qe(this, "initialized", false), Qe(this, "logChunkController"), Qe(this, "on", (a, u) => this.events.on(a, u)), Qe(this, "once", (a, u) => this.events.once(a, u)), Qe(this, "off", (a, u) => this.events.off(a, u)), Qe(this, "removeListener", (a, u) => this.events.removeListener(a, u)), Qe(this, "dispatchEnvelope", ({ topic: a, message: u, sessionExists: c }) => {
      if (!a || !u) return;
      const l = { topic: a, message: u, publishedAt: Date.now(), transportType: Ye.link_mode };
      this.relayer.onLinkMessageEvent(l, { sessionExists: c });
    });
    const n = this.getGlobalCore(e == null ? void 0 : e.customStoragePrefix);
    if (n) try {
      return this.customStoragePrefix = n.customStoragePrefix, this.logger = n.logger, this.heartbeat = n.heartbeat, this.crypto = n.crypto, this.history = n.history, this.expirer = n.expirer, this.storage = n.storage, this.relayer = n.relayer, this.pairing = n.pairing, this.verify = n.verify, this.echoClient = n.echoClient, this.linkModeSupportedApps = n.linkModeSupportedApps, this.eventClient = n.eventClient, this.initialized = n.initialized, this.logChunkController = n.logChunkController, n;
    } catch (a) {
      console.warn("Failed to copy global core", a);
    }
    this.projectId = e == null ? void 0 : e.projectId, this.relayUrl = (e == null ? void 0 : e.relayUrl) || fw, this.customStoragePrefix = e != null && e.customStoragePrefix ? `:${e.customStoragePrefix}` : "";
    const s = TE({ level: typeof (e == null ? void 0 : e.logger) == "string" && e.logger ? e.logger : nj.logger, name: $u }), { logger: i, chunkLoggerController: o } = yg({ opts: s, maxSizeInBytes: e == null ? void 0 : e.maxLogBlobSizeInBytes, loggerOverride: e == null ? void 0 : e.logger });
    this.logChunkController = o, (t = this.logChunkController) != null && t.downloadLogsBlobInBrowser && (window.downloadLogsBlobInBrowser = async () => {
      var a, u;
      (a = this.logChunkController) != null && a.downloadLogsBlobInBrowser && ((u = this.logChunkController) == null || u.downloadLogsBlobInBrowser({ clientId: await this.crypto.getClientId() }));
    }), this.logger = tr(i, this.name), this.heartbeat = new cM(), this.crypto = new d5(this, this.logger, e == null ? void 0 : e.keychain), this.history = new ML(this, this.logger), this.expirer = new xL(this, this.logger), this.storage = e != null && e.storage ? e.storage : new qM(op(op({}, ij), e == null ? void 0 : e.storageOptions)), this.relayer = new P5({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new mL(this, this.logger), this.verify = new DL(this, this.logger, this.storage), this.echoClient = new OL(this.projectId || "", this.logger), this.linkModeSupportedApps = [], this.eventClient = new LL(this, this.logger, e == null ? void 0 : e.telemetryEnabled), this.setGlobalCore(this);
  }
  static async init(e) {
    const t = new _Vl(e);
    await t.initialize();
    const n = await t.crypto.getClientId();
    return await t.storage.setItem(mj, n), t;
  }
  get context() {
    return Wt(this.logger);
  }
  async start() {
    this.initialized || await this.initialize();
  }
  async getLogsBlob() {
    var e;
    return (e = this.logChunkController) == null ? void 0 : e.logsToBlob({ clientId: await this.crypto.getClientId() });
  }
  async addLinkModeSupportedApp(e) {
    this.linkModeSupportedApps.includes(e) || (this.linkModeSupportedApps.push(e), await this.storage.setItem(Pf, this.linkModeSupportedApps));
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.linkModeSupportedApps = await this.storage.getItem(Pf) || [], this.initialized = true, this.logger.info("Core Initialization Success");
    } catch (e) {
      throw this.logger.warn(e, `Core Initialization Failure at epoch ${Date.now()}`), this.logger.error(e.message), e;
    }
  }
  getGlobalCore(e = "") {
    try {
      if (this.isGlobalCoreDisabled()) return;
      const t = `_walletConnectCore_${e}`, n = `${t}_count`;
      return globalThis[n] = (globalThis[n] || 0) + 1, globalThis[n] > 1 && console.warn(`WalletConnect Core is already initialized. This is probably a mistake and can lead to unexpected behavior. Init() was called ${globalThis[n]} times.`), globalThis[t];
    } catch (t) {
      console.warn("Failed to get global WalletConnect core", t);
      return;
    }
  }
  setGlobalCore(e) {
    var t;
    try {
      if (this.isGlobalCoreDisabled()) return;
      const n = `_walletConnectCore_${((t = e.opts) == null ? void 0 : t.customStoragePrefix) || ""}`;
      globalThis[n] = e;
    } catch (n) {
      console.warn("Failed to set global WalletConnect core", n);
    }
  }
  isGlobalCoreDisabled() {
    try {
      return typeof process < "u" && process.env.DISABLE_GLOBAL_CORE === "true";
    } catch {
      return true;
    }
  }
};
var PL = Vl;
var _w = "wc";
var Dw = 2;
var Tw = "client";
var Hl = `${_w}@${Dw}:${Tw}:`;
var eu = { name: Tw, logger: "error" };
var ap = "WALLETCONNECT_DEEPLINK_CHOICE";
var BL = "proposal";
var cp = "Proposal expired";
var RL = "session";
var Ni = ce.SEVEN_DAYS;
var $L = "engine";
var vt = { wc_sessionPropose: { req: { ttl: ce.FIVE_MINUTES, prompt: true, tag: 1100 }, res: { ttl: ce.FIVE_MINUTES, prompt: false, tag: 1101 }, reject: { ttl: ce.FIVE_MINUTES, prompt: false, tag: 1120 }, autoReject: { ttl: ce.FIVE_MINUTES, prompt: false, tag: 1121 } }, wc_sessionSettle: { req: { ttl: ce.FIVE_MINUTES, prompt: false, tag: 1102 }, res: { ttl: ce.FIVE_MINUTES, prompt: false, tag: 1103 } }, wc_sessionUpdate: { req: { ttl: ce.ONE_DAY, prompt: false, tag: 1104 }, res: { ttl: ce.ONE_DAY, prompt: false, tag: 1105 } }, wc_sessionExtend: { req: { ttl: ce.ONE_DAY, prompt: false, tag: 1106 }, res: { ttl: ce.ONE_DAY, prompt: false, tag: 1107 } }, wc_sessionRequest: { req: { ttl: ce.FIVE_MINUTES, prompt: true, tag: 1108 }, res: { ttl: ce.FIVE_MINUTES, prompt: false, tag: 1109 } }, wc_sessionEvent: { req: { ttl: ce.FIVE_MINUTES, prompt: true, tag: 1110 }, res: { ttl: ce.FIVE_MINUTES, prompt: false, tag: 1111 } }, wc_sessionDelete: { req: { ttl: ce.ONE_DAY, prompt: false, tag: 1112 }, res: { ttl: ce.ONE_DAY, prompt: false, tag: 1113 } }, wc_sessionPing: { req: { ttl: ce.ONE_DAY, prompt: false, tag: 1114 }, res: { ttl: ce.ONE_DAY, prompt: false, tag: 1115 } }, wc_sessionAuthenticate: { req: { ttl: ce.ONE_HOUR, prompt: true, tag: 1116 }, res: { ttl: ce.ONE_HOUR, prompt: false, tag: 1117 }, reject: { ttl: ce.FIVE_MINUTES, prompt: false, tag: 1118 }, autoReject: { ttl: ce.FIVE_MINUTES, prompt: false, tag: 1119 } } };
var tu = { min: ce.FIVE_MINUTES, max: ce.SEVEN_DAYS };
var Dr = { idle: "IDLE", active: "ACTIVE" };
var FL = { eth_sendTransaction: { key: "" }, eth_sendRawTransaction: { key: "" }, wallet_sendCalls: { key: "" }, solana_signTransaction: { key: "signature" }, solana_signAllTransactions: { key: "transactions" }, solana_signAndSendTransaction: { key: "signature" }, sui_signAndExecuteTransaction: { key: "digest" }, sui_signTransaction: { key: "" }, hedera_signAndExecuteTransaction: { key: "transactionId" }, hedera_executeTransaction: { key: "transactionId" }, near_signTransaction: { key: "" }, near_signTransactions: { key: "" }, tron_signTransaction: { key: "txID" }, xrpl_signTransaction: { key: "" }, xrpl_signTransactionFor: { key: "" }, algo_signTxn: { key: "" }, sendTransfer: { key: "txid" }, stacks_stxTransfer: { key: "txId" }, polkadot_signTransaction: { key: "" }, cosmos_signDirect: { key: "" } };
var QL = "request";
var qL = ["wc_sessionPropose", "wc_sessionRequest", "wc_authRequest", "wc_sessionAuthenticate"];
var YL = "wc";
var VL = "auth";
var HL = "authKeys";
var GL = "pairingTopics";
var WL = "requests";
var Ja = `${YL}@${1.5}:${VL}:`;
var So = `${Ja}:PUB_KEY`;
var KL = Object.defineProperty;
var XL = Object.defineProperties;
var ZL = Object.getOwnPropertyDescriptors;
var up = Object.getOwnPropertySymbols;
var JL = Object.prototype.hasOwnProperty;
var ez = Object.prototype.propertyIsEnumerable;
var Zu = (r, e, t) => e in r ? KL(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;
var ze = (r, e) => {
  for (var t in e || (e = {})) JL.call(e, t) && Zu(r, t, e[t]);
  if (up) for (var t of up(e)) ez.call(e, t) && Zu(r, t, e[t]);
  return r;
};
var Ot = (r, e) => XL(r, ZL(e));
var oe = (r, e, t) => Zu(r, typeof e != "symbol" ? e + "" : e, t);
var tz = class extends ZE {
  constructor(e) {
    super(e), oe(this, "name", $L), oe(this, "events", new xp()), oe(this, "initialized", false), oe(this, "requestQueue", { state: Dr.idle, queue: [] }), oe(this, "sessionRequestQueue", { state: Dr.idle, queue: [] }), oe(this, "emittedSessionRequests", new BA({ limit: 500 })), oe(this, "requestQueueDelay", ce.ONE_SECOND), oe(this, "expectedPairingMethodMap", /* @__PURE__ */ new Map()), oe(this, "recentlyDeletedMap", /* @__PURE__ */ new Map()), oe(this, "recentlyDeletedLimit", 200), oe(this, "relayMessageCache", []), oe(this, "pendingSessions", /* @__PURE__ */ new Map()), oe(this, "init", async () => {
      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), await this.registerLinkModeListeners(), this.client.core.pairing.register({ methods: Object.keys(vt) }), this.initialized = true, setTimeout(async () => {
        await this.processPendingMessageEvents(), this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue();
      }, ce.toMiliseconds(this.requestQueueDelay)));
    }), oe(this, "connect", async (t) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      const n = Ot(ze({}, t), { requiredNamespaces: t.requiredNamespaces || {}, optionalNamespaces: t.optionalNamespaces || {} });
      await this.isValidConnect(n), n.optionalNamespaces = HS(n.requiredNamespaces, n.optionalNamespaces), n.requiredNamespaces = {};
      const { pairingTopic: s, requiredNamespaces: i, optionalNamespaces: o, sessionProperties: a, scopedProperties: u, relays: c } = n;
      let l = s, d, h = false;
      try {
        if (l) {
          const k = this.client.core.pairing.pairings.get(l);
          this.client.logger.warn("connect() with existing pairing topic is deprecated and will be removed in the next major release."), h = k.active;
        }
      } catch (k) {
        throw this.client.logger.error(`connect() -> pairing.get(${l}) failed`), k;
      }
      if (!l || !h) {
        const { topic: k, uri: U } = await this.client.core.pairing.create({ internal: { skipSubscribe: true } });
        l = k, d = U;
      }
      if (!l) {
        const { message: k } = ae("NO_MATCHING_KEY", `connect() pairing topic: ${l}`);
        throw new Error(k);
      }
      const f = await this.client.core.crypto.generateKeyPair(), g = vt.wc_sessionPropose.req.ttl || ce.FIVE_MINUTES, p = ot(g), b = Ot(ze(ze({ requiredNamespaces: i, optionalNamespaces: o, relays: c ?? [{ protocol: hw }], proposer: { publicKey: f, metadata: this.client.metadata }, expiryTimestamp: p, pairingTopic: l }, a && { sessionProperties: a }), u && { scopedProperties: u }), { id: Or() }), _ = Le("session_connect", b.id), { reject: D, resolve: v, done: E } = Qn(g, cp), A = ({ id: k }) => {
        k === b.id && (this.client.events.off("proposal_expire", A), this.pendingSessions.delete(b.id), this.events.emit(_, { error: { message: cp, code: 0 } }));
      };
      return this.client.events.on("proposal_expire", A), this.events.once(_, ({ error: k, session: U }) => {
        this.client.events.off("proposal_expire", A), k ? D(k) : U && v(U);
      }), await this.sendProposeSession({ proposal: b, publishOpts: { internal: { throwOnFailedPublish: true }, tvf: { correlationId: b.id } } }), await this.setProposal(b.id, b), { uri: d, approval: E };
    }), oe(this, "pair", async (t) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        return await this.client.core.pairing.pair(t);
      } catch (n) {
        throw this.client.logger.error("pair() failed"), n;
      }
    }), oe(this, "approve", async (t) => {
      var n, s, i;
      const o = this.client.core.eventClient.createEvent({ properties: { topic: (n = t == null ? void 0 : t.id) == null ? void 0 : n.toString(), trace: [yr.session_approve_started] } });
      try {
        this.isInitialized(), await this.confirmOnlineStateOrThrow();
      } catch ($) {
        throw o.setError(Rn.no_internet_connection), $;
      }
      try {
        await this.isValidProposalId(t == null ? void 0 : t.id);
      } catch ($) {
        throw this.client.logger.error(`approve() -> proposal.get(${t == null ? void 0 : t.id}) failed`), o.setError(Rn.proposal_not_found), $;
      }
      try {
        await this.isValidApprove(t);
      } catch ($) {
        throw this.client.logger.error("approve() -> isValidApprove() failed"), o.setError(Rn.session_approve_namespace_validation_failure), $;
      }
      const { id: a, relayProtocol: u, namespaces: c, sessionProperties: l, scopedProperties: d, sessionConfig: h } = t, f = this.client.proposal.get(a);
      this.client.core.eventClient.deleteEvent({ eventId: o.eventId });
      const { pairingTopic: g, proposer: p, requiredNamespaces: b, optionalNamespaces: _ } = f;
      let D = (s = this.client.core.eventClient) == null ? void 0 : s.getEvent({ topic: g });
      D || (D = (i = this.client.core.eventClient) == null ? void 0 : i.createEvent({ type: yr.session_approve_started, properties: { topic: g, trace: [yr.session_approve_started, yr.session_namespaces_validation_success] } }));
      const v = await this.client.core.crypto.generateKeyPair(), E = p.publicKey, A = await this.client.core.crypto.generateSharedKey(v, E), k = ze(ze(ze({ relay: { protocol: u ?? "irn" }, namespaces: c, controller: { publicKey: v, metadata: this.client.metadata }, expiry: ot(Ni) }, l && { sessionProperties: l }), d && { scopedProperties: d }), h && { sessionConfig: h }), U = Ye.relay;
      D.addTrace(yr.subscribing_session_topic);
      try {
        await this.client.core.relayer.subscribe(A, { transportType: U, internal: { skipSubscribe: true } });
      } catch ($) {
        throw D.setError(Rn.subscribe_session_topic_failure), $;
      }
      D.addTrace(yr.subscribe_session_topic_success);
      const P = Ot(ze({}, k), { topic: A, requiredNamespaces: b, optionalNamespaces: _, pairingTopic: g, acknowledged: false, self: k.controller, peer: { publicKey: p.publicKey, metadata: p.metadata }, controller: v, transportType: Ye.relay });
      await this.client.session.set(A, P), D.addTrace(yr.store_session);
      try {
        await this.sendApproveSession({ sessionTopic: A, proposal: f, pairingProposalResponse: { relay: { protocol: u ?? "irn" }, responderPublicKey: v }, sessionSettleRequest: k, publishOpts: { internal: { throwOnFailedPublish: true }, tvf: { correlationId: a } } }), D.addTrace(yr.session_approve_publish_success);
      } catch ($) {
        throw this.client.logger.error($), this.client.session.delete(A, Je("USER_DISCONNECTED")), await this.client.core.relayer.unsubscribe(A), $;
      }
      return this.client.core.eventClient.deleteEvent({ eventId: D.eventId }), await this.client.core.pairing.updateMetadata({ topic: g, metadata: p.metadata }), await this.deleteProposal(a), await this.client.core.pairing.activate({ topic: g }), await this.setExpiry(A, ot(Ni)), { topic: A, acknowledged: () => Promise.resolve(this.client.session.get(A)) };
    }), oe(this, "reject", async (t) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidReject(t);
      } catch (o) {
        throw this.client.logger.error("reject() -> isValidReject() failed"), o;
      }
      const { id: n, reason: s } = t;
      let i;
      try {
        i = this.client.proposal.get(n).pairingTopic;
      } catch (o) {
        throw this.client.logger.error(`reject() -> proposal.get(${n}) failed`), o;
      }
      i && await this.sendError({ id: n, topic: i, error: s, rpcOpts: vt.wc_sessionPropose.reject }), await this.deleteProposal(n);
    }), oe(this, "update", async (t) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidUpdate(t);
      } catch (d) {
        throw this.client.logger.error("update() -> isValidUpdate() failed"), d;
      }
      const { topic: n, namespaces: s } = t, { done: i, resolve: o, reject: a } = Qn(), u = Or(), c = _n().toString(), l = this.client.session.get(n).namespaces;
      return this.events.once(Le("session_update", u), ({ error: d }) => {
        d ? a(d) : o();
      }), await this.client.session.update(n, { namespaces: s }), await this.sendRequest({ topic: n, method: "wc_sessionUpdate", params: { namespaces: s }, throwOnFailedPublish: true, clientRpcId: u, relayRpcId: c }).catch((d) => {
        this.client.logger.error(d), this.client.session.update(n, { namespaces: l }), a(d);
      }), { acknowledged: i };
    }), oe(this, "extend", async (t) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidExtend(t);
      } catch (u) {
        throw this.client.logger.error("extend() -> isValidExtend() failed"), u;
      }
      const { topic: n } = t, s = Or(), { done: i, resolve: o, reject: a } = Qn();
      return this.events.once(Le("session_extend", s), ({ error: u }) => {
        u ? a(u) : o();
      }), await this.setExpiry(n, ot(Ni)), this.sendRequest({ topic: n, method: "wc_sessionExtend", params: {}, clientRpcId: s, throwOnFailedPublish: true }).catch((u) => {
        a(u);
      }), { acknowledged: i };
    }), oe(this, "request", async (t) => {
      this.isInitialized();
      try {
        await this.isValidRequest(t);
      } catch (b) {
        throw this.client.logger.error("request() -> isValidRequest() failed"), b;
      }
      const { chainId: n, request: s, topic: i, expiry: o = vt.wc_sessionRequest.req.ttl } = t, a = this.client.session.get(i);
      (a == null ? void 0 : a.transportType) === Ye.relay && await this.confirmOnlineStateOrThrow();
      const u = Or(), c = _n().toString(), { done: l, resolve: d, reject: h } = Qn(o, "Request expired. Please try again.");
      this.events.once(Le("session_request", u), ({ error: b, result: _ }) => {
        b ? h(b) : d(_);
      });
      const f = "wc_sessionRequest", g = this.getAppLinkIfEnabled(a.peer.metadata, a.transportType);
      if (g) return await this.sendRequest({ clientRpcId: u, relayRpcId: c, topic: i, method: f, params: { request: Ot(ze({}, s), { expiryTimestamp: ot(o) }), chainId: n }, expiry: o, throwOnFailedPublish: true, appLink: g }).catch((b) => h(b)), this.client.events.emit("session_request_sent", { topic: i, request: s, chainId: n, id: u }), await l();
      const p = { request: Ot(ze({}, s), { expiryTimestamp: ot(o) }), chainId: n };
      return await Promise.all([new Promise(async (b) => {
        await this.sendRequest({ clientRpcId: u, relayRpcId: c, topic: i, method: f, params: p, expiry: o, throwOnFailedPublish: true, tvf: this.getTVFParams(u, p) }).catch((_) => h(_)), this.client.events.emit("session_request_sent", { topic: i, request: s, chainId: n, id: u }), b();
      }), new Promise(async (b) => {
        var _;
        if (!((_ = a.sessionConfig) != null && _.disableDeepLink)) {
          const D = await LA(this.client.core.storage, ap);
          await SA({ id: u, topic: i, wcDeepLink: D });
        }
        b();
      }), l()]).then((b) => b[2]);
    }), oe(this, "respond", async (t) => {
      var n, s;
      this.isInitialized();
      const i = this.client.core.eventClient.createEvent({ properties: { topic: (t == null ? void 0 : t.topic) || ((s = (n = t == null ? void 0 : t.response) == null ? void 0 : n.id) == null ? void 0 : s.toString()), trace: [yr.session_request_response_started] } });
      try {
        await this.isValidRespond(t);
      } catch (d) {
        throw i.addTrace(d == null ? void 0 : d.message), i.setError(Rn.session_request_response_validation_failure), d;
      }
      i.addTrace(yr.session_request_response_validation_success);
      const { topic: o, response: a } = t, { id: u } = a, c = this.client.session.get(o);
      c.transportType === Ye.relay && await this.confirmOnlineStateOrThrow();
      const l = this.getAppLinkIfEnabled(c.peer.metadata, c.transportType);
      try {
        i.addTrace(yr.session_request_response_publish_started), Sr(a) ? await this.sendResult({ id: u, topic: o, result: a.result, throwOnFailedPublish: true, appLink: l }) : lr(a) && await this.sendError({ id: u, topic: o, error: a.error, appLink: l }), this.cleanupAfterResponse(t);
      } catch (d) {
        throw i.addTrace(d == null ? void 0 : d.message), i.setError(Rn.session_request_response_publish_failure), d;
      }
    }), oe(this, "ping", async (t) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidPing(t);
      } catch (s) {
        throw this.client.logger.error("ping() -> isValidPing() failed"), s;
      }
      const { topic: n } = t;
      if (this.client.session.keys.includes(n)) {
        const s = Or(), i = _n().toString(), { done: o, resolve: a, reject: u } = Qn();
        this.events.once(Le("session_ping", s), ({ error: c }) => {
          c ? u(c) : a();
        }), await Promise.all([this.sendRequest({ topic: n, method: "wc_sessionPing", params: {}, throwOnFailedPublish: true, clientRpcId: s, relayRpcId: i }), o()]);
      } else this.client.core.pairing.pairings.keys.includes(n) && (this.client.logger.warn("ping() on pairing topic is deprecated and will be removed in the next major release."), await this.client.core.pairing.ping({ topic: n }));
    }), oe(this, "emit", async (t) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidEmit(t);
      const { topic: n, event: s, chainId: i } = t, o = _n().toString(), a = Or();
      await this.sendRequest({ topic: n, method: "wc_sessionEvent", params: { event: s, chainId: i }, throwOnFailedPublish: true, relayRpcId: o, clientRpcId: a });
    }), oe(this, "disconnect", async (t) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidDisconnect(t);
      const { topic: n } = t;
      if (this.client.session.keys.includes(n)) await this.sendRequest({ topic: n, method: "wc_sessionDelete", params: Je("USER_DISCONNECTED"), throwOnFailedPublish: true }), await this.deleteSession({ topic: n, emitEvent: false });
      else if (this.client.core.pairing.pairings.keys.includes(n)) await this.client.core.pairing.disconnect({ topic: n });
      else {
        const { message: s } = ae("MISMATCHED_TOPIC", `Session or pairing topic not found: ${n}`);
        throw new Error(s);
      }
    }), oe(this, "find", (t) => (this.isInitialized(), this.client.session.getAll().filter((n) => KS(n, t)))), oe(this, "getPendingSessionRequests", () => this.client.pendingRequest.getAll()), oe(this, "authenticate", async (t, n) => {
      var s;
      this.isInitialized(), this.isValidAuthenticate(t);
      const i = n && this.client.core.linkModeSupportedApps.includes(n) && ((s = this.client.metadata.redirect) == null ? void 0 : s.linkMode), o = i ? Ye.link_mode : Ye.relay;
      o === Ye.relay && await this.confirmOnlineStateOrThrow();
      const { chains: a, statement: u = "", uri: c, domain: l, nonce: d, type: h, exp: f, nbf: g, methods: p = [], expiry: b } = t, _ = [...t.resources || []], { topic: D, uri: v } = await this.client.core.pairing.create({ methods: ["wc_sessionAuthenticate"], transportType: o });
      this.client.logger.info({ message: "Generated new pairing", pairing: { topic: D, uri: v } });
      const E = await this.client.core.crypto.generateKeyPair(), A = Ao(E);
      if (await Promise.all([this.client.auth.authKeys.set(So, { responseTopic: A, publicKey: E }), this.client.auth.pairingTopics.set(A, { topic: A, pairingTopic: D })]), await this.client.core.relayer.subscribe(A, { transportType: o }), this.client.logger.info(`sending request to new pairing topic: ${D}`), p.length > 0) {
        const { namespace: N } = Do(a[0]);
        let T = K4(N, "request", p);
        To(_) && (T = Z4(T, _.pop())), _.push(T);
      }
      const k = b && b > vt.wc_sessionAuthenticate.req.ttl ? b : vt.wc_sessionAuthenticate.req.ttl, U = { authPayload: { type: h ?? "caip122", chains: a, statement: u, aud: c, domain: l, version: "1", nonce: d, iat: (/* @__PURE__ */ new Date()).toISOString(), exp: f, nbf: g, resources: _ }, requester: { publicKey: E, metadata: this.client.metadata }, expiryTimestamp: ot(k) }, P = { eip155: { chains: a, methods: [.../* @__PURE__ */ new Set(["personal_sign", ...p])], events: ["chainChanged", "accountsChanged"] } }, $ = { requiredNamespaces: {}, optionalNamespaces: P, relays: [{ protocol: "irn" }], pairingTopic: D, proposer: { publicKey: E, metadata: this.client.metadata }, expiryTimestamp: ot(vt.wc_sessionPropose.req.ttl), id: Or() }, { done: ee, resolve: G, reject: H } = Qn(k, "Request expired"), R = Or(), z = Le("session_connect", $.id), j = Le("session_request", R), I = async ({ error: N, session: T }) => {
        this.events.off(j, y), N ? H(N) : T && G({ session: T });
      }, y = async (N) => {
        var T, x, L;
        if (await this.deletePendingAuthRequest(R, { message: "fulfilled", code: 0 }), N.error) {
          const se = Je("WC_METHOD_UNSUPPORTED", "wc_sessionAuthenticate");
          return N.error.code === se.code ? void 0 : (this.events.off(z, I), H(N.error.message));
        }
        await this.deleteProposal($.id), this.events.off(z, I);
        const { cacaos: V, responder: q } = N.result, K = [], Z = [];
        for (const se of V) {
          await Kh({ cacao: se, projectId: this.client.core.projectId }) || (this.client.logger.error(se, "Signature verification failed"), H(Je("SESSION_SETTLEMENT_FAILED", "Signature verification failed")));
          const { p: ue } = se, he = To(ue.resources), Q = [Au(ue.iss)], X = Go(ue.iss);
          if (he) {
            const Y = Xh(he), J = Zh(he);
            K.push(...Y), Q.push(...J);
          }
          for (const Y of Q) Z.push(`${Y}:${X}`);
        }
        const re = await this.client.core.crypto.generateSharedKey(E, q.publicKey);
        let ne;
        K.length > 0 && (ne = { topic: re, acknowledged: true, self: { publicKey: E, metadata: this.client.metadata }, peer: q, controller: q.publicKey, expiry: ot(Ni), requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: D, namespaces: If([...new Set(K)], [...new Set(Z)]), transportType: o }, await this.client.core.relayer.subscribe(re, { transportType: o }), await this.client.session.set(re, ne), D && await this.client.core.pairing.updateMetadata({ topic: D, metadata: q.metadata }), ne = this.client.session.get(re)), (T = this.client.metadata.redirect) != null && T.linkMode && (x = q.metadata.redirect) != null && x.linkMode && (L = q.metadata.redirect) != null && L.universal && n && (this.client.core.addLinkModeSupportedApp(q.metadata.redirect.universal), this.client.session.update(re, { transportType: Ye.link_mode })), G({ auths: V, session: ne });
      };
      this.events.once(z, I), this.events.once(j, y);
      let m;
      try {
        if (i) {
          const N = Gr("wc_sessionAuthenticate", U, R);
          this.client.core.history.set(D, N);
          const T = await this.client.core.crypto.encode("", N, { type: Ys, encoding: Nn });
          m = vo(n, D, T);
        } else await Promise.all([this.sendRequest({ topic: D, method: "wc_sessionAuthenticate", params: U, expiry: t.expiry, throwOnFailedPublish: true, clientRpcId: R }), this.sendRequest({ topic: D, method: "wc_sessionPropose", params: $, expiry: vt.wc_sessionPropose.req.ttl, throwOnFailedPublish: true, clientRpcId: $.id })]);
      } catch (N) {
        throw this.events.off(z, I), this.events.off(j, y), N;
      }
      return await this.setProposal($.id, $), await this.setAuthRequest(R, { request: Ot(ze({}, U), { verifyContext: {} }), pairingTopic: D, transportType: o }), { uri: m ?? v, response: ee };
    }), oe(this, "approveSessionAuthenticate", async (t) => {
      const { id: n, auths: s } = t, i = this.client.core.eventClient.createEvent({ properties: { topic: n.toString(), trace: [$n.authenticated_session_approve_started] } });
      try {
        this.isInitialized();
      } catch (b) {
        throw i.setError(ls.no_internet_connection), b;
      }
      const o = this.getPendingAuthRequest(n);
      if (!o) throw i.setError(ls.authenticated_session_pending_request_not_found), new Error(`Could not find pending auth request with id ${n}`);
      const a = o.transportType || Ye.relay;
      a === Ye.relay && await this.confirmOnlineStateOrThrow();
      const u = o.requester.publicKey, c = await this.client.core.crypto.generateKeyPair(), l = Ao(u), d = { type: Zr, receiverPublicKey: u, senderPublicKey: c }, h = [], f = [];
      for (const b of s) {
        if (!await Kh({ cacao: b, projectId: this.client.core.projectId })) {
          i.setError(ls.invalid_cacao);
          const A = Je("SESSION_SETTLEMENT_FAILED", "Signature verification failed");
          throw await this.sendError({ id: n, topic: l, error: A, encodeOpts: d }), new Error(A.message);
        }
        i.addTrace($n.cacaos_verified);
        const { p: _ } = b, D = To(_.resources), v = [Au(_.iss)], E = Go(_.iss);
        if (D) {
          const A = Xh(D), k = Zh(D);
          h.push(...A), v.push(...k);
        }
        for (const A of v) f.push(`${A}:${E}`);
      }
      const g = await this.client.core.crypto.generateSharedKey(c, u);
      i.addTrace($n.create_authenticated_session_topic);
      let p;
      if ((h == null ? void 0 : h.length) > 0) {
        p = { topic: g, acknowledged: true, self: { publicKey: c, metadata: this.client.metadata }, peer: { publicKey: u, metadata: o.requester.metadata }, controller: u, expiry: ot(Ni), authentication: s, requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: o.pairingTopic, namespaces: If([...new Set(h)], [...new Set(f)]), transportType: a }, i.addTrace($n.subscribing_authenticated_session_topic);
        try {
          await this.client.core.relayer.subscribe(g, { transportType: a });
        } catch (b) {
          throw i.setError(ls.subscribe_authenticated_session_topic_failure), b;
        }
        i.addTrace($n.subscribe_authenticated_session_topic_success), await this.client.session.set(g, p), i.addTrace($n.store_authenticated_session), await this.client.core.pairing.updateMetadata({ topic: o.pairingTopic, metadata: o.requester.metadata });
      }
      i.addTrace($n.publishing_authenticated_session_approve);
      try {
        await this.sendResult({ topic: l, id: n, result: { cacaos: s, responder: { publicKey: c, metadata: this.client.metadata } }, encodeOpts: d, throwOnFailedPublish: true, appLink: this.getAppLinkIfEnabled(o.requester.metadata, a) });
      } catch (b) {
        throw i.setError(ls.authenticated_session_approve_publish_failure), b;
      }
      return await this.client.auth.requests.delete(n, { message: "fulfilled", code: 0 }), await this.client.core.pairing.activate({ topic: o.pairingTopic }), this.client.core.eventClient.deleteEvent({ eventId: i.eventId }), { session: p };
    }), oe(this, "rejectSessionAuthenticate", async (t) => {
      this.isInitialized();
      const { id: n, reason: s } = t, i = this.getPendingAuthRequest(n);
      if (!i) throw new Error(`Could not find pending auth request with id ${n}`);
      i.transportType === Ye.relay && await this.confirmOnlineStateOrThrow();
      const o = i.requester.publicKey, a = await this.client.core.crypto.generateKeyPair(), u = Ao(o), c = { type: Zr, receiverPublicKey: o, senderPublicKey: a };
      await this.sendError({ id: n, topic: u, error: s, encodeOpts: c, rpcOpts: vt.wc_sessionAuthenticate.reject, appLink: this.getAppLinkIfEnabled(i.requester.metadata, i.transportType) }), await this.client.auth.requests.delete(n, { message: "rejected", code: 0 }), await this.deleteProposal(n);
    }), oe(this, "formatAuthMessage", (t) => {
      this.isInitialized();
      const { request: n, iss: s } = t;
      return vy(n, s);
    }), oe(this, "processRelayMessageCache", () => {
      setTimeout(async () => {
        if (this.relayMessageCache.length !== 0) for (; this.relayMessageCache.length > 0; ) try {
          const t = this.relayMessageCache.shift();
          t && await this.onRelayMessage(t);
        } catch (t) {
          this.client.logger.error(t);
        }
      }, 50);
    }), oe(this, "cleanupDuplicatePairings", async (t) => {
      if (t.pairingTopic) try {
        const n = this.client.core.pairing.pairings.get(t.pairingTopic), s = this.client.core.pairing.pairings.getAll().filter((i) => {
          var o, a;
          return ((o = i.peerMetadata) == null ? void 0 : o.url) && ((a = i.peerMetadata) == null ? void 0 : a.url) === t.peer.metadata.url && i.topic && i.topic !== n.topic;
        });
        if (s.length === 0) return;
        this.client.logger.info(`Cleaning up ${s.length} duplicate pairing(s)`), await Promise.all(s.map((i) => this.client.core.pairing.disconnect({ topic: i.topic }))), this.client.logger.info("Duplicate pairings clean up finished");
      } catch (n) {
        this.client.logger.error(n);
      }
    }), oe(this, "deleteSession", async (t) => {
      var n;
      const { topic: s, expirerHasDeleted: i = false, emitEvent: o = true, id: a = 0 } = t, { self: u } = this.client.session.get(s);
      await this.client.core.relayer.unsubscribe(s), await this.client.session.delete(s, Je("USER_DISCONNECTED")), this.addToRecentlyDeleted(s, "session"), this.client.core.crypto.keychain.has(u.publicKey) && await this.client.core.crypto.deleteKeyPair(u.publicKey), this.client.core.crypto.keychain.has(s) && await this.client.core.crypto.deleteSymKey(s), i || this.client.core.expirer.del(s), this.client.core.storage.removeItem(ap).catch((c) => this.client.logger.warn(c)), this.getPendingSessionRequests().forEach((c) => {
        c.topic === s && this.deletePendingSessionRequest(c.id, Je("USER_DISCONNECTED"));
      }), s === ((n = this.sessionRequestQueue.queue[0]) == null ? void 0 : n.topic) && (this.sessionRequestQueue.state = Dr.idle), o && this.client.events.emit("session_delete", { id: a, topic: s });
    }), oe(this, "deleteProposal", async (t, n) => {
      if (n) try {
        const s = this.client.proposal.get(t), i = this.client.core.eventClient.getEvent({ topic: s.pairingTopic });
        i == null || i.setError(Rn.proposal_expired);
      } catch {
      }
      await Promise.all([this.client.proposal.delete(t, Je("USER_DISCONNECTED")), n ? Promise.resolve() : this.client.core.expirer.del(t)]), this.addToRecentlyDeleted(t, "proposal");
    }), oe(this, "deletePendingSessionRequest", async (t, n, s = false) => {
      await Promise.all([this.client.pendingRequest.delete(t, n), s ? Promise.resolve() : this.client.core.expirer.del(t)]), this.addToRecentlyDeleted(t, "request"), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter((i) => i.id !== t), s && (this.sessionRequestQueue.state = Dr.idle, this.client.events.emit("session_request_expire", { id: t }));
    }), oe(this, "deletePendingAuthRequest", async (t, n, s = false) => {
      await Promise.all([this.client.auth.requests.delete(t, n), s ? Promise.resolve() : this.client.core.expirer.del(t)]);
    }), oe(this, "setExpiry", async (t, n) => {
      this.client.session.keys.includes(t) && (this.client.core.expirer.set(t, n), await this.client.session.update(t, { expiry: n }));
    }), oe(this, "setProposal", async (t, n) => {
      this.client.core.expirer.set(t, ot(vt.wc_sessionPropose.req.ttl)), await this.client.proposal.set(t, n);
    }), oe(this, "setAuthRequest", async (t, n) => {
      const { request: s, pairingTopic: i, transportType: o = Ye.relay } = n;
      this.client.core.expirer.set(t, s.expiryTimestamp), await this.client.auth.requests.set(t, { authPayload: s.authPayload, requester: s.requester, expiryTimestamp: s.expiryTimestamp, id: t, pairingTopic: i, verifyContext: s.verifyContext, transportType: o });
    }), oe(this, "setPendingSessionRequest", async (t) => {
      const { id: n, topic: s, params: i, verifyContext: o } = t, a = i.request.expiryTimestamp || ot(vt.wc_sessionRequest.req.ttl);
      this.client.core.expirer.set(n, a), await this.client.pendingRequest.set(n, { id: n, topic: s, params: i, verifyContext: o });
    }), oe(this, "sendRequest", async (t) => {
      const { topic: n, method: s, params: i, expiry: o, relayRpcId: a, clientRpcId: u, throwOnFailedPublish: c, appLink: l, tvf: d, publishOpts: h = {} } = t, f = Gr(s, i, u);
      let g;
      const p = !!l;
      try {
        const D = p ? Nn : qt;
        g = await this.client.core.crypto.encode(n, f, { encoding: D });
      } catch (D) {
        throw await this.cleanup(), this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${n} failed`), D;
      }
      let b;
      if (qL.includes(s)) {
        const D = ur(JSON.stringify(f)), v = ur(g);
        b = await this.client.core.verify.register({ id: v, decryptedId: D });
      }
      const _ = ze(ze({}, vt[s].req), h);
      if (_.attestation = b, o && (_.ttl = o), a && (_.id = a), this.client.core.history.set(n, f), p) {
        const D = vo(l, n, g);
        await global.Linking.openURL(D, this.client.name);
      } else _.tvf = Ot(ze({}, d), { correlationId: f.id }), c ? (_.internal = Ot(ze({}, _.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(n, g, _)) : this.client.core.relayer.publish(n, g, _).catch((D) => this.client.logger.error(D));
      return f.id;
    }), oe(this, "sendProposeSession", async (t) => {
      const { proposal: n, publishOpts: s } = t, i = Gr("wc_sessionPropose", n, n.id);
      this.client.core.history.set(n.pairingTopic, i);
      const o = await this.client.core.crypto.encode(n.pairingTopic, i, { encoding: qt }), a = ur(JSON.stringify(i)), u = ur(o), c = await this.client.core.verify.register({ id: u, decryptedId: a });
      await this.client.core.relayer.publishCustom({ payload: { pairingTopic: n.pairingTopic, sessionProposal: o }, opts: Ot(ze({}, s), { publishMethod: "wc_proposeSession", attestation: c }) });
    }), oe(this, "sendApproveSession", async (t) => {
      const { sessionTopic: n, pairingProposalResponse: s, proposal: i, sessionSettleRequest: o, publishOpts: a } = t, u = ea(i.id, s), c = await this.client.core.crypto.encode(i.pairingTopic, u, { encoding: qt }), l = Gr("wc_sessionSettle", o, a == null ? void 0 : a.id), d = await this.client.core.crypto.encode(n, l, { encoding: qt });
      this.client.core.history.set(n, l), await this.client.core.relayer.publishCustom({ payload: { sessionTopic: n, pairingTopic: i.pairingTopic, sessionProposalResponse: c, sessionSettlementRequest: d }, opts: Ot(ze({}, a), { publishMethod: "wc_approveSession" }) });
    }), oe(this, "sendResult", async (t) => {
      const { id: n, topic: s, result: i, throwOnFailedPublish: o, encodeOpts: a, appLink: u } = t, c = ea(n, i);
      let l;
      const d = u && typeof (global == null ? void 0 : global.Linking) < "u";
      try {
        const g = d ? Nn : qt;
        l = await this.client.core.crypto.encode(s, c, Ot(ze({}, a || {}), { encoding: g }));
      } catch (g) {
        throw await this.cleanup(), this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${s} failed`), g;
      }
      let h, f;
      try {
        h = await this.client.core.history.get(s, n);
        const g = h.request;
        try {
          f = this.getTVFParams(n, g.params, i);
        } catch (p) {
          this.client.logger.warn(`sendResult() -> getTVFParams() failed: ${p == null ? void 0 : p.message}`);
        }
      } catch (g) {
        throw this.client.logger.error(`sendResult() -> history.get(${s}, ${n}) failed`), g;
      }
      if (d) {
        const g = vo(u, s, l);
        await global.Linking.openURL(g, this.client.name);
      } else {
        const g = h.request.method, p = vt[g].res;
        p.tvf = Ot(ze({}, f), { correlationId: n }), o ? (p.internal = Ot(ze({}, p.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(s, l, p)) : this.client.core.relayer.publish(s, l, p).catch((b) => this.client.logger.error(b));
      }
      await this.client.core.history.resolve(c);
    }), oe(this, "sendError", async (t) => {
      const { id: n, topic: s, error: i, encodeOpts: o, rpcOpts: a, appLink: u } = t, c = ql(n, i);
      let l;
      const d = u && typeof (global == null ? void 0 : global.Linking) < "u";
      try {
        const f = d ? Nn : qt;
        l = await this.client.core.crypto.encode(s, c, Ot(ze({}, o || {}), { encoding: f }));
      } catch (f) {
        throw await this.cleanup(), this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${s} failed`), f;
      }
      let h;
      try {
        h = await this.client.core.history.get(s, n);
      } catch (f) {
        throw this.client.logger.error(`sendError() -> history.get(${s}, ${n}) failed`), f;
      }
      if (d) {
        const f = vo(u, s, l);
        await global.Linking.openURL(f, this.client.name);
      } else {
        const f = h.request.method, g = a || vt[f].res;
        this.client.core.relayer.publish(s, l, g);
      }
      await this.client.core.history.resolve(c);
    }), oe(this, "cleanup", async () => {
      const t = [], n = [];
      this.client.session.getAll().forEach((s) => {
        let i = false;
        wn(s.expiry) && (i = true), this.client.core.crypto.keychain.has(s.topic) || (i = true), i && t.push(s.topic);
      }), this.client.proposal.getAll().forEach((s) => {
        wn(s.expiryTimestamp) && n.push(s.id);
      }), await Promise.all([...t.map((s) => this.deleteSession({ topic: s })), ...n.map((s) => this.deleteProposal(s))]);
    }), oe(this, "onProviderMessageEvent", async (t) => {
      !this.initialized || this.relayMessageCache.length > 0 ? this.relayMessageCache.push(t) : await this.onRelayMessage(t);
    }), oe(this, "onRelayEventRequest", async (t) => {
      this.requestQueue.queue.push(t), await this.processRequestsQueue();
    }), oe(this, "processRequestsQueue", async () => {
      if (this.requestQueue.state === Dr.active) {
        this.client.logger.info("Request queue already active, skipping...");
        return;
      }
      for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0; ) {
        this.requestQueue.state = Dr.active;
        const t = this.requestQueue.queue.shift();
        if (t) try {
          await this.processRequest(t);
        } catch (n) {
          this.client.logger.warn(n);
        }
      }
      this.requestQueue.state = Dr.idle;
    }), oe(this, "processRequest", async (t) => {
      const { topic: n, payload: s, attestation: i, transportType: o, encryptedId: a } = t, u = s.method;
      if (!this.shouldIgnorePairingRequest({ topic: n, requestMethod: u })) switch (u) {
        case "wc_sessionPropose":
          return await this.onSessionProposeRequest({ topic: n, payload: s, attestation: i, encryptedId: a });
        case "wc_sessionSettle":
          return await this.onSessionSettleRequest(n, s);
        case "wc_sessionUpdate":
          return await this.onSessionUpdateRequest(n, s);
        case "wc_sessionExtend":
          return await this.onSessionExtendRequest(n, s);
        case "wc_sessionPing":
          return await this.onSessionPingRequest(n, s);
        case "wc_sessionDelete":
          return await this.onSessionDeleteRequest(n, s);
        case "wc_sessionRequest":
          return await this.onSessionRequest({ topic: n, payload: s, attestation: i, encryptedId: a, transportType: o });
        case "wc_sessionEvent":
          return await this.onSessionEventRequest(n, s);
        case "wc_sessionAuthenticate":
          return await this.onSessionAuthenticateRequest({ topic: n, payload: s, attestation: i, encryptedId: a, transportType: o });
        default:
          return this.client.logger.info(`Unsupported request method ${u}`);
      }
    }), oe(this, "onRelayEventResponse", async (t) => {
      const { topic: n, payload: s, transportType: i } = t, o = (await this.client.core.history.get(n, s.id)).request.method;
      switch (o) {
        case "wc_sessionPropose":
          return this.onSessionProposeResponse(n, s, i);
        case "wc_sessionSettle":
          return this.onSessionSettleResponse(n, s);
        case "wc_sessionUpdate":
          return this.onSessionUpdateResponse(n, s);
        case "wc_sessionExtend":
          return this.onSessionExtendResponse(n, s);
        case "wc_sessionPing":
          return this.onSessionPingResponse(n, s);
        case "wc_sessionRequest":
          return this.onSessionRequestResponse(n, s);
        case "wc_sessionAuthenticate":
          return this.onSessionAuthenticateResponse(n, s);
        default:
          return this.client.logger.info(`Unsupported response method ${o}`);
      }
    }), oe(this, "onRelayEventUnknownPayload", (t) => {
      const { topic: n } = t, { message: s } = ae("MISSING_OR_INVALID", `Decoded payload on topic ${n} is not identifiable as a JSON-RPC request or a response.`);
      throw new Error(s);
    }), oe(this, "shouldIgnorePairingRequest", (t) => {
      const { topic: n, requestMethod: s } = t, i = this.expectedPairingMethodMap.get(n);
      return !i || i.includes(s) ? false : !!(i.includes("wc_sessionAuthenticate") && this.client.events.listenerCount("session_authenticate") > 0);
    }), oe(this, "onSessionProposeRequest", async (t) => {
      const { topic: n, payload: s, attestation: i, encryptedId: o } = t, { params: a, id: u } = s;
      try {
        const c = this.client.core.eventClient.getEvent({ topic: n });
        this.client.events.listenerCount("session_proposal") === 0 && (console.warn("No listener for session_proposal event"), c == null || c.setError(qr.proposal_listener_not_found)), this.isValidConnect(ze({}, s.params));
        const l = a.expiryTimestamp || ot(vt.wc_sessionPropose.req.ttl), d = ze({ id: u, pairingTopic: n, expiryTimestamp: l, attestation: i, encryptedId: o }, a);
        await this.setProposal(u, d);
        const h = await this.getVerifyContext({ attestationId: i, hash: ur(JSON.stringify(s)), encryptedId: o, metadata: d.proposer.metadata });
        c == null || c.addTrace(Ar.emit_session_proposal), this.client.events.emit("session_proposal", { id: u, params: d, verifyContext: h });
      } catch (c) {
        await this.sendError({ id: u, topic: n, error: c, rpcOpts: vt.wc_sessionPropose.autoReject }), this.client.logger.error(c);
      }
    }), oe(this, "onSessionProposeResponse", async (t, n, s) => {
      const { id: i } = n;
      if (Sr(n)) {
        const { result: o } = n;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", result: o });
        const a = this.client.proposal.get(i);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", proposal: a });
        const u = a.proposer.publicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", selfPublicKey: u });
        const c = o.responderPublicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", peerPublicKey: c });
        const l = await this.client.core.crypto.generateSharedKey(u, c);
        this.pendingSessions.set(i, { sessionTopic: l, pairingTopic: t, proposalId: i, publicKey: u });
        const d = await this.client.core.relayer.subscribe(l, { transportType: s });
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", subscriptionId: d }), await this.client.core.pairing.activate({ topic: t });
      } else if (lr(n)) {
        await this.deleteProposal(i);
        const o = Le("session_connect", i);
        if (this.events.listenerCount(o) === 0) throw new Error(`emitting ${o} without any listeners, 954`);
        this.events.emit(o, { error: n.error });
      }
    }), oe(this, "onSessionSettleRequest", async (t, n) => {
      const { id: s, params: i } = n;
      try {
        this.isValidSessionSettleRequest(i);
        const { relay: o, controller: a, expiry: u, namespaces: c, sessionProperties: l, scopedProperties: d, sessionConfig: h } = n.params, f = [...this.pendingSessions.values()].find((b) => b.sessionTopic === t);
        if (!f) return this.client.logger.error(`Pending session not found for topic ${t}`);
        const g = this.client.proposal.get(f.proposalId), p = Ot(ze(ze(ze({ topic: t, relay: o, expiry: u, namespaces: c, acknowledged: true, pairingTopic: f.pairingTopic, requiredNamespaces: g.requiredNamespaces, optionalNamespaces: g.optionalNamespaces, controller: a.publicKey, self: { publicKey: f.publicKey, metadata: this.client.metadata }, peer: { publicKey: a.publicKey, metadata: a.metadata } }, l && { sessionProperties: l }), d && { scopedProperties: d }), h && { sessionConfig: h }), { transportType: Ye.relay });
        await this.client.session.set(p.topic, p), await this.setExpiry(p.topic, p.expiry), await this.client.core.pairing.updateMetadata({ topic: f.pairingTopic, metadata: p.peer.metadata }), this.client.events.emit("session_connect", { session: p }), this.events.emit(Le("session_connect", f.proposalId), { session: p }), this.pendingSessions.delete(f.proposalId), this.deleteProposal(f.proposalId, false), this.cleanupDuplicatePairings(p), await this.sendResult({ id: n.id, topic: t, result: true });
      } catch (o) {
        await this.sendError({ id: s, topic: t, error: o }), this.client.logger.error(o);
      }
    }), oe(this, "onSessionSettleResponse", async (t, n) => {
      const { id: s } = n;
      Sr(n) ? (await this.client.session.update(t, { acknowledged: true }), this.events.emit(Le("session_approve", s), {})) : lr(n) && (await this.client.session.delete(t, Je("USER_DISCONNECTED")), this.events.emit(Le("session_approve", s), { error: n.error }));
    }), oe(this, "onSessionUpdateRequest", async (t, n) => {
      const { params: s, id: i } = n;
      try {
        const o = `${t}_session_update`, a = cs.get(o);
        if (a && this.isRequestOutOfSync(a, i)) {
          this.client.logger.warn(`Discarding out of sync request - ${i}`), this.sendError({ id: i, topic: t, error: Je("INVALID_UPDATE_REQUEST") });
          return;
        }
        this.isValidUpdate(ze({ topic: t }, s));
        try {
          cs.set(o, i), await this.client.session.update(t, { namespaces: s.namespaces }), await this.sendResult({ id: i, topic: t, result: true });
        } catch (u) {
          throw cs.delete(o), u;
        }
        this.client.events.emit("session_update", { id: i, topic: t, params: s });
      } catch (o) {
        await this.sendError({ id: i, topic: t, error: o }), this.client.logger.error(o);
      }
    }), oe(this, "isRequestOutOfSync", (t, n) => n.toString().slice(0, -3) < t.toString().slice(0, -3)), oe(this, "onSessionUpdateResponse", (t, n) => {
      const { id: s } = n, i = Le("session_update", s);
      if (this.events.listenerCount(i) === 0) throw new Error(`emitting ${i} without any listeners`);
      Sr(n) ? this.events.emit(Le("session_update", s), {}) : lr(n) && this.events.emit(Le("session_update", s), { error: n.error });
    }), oe(this, "onSessionExtendRequest", async (t, n) => {
      const { id: s } = n;
      try {
        this.isValidExtend({ topic: t }), await this.setExpiry(t, ot(Ni)), await this.sendResult({ id: s, topic: t, result: true }), this.client.events.emit("session_extend", { id: s, topic: t });
      } catch (i) {
        await this.sendError({ id: s, topic: t, error: i }), this.client.logger.error(i);
      }
    }), oe(this, "onSessionExtendResponse", (t, n) => {
      const { id: s } = n, i = Le("session_extend", s);
      if (this.events.listenerCount(i) === 0) throw new Error(`emitting ${i} without any listeners`);
      Sr(n) ? this.events.emit(Le("session_extend", s), {}) : lr(n) && this.events.emit(Le("session_extend", s), { error: n.error });
    }), oe(this, "onSessionPingRequest", async (t, n) => {
      const { id: s } = n;
      try {
        this.isValidPing({ topic: t }), await this.sendResult({ id: s, topic: t, result: true, throwOnFailedPublish: true }), this.client.events.emit("session_ping", { id: s, topic: t });
      } catch (i) {
        await this.sendError({ id: s, topic: t, error: i }), this.client.logger.error(i);
      }
    }), oe(this, "onSessionPingResponse", (t, n) => {
      const { id: s } = n, i = Le("session_ping", s);
      setTimeout(() => {
        if (this.events.listenerCount(i) === 0) throw new Error(`emitting ${i} without any listeners 2176`);
        Sr(n) ? this.events.emit(Le("session_ping", s), {}) : lr(n) && this.events.emit(Le("session_ping", s), { error: n.error });
      }, 500);
    }), oe(this, "onSessionDeleteRequest", async (t, n) => {
      const { id: s } = n;
      try {
        this.isValidDisconnect({ topic: t, reason: n.params }), await Promise.all([new Promise((i) => {
          this.client.core.relayer.once(tt.publish, async () => {
            i(await this.deleteSession({ topic: t, id: s }));
          });
        }), this.sendResult({ id: s, topic: t, result: true }), this.cleanupPendingSentRequestsForTopic({ topic: t, error: Je("USER_DISCONNECTED") })]).catch((i) => this.client.logger.error(i));
      } catch (i) {
        this.client.logger.error(i);
      }
    }), oe(this, "onSessionRequest", async (t) => {
      var n, s, i;
      const { topic: o, payload: a, attestation: u, encryptedId: c, transportType: l } = t, { id: d, params: h } = a;
      try {
        await this.isValidRequest(ze({ topic: o }, h));
        const f = this.client.session.get(o), g = await this.getVerifyContext({ attestationId: u, hash: ur(JSON.stringify(Gr("wc_sessionRequest", h, d))), encryptedId: c, metadata: f.peer.metadata, transportType: l }), p = { id: d, topic: o, params: h, verifyContext: g };
        await this.setPendingSessionRequest(p), l === Ye.link_mode && (n = f.peer.metadata.redirect) != null && n.universal && this.client.core.addLinkModeSupportedApp((s = f.peer.metadata.redirect) == null ? void 0 : s.universal), (i = this.client.signConfig) != null && i.disableRequestQueue ? this.emitSessionRequest(p) : (this.addSessionRequestToSessionRequestQueue(p), this.processSessionRequestQueue());
      } catch (f) {
        await this.sendError({ id: d, topic: o, error: f }), this.client.logger.error(f);
      }
    }), oe(this, "onSessionRequestResponse", (t, n) => {
      const { id: s } = n, i = Le("session_request", s);
      if (this.events.listenerCount(i) === 0) throw new Error(`emitting ${i} without any listeners`);
      Sr(n) ? this.events.emit(Le("session_request", s), { result: n.result }) : lr(n) && this.events.emit(Le("session_request", s), { error: n.error });
    }), oe(this, "onSessionEventRequest", async (t, n) => {
      const { id: s, params: i } = n;
      try {
        const o = `${t}_session_event_${i.event.name}`, a = cs.get(o);
        if (a && this.isRequestOutOfSync(a, s)) {
          this.client.logger.info(`Discarding out of sync request - ${s}`);
          return;
        }
        this.isValidEmit(ze({ topic: t }, i)), this.client.events.emit("session_event", { id: s, topic: t, params: i }), cs.set(o, s);
      } catch (o) {
        await this.sendError({ id: s, topic: t, error: o }), this.client.logger.error(o);
      }
    }), oe(this, "onSessionAuthenticateResponse", (t, n) => {
      const { id: s } = n;
      this.client.logger.trace({ type: "method", method: "onSessionAuthenticateResponse", topic: t, payload: n }), Sr(n) ? this.events.emit(Le("session_request", s), { result: n.result }) : lr(n) && this.events.emit(Le("session_request", s), { error: n.error });
    }), oe(this, "onSessionAuthenticateRequest", async (t) => {
      var n;
      const { topic: s, payload: i, attestation: o, encryptedId: a, transportType: u } = t;
      try {
        const { requester: c, authPayload: l, expiryTimestamp: d } = i.params, h = await this.getVerifyContext({ attestationId: o, hash: ur(JSON.stringify(i)), encryptedId: a, metadata: c.metadata, transportType: u }), f = { requester: c, pairingTopic: s, id: i.id, authPayload: l, verifyContext: h, expiryTimestamp: d };
        await this.setAuthRequest(i.id, { request: f, pairingTopic: s, transportType: u }), u === Ye.link_mode && (n = c.metadata.redirect) != null && n.universal && this.client.core.addLinkModeSupportedApp(c.metadata.redirect.universal), this.client.events.emit("session_authenticate", { topic: s, params: i.params, id: i.id, verifyContext: h });
      } catch (c) {
        this.client.logger.error(c);
        const l = i.params.requester.publicKey, d = await this.client.core.crypto.generateKeyPair(), h = this.getAppLinkIfEnabled(i.params.requester.metadata, u), f = { type: Zr, receiverPublicKey: l, senderPublicKey: d };
        await this.sendError({ id: i.id, topic: s, error: c, encodeOpts: f, rpcOpts: vt.wc_sessionAuthenticate.autoReject, appLink: h });
      }
    }), oe(this, "addSessionRequestToSessionRequestQueue", (t) => {
      this.sessionRequestQueue.queue.push(t);
    }), oe(this, "cleanupAfterResponse", (t) => {
      this.deletePendingSessionRequest(t.response.id, { message: "fulfilled", code: 0 }), setTimeout(() => {
        this.sessionRequestQueue.state = Dr.idle, this.processSessionRequestQueue();
      }, ce.toMiliseconds(this.requestQueueDelay));
    }), oe(this, "cleanupPendingSentRequestsForTopic", ({ topic: t, error: n }) => {
      const s = this.client.core.history.pending;
      s.length > 0 && s.filter((i) => i.topic === t && i.request.method === "wc_sessionRequest").forEach((i) => {
        const o = i.request.id, a = Le("session_request", o);
        if (this.events.listenerCount(a) === 0) throw new Error(`emitting ${a} without any listeners`);
        this.events.emit(Le("session_request", i.request.id), { error: n });
      });
    }), oe(this, "processSessionRequestQueue", () => {
      if (this.sessionRequestQueue.state === Dr.active) {
        this.client.logger.info("session request queue is already active.");
        return;
      }
      const t = this.sessionRequestQueue.queue[0];
      if (!t) {
        this.client.logger.info("session request queue is empty.");
        return;
      }
      try {
        this.emitSessionRequest(t);
      } catch (n) {
        this.client.logger.error(n);
      }
    }), oe(this, "emitSessionRequest", (t) => {
      if (this.emittedSessionRequests.has(t.id)) {
        this.client.logger.warn({ id: t.id }, `Skipping emitting \`session_request\` event for duplicate request. id: ${t.id}`);
        return;
      }
      this.sessionRequestQueue.state = Dr.active, this.emittedSessionRequests.add(t.id), this.client.events.emit("session_request", t);
    }), oe(this, "onPairingCreated", (t) => {
      if (t.methods && this.expectedPairingMethodMap.set(t.topic, t.methods), t.active) return;
      const n = this.client.proposal.getAll().find((s) => s.pairingTopic === t.topic);
      n && this.onSessionProposeRequest({ topic: t.topic, payload: Gr("wc_sessionPropose", Ot(ze({}, n), { requiredNamespaces: n.requiredNamespaces, optionalNamespaces: n.optionalNamespaces, relays: n.relays, proposer: n.proposer, sessionProperties: n.sessionProperties, scopedProperties: n.scopedProperties }), n.id), attestation: n.attestation, encryptedId: n.encryptedId });
    }), oe(this, "isValidConnect", async (t) => {
      if (!$t(t)) {
        const { message: c } = ae("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(t)}`);
        throw new Error(c);
      }
      const { pairingTopic: n, requiredNamespaces: s, optionalNamespaces: i, sessionProperties: o, scopedProperties: a, relays: u } = t;
      if (ut(n) || await this.isValidPairingTopic(n), !c3(u)) {
        const { message: c } = ae("MISSING_OR_INVALID", `connect() relays: ${u}`);
        throw new Error(c);
      }
      if (s && !ut(s) && js(s) !== 0) {
        const c = "requiredNamespaces are deprecated and are automatically assigned to optionalNamespaces";
        ["fatal", "error", "silent"].includes(this.client.logger.level) ? console.warn(c) : this.client.logger.warn(c), this.validateNamespaces(s, "requiredNamespaces");
      }
      if (i && !ut(i) && js(i) !== 0 && this.validateNamespaces(i, "optionalNamespaces"), o && !ut(o) && this.validateSessionProps(o, "sessionProperties"), a && !ut(a)) {
        this.validateSessionProps(a, "scopedProperties");
        const c = Object.keys(s || {}).concat(Object.keys(i || {}));
        if (!Object.keys(a).every((l) => c.includes(l.split(":")[0]))) throw new Error(`Scoped properties must be a subset of required/optional namespaces, received: ${JSON.stringify(a)}, required/optional namespaces: ${JSON.stringify(c)}`);
      }
    }), oe(this, "validateNamespaces", (t, n) => {
      const s = a3(t, "connect()", n);
      if (s) throw new Error(s.message);
    }), oe(this, "isValidApprove", async (t) => {
      if (!$t(t)) throw new Error(ae("MISSING_OR_INVALID", `approve() params: ${t}`).message);
      const { id: n, namespaces: s, relayProtocol: i, sessionProperties: o, scopedProperties: a } = t;
      this.checkRecentlyDeleted(n), await this.isValidProposalId(n);
      const u = this.client.proposal.get(n), c = Wc(s, "approve()");
      if (c) throw new Error(c.message);
      const l = Tf(u.requiredNamespaces, s, "approve()");
      if (l) throw new Error(l.message);
      if (!it(i, true)) {
        const { message: d } = ae("MISSING_OR_INVALID", `approve() relayProtocol: ${i}`);
        throw new Error(d);
      }
      if (o && !ut(o) && this.validateSessionProps(o, "sessionProperties"), a && !ut(a)) {
        this.validateSessionProps(a, "scopedProperties");
        const d = new Set(Object.keys(s));
        if (!Object.keys(a).every((h) => d.has(h.split(":")[0]))) throw new Error(`Scoped properties must be a subset of approved namespaces, received: ${JSON.stringify(a)}, approved namespaces: ${Array.from(d).join(", ")}`);
      }
    }), oe(this, "isValidReject", async (t) => {
      if (!$t(t)) {
        const { message: i } = ae("MISSING_OR_INVALID", `reject() params: ${t}`);
        throw new Error(i);
      }
      const { id: n, reason: s } = t;
      if (this.checkRecentlyDeleted(n), await this.isValidProposalId(n), !l3(s)) {
        const { message: i } = ae("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(s)}`);
        throw new Error(i);
      }
    }), oe(this, "isValidSessionSettleRequest", (t) => {
      if (!$t(t)) {
        const { message: c } = ae("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${t}`);
        throw new Error(c);
      }
      const { relay: n, controller: s, namespaces: i, expiry: o } = t;
      if (!iw(n)) {
        const { message: c } = ae("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
        throw new Error(c);
      }
      const a = t3(s, "onSessionSettleRequest()");
      if (a) throw new Error(a.message);
      const u = Wc(i, "onSessionSettleRequest()");
      if (u) throw new Error(u.message);
      if (wn(o)) {
        const { message: c } = ae("EXPIRED", "onSessionSettleRequest()");
        throw new Error(c);
      }
    }), oe(this, "isValidUpdate", async (t) => {
      if (!$t(t)) {
        const { message: u } = ae("MISSING_OR_INVALID", `update() params: ${t}`);
        throw new Error(u);
      }
      const { topic: n, namespaces: s } = t;
      this.checkRecentlyDeleted(n), await this.isValidSessionTopic(n);
      const i = this.client.session.get(n), o = Wc(s, "update()");
      if (o) throw new Error(o.message);
      const a = Tf(i.requiredNamespaces, s, "update()");
      if (a) throw new Error(a.message);
    }), oe(this, "isValidExtend", async (t) => {
      if (!$t(t)) {
        const { message: s } = ae("MISSING_OR_INVALID", `extend() params: ${t}`);
        throw new Error(s);
      }
      const { topic: n } = t;
      this.checkRecentlyDeleted(n), await this.isValidSessionTopic(n);
    }), oe(this, "isValidRequest", async (t) => {
      if (!$t(t)) {
        const { message: u } = ae("MISSING_OR_INVALID", `request() params: ${t}`);
        throw new Error(u);
      }
      const { topic: n, request: s, chainId: i, expiry: o } = t;
      this.checkRecentlyDeleted(n), await this.isValidSessionTopic(n);
      const { namespaces: a } = this.client.session.get(n);
      if (!Df(a, i)) {
        const { message: u } = ae("MISSING_OR_INVALID", `request() chainId: ${i}`);
        throw new Error(u);
      }
      if (!d3(s)) {
        const { message: u } = ae("MISSING_OR_INVALID", `request() ${JSON.stringify(s)}`);
        throw new Error(u);
      }
      if (!p3(a, i, s.method)) {
        const { message: u } = ae("MISSING_OR_INVALID", `request() method: ${s.method}`);
        throw new Error(u);
      }
      if (o && !m3(o, tu)) {
        const { message: u } = ae("MISSING_OR_INVALID", `request() expiry: ${o}. Expiry must be a number (in seconds) between ${tu.min} and ${tu.max}`);
        throw new Error(u);
      }
    }), oe(this, "isValidRespond", async (t) => {
      var n;
      if (!$t(t)) {
        const { message: a } = ae("MISSING_OR_INVALID", `respond() params: ${t}`);
        throw new Error(a);
      }
      const { topic: s, response: i } = t;
      try {
        await this.isValidSessionTopic(s);
      } catch (a) {
        throw (n = t == null ? void 0 : t.response) != null && n.id && this.cleanupAfterResponse(t), a;
      }
      if (!h3(i)) {
        const { message: a } = ae("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(i)}`);
        throw new Error(a);
      }
      const o = this.client.pendingRequest.get(i.id);
      if (o.topic !== s) {
        const { message: a } = ae("MISMATCHED_TOPIC", `Request response topic mismatch. reqId: ${i.id}, expected topic: ${o.topic}, received topic: ${s}`);
        throw new Error(a);
      }
    }), oe(this, "isValidPing", async (t) => {
      if (!$t(t)) {
        const { message: s } = ae("MISSING_OR_INVALID", `ping() params: ${t}`);
        throw new Error(s);
      }
      const { topic: n } = t;
      await this.isValidSessionOrPairingTopic(n);
    }), oe(this, "isValidEmit", async (t) => {
      if (!$t(t)) {
        const { message: a } = ae("MISSING_OR_INVALID", `emit() params: ${t}`);
        throw new Error(a);
      }
      const { topic: n, event: s, chainId: i } = t;
      await this.isValidSessionTopic(n);
      const { namespaces: o } = this.client.session.get(n);
      if (!Df(o, i)) {
        const { message: a } = ae("MISSING_OR_INVALID", `emit() chainId: ${i}`);
        throw new Error(a);
      }
      if (!f3(s)) {
        const { message: a } = ae("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(s)}`);
        throw new Error(a);
      }
      if (!g3(o, i, s.name)) {
        const { message: a } = ae("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(s)}`);
        throw new Error(a);
      }
    }), oe(this, "isValidDisconnect", async (t) => {
      if (!$t(t)) {
        const { message: s } = ae("MISSING_OR_INVALID", `disconnect() params: ${t}`);
        throw new Error(s);
      }
      const { topic: n } = t;
      await this.isValidSessionOrPairingTopic(n);
    }), oe(this, "isValidAuthenticate", (t) => {
      const { chains: n, uri: s, domain: i, nonce: o } = t;
      if (!Array.isArray(n) || n.length === 0) throw new Error("chains is required and must be a non-empty array");
      if (!it(s, false)) throw new Error("uri is required parameter");
      if (!it(i, false)) throw new Error("domain is required parameter");
      if (!it(o, false)) throw new Error("nonce is required parameter");
      if ([...new Set(n.map((u) => Do(u).namespace))].length > 1) throw new Error("Multi-namespace requests are not supported. Please request single namespace only.");
      const { namespace: a } = Do(n[0]);
      if (a !== "eip155") throw new Error("Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.");
    }), oe(this, "getVerifyContext", async (t) => {
      const { attestationId: n, hash: s, encryptedId: i, metadata: o, transportType: a } = t, u = { verified: { verifyUrl: o.verifyUrl || Ms, validation: "UNKNOWN", origin: o.url || "" } };
      try {
        if (a === Ye.link_mode) {
          const l = this.getAppLinkIfEnabled(o, a);
          return u.verified.validation = l && new URL(l).origin === new URL(o.url).origin ? "VALID" : "INVALID", u;
        }
        const c = await this.client.core.verify.resolve({ attestationId: n, hash: s, encryptedId: i, verifyUrl: o.verifyUrl });
        c && (u.verified.origin = c.origin, u.verified.isScam = c.isScam, u.verified.validation = c.origin === new URL(o.url).origin ? "VALID" : "INVALID");
      } catch (c) {
        this.client.logger.warn(c);
      }
      return this.client.logger.debug(`Verify context: ${JSON.stringify(u)}`), u;
    }), oe(this, "validateSessionProps", (t, n) => {
      Object.values(t).forEach((s, i) => {
        if (s == null) {
          const { message: o } = ae("MISSING_OR_INVALID", `${n} must contain an existing value for each key. Received: ${s} for key ${Object.keys(t)[i]}`);
          throw new Error(o);
        }
      });
    }), oe(this, "getPendingAuthRequest", (t) => {
      const n = this.client.auth.requests.get(t);
      return typeof n == "object" ? n : void 0;
    }), oe(this, "addToRecentlyDeleted", (t, n) => {
      if (this.recentlyDeletedMap.set(t, n), this.recentlyDeletedMap.size >= this.recentlyDeletedLimit) {
        let s = 0;
        const i = this.recentlyDeletedLimit / 2;
        for (const o of this.recentlyDeletedMap.keys()) {
          if (s++ >= i) break;
          this.recentlyDeletedMap.delete(o);
        }
      }
    }), oe(this, "checkRecentlyDeleted", (t) => {
      const n = this.recentlyDeletedMap.get(t);
      if (n) {
        const { message: s } = ae("MISSING_OR_INVALID", `Record was recently deleted - ${n}: ${t}`);
        throw new Error(s);
      }
    }), oe(this, "isLinkModeEnabled", (t, n) => {
      var s, i, o, a, u, c, l, d, h;
      return !t || n !== Ye.link_mode ? false : ((i = (s = this.client.metadata) == null ? void 0 : s.redirect) == null ? void 0 : i.linkMode) === true && ((a = (o = this.client.metadata) == null ? void 0 : o.redirect) == null ? void 0 : a.universal) !== void 0 && ((c = (u = this.client.metadata) == null ? void 0 : u.redirect) == null ? void 0 : c.universal) !== "" && ((l = t == null ? void 0 : t.redirect) == null ? void 0 : l.universal) !== void 0 && ((d = t == null ? void 0 : t.redirect) == null ? void 0 : d.universal) !== "" && ((h = t == null ? void 0 : t.redirect) == null ? void 0 : h.linkMode) === true && this.client.core.linkModeSupportedApps.includes(t.redirect.universal) && typeof (global == null ? void 0 : global.Linking) < "u";
    }), oe(this, "getAppLinkIfEnabled", (t, n) => {
      var s;
      return this.isLinkModeEnabled(t, n) ? (s = t == null ? void 0 : t.redirect) == null ? void 0 : s.universal : void 0;
    }), oe(this, "handleLinkModeMessage", ({ url: t }) => {
      if (!t || !t.includes("wc_ev") || !t.includes("topic")) return;
      const n = Ph(t, "topic") || "", s = decodeURIComponent(Ph(t, "wc_ev") || ""), i = this.client.session.keys.includes(n);
      i && this.client.session.update(n, { transportType: Ye.link_mode }), this.client.core.dispatchEnvelope({ topic: n, message: s, sessionExists: i });
    }), oe(this, "registerLinkModeListeners", async () => {
      var t;
      if (Sl() || Sn() && (t = this.client.metadata.redirect) != null && t.linkMode) {
        const n = global == null ? void 0 : global.Linking;
        if (typeof n < "u") {
          n.addEventListener("url", this.handleLinkModeMessage, this.client.name);
          const s = await n.getInitialURL();
          s && setTimeout(() => {
            this.handleLinkModeMessage({ url: s });
          }, 50);
        }
      }
    }), oe(this, "getTVFParams", (t, n, s) => {
      var i, o, a;
      if (!((i = n.request) != null && i.method)) return {};
      const u = { correlationId: t, rpcMethods: [n.request.method], chainId: n.chainId };
      try {
        const c = this.extractTxHashesFromResult(n.request, s);
        u.txHashes = c, u.contractAddresses = this.isValidContractData(n.request.params) ? [(a = (o = n.request.params) == null ? void 0 : o[0]) == null ? void 0 : a.to] : [];
      } catch (c) {
        this.client.logger.warn(c, "Error getting TVF params");
      }
      return u;
    }), oe(this, "isValidContractData", (t) => {
      var n;
      if (!t) return false;
      try {
        const s = (t == null ? void 0 : t.data) || ((n = t == null ? void 0 : t[0]) == null ? void 0 : n.data);
        if (!s.startsWith("0x")) return false;
        const i = s.slice(2);
        return /^[0-9a-fA-F]*$/.test(i) ? i.length % 2 === 0 : false;
      } catch {
      }
      return false;
    }), oe(this, "extractTxHashesFromResult", (t, n) => {
      var s;
      try {
        if (!n) return [];
        const i = t.method, o = FL[i];
        if (i === "sui_signTransaction") return [C4(n.transactionBytes)];
        if (i === "near_signTransaction") return [Vh(n)];
        if (i === "near_signTransactions") return n.map((u) => Vh(u));
        if (i === "xrpl_signTransactionFor" || i === "xrpl_signTransaction") return [(s = n.tx_json) == null ? void 0 : s.hash];
        if (i === "polkadot_signTransaction") return [C3({ transaction: t.params.transactionPayload, signature: n.signature })];
        if (i === "algo_signTxn") return Ri(n) ? n.map((u) => Hh(u)) : [Hh(n)];
        if (i === "cosmos_signDirect") return [z4(n)];
        if (i === "wallet_sendCalls") return k4(n);
        if (typeof n == "string") return [n];
        const a = n[o.key];
        if (Ri(a)) return i === "solana_signAllTransactions" ? a.map((u) => j4(u)) : a;
        if (typeof a == "string") return [a];
      } catch (i) {
        this.client.logger.warn(i, "Error extracting tx hashes from result");
      }
      return [];
    });
  }
  async processPendingMessageEvents() {
    try {
      const e = this.client.session.keys, t = this.client.core.relayer.messages.getWithoutAck(e);
      for (const [n, s] of Object.entries(t)) for (const i of s) try {
        await this.onProviderMessageEvent({ topic: n, message: i, publishedAt: Date.now() });
      } catch {
        this.client.logger.warn(`Error processing pending message event for topic: ${n}, message: ${i}`);
      }
    } catch (e) {
      this.client.logger.warn(e, "processPendingMessageEvents failed");
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ae("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async confirmOnlineStateOrThrow() {
    await this.client.core.relayer.confirmOnlineStateOrThrow();
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(tt.message, (e) => {
      this.onProviderMessageEvent(e);
    });
  }
  async onRelayMessage(e) {
    const { topic: t, message: n, attestation: s, transportType: i } = e, { publicKey: o } = this.client.auth.authKeys.keys.includes(So) ? this.client.auth.authKeys.get(So) : { publicKey: void 0 };
    try {
      const a = await this.client.core.crypto.decode(t, n, { receiverPublicKey: o, encoding: i === Ye.link_mode ? Nn : qt });
      Yl(a) ? (this.client.core.history.set(t, a), await this.onRelayEventRequest({ topic: t, payload: a, attestation: s, transportType: i, encryptedId: ur(n) })) : Xa(a) ? (await this.client.core.history.resolve(a), await this.onRelayEventResponse({ topic: t, payload: a, transportType: i }), this.client.core.history.delete(t, a.id)) : await this.onRelayEventUnknownPayload({ topic: t, payload: a, transportType: i }), await this.client.core.relayer.messages.ack(t, n);
    } catch (a) {
      this.client.logger.error(a);
    }
  }
  registerExpirerEvents() {
    this.client.core.expirer.on(or.expired, async (e) => {
      const { topic: t, id: n } = iy(e.target);
      if (n && this.client.pendingRequest.keys.includes(n)) return await this.deletePendingSessionRequest(n, ae("EXPIRED"), true);
      if (n && this.client.auth.requests.keys.includes(n)) return await this.deletePendingAuthRequest(n, ae("EXPIRED"), true);
      t ? this.client.session.keys.includes(t) && (await this.deleteSession({ topic: t, expirerHasDeleted: true }), this.client.events.emit("session_expire", { topic: t })) : n && (await this.deleteProposal(n, true), this.client.events.emit("proposal_expire", { id: n }));
    });
  }
  registerPairingEvents() {
    this.client.core.pairing.events.on(Vn.create, (e) => this.onPairingCreated(e)), this.client.core.pairing.events.on(Vn.delete, (e) => {
      this.addToRecentlyDeleted(e.topic, "pairing");
    });
  }
  isValidPairingTopic(e) {
    if (!it(e, false)) {
      const { message: t } = ae("MISSING_OR_INVALID", `pairing topic should be a string: ${e}`);
      throw new Error(t);
    }
    if (!this.client.core.pairing.pairings.keys.includes(e)) {
      const { message: t } = ae("NO_MATCHING_KEY", `pairing topic doesn't exist: ${e}`);
      throw new Error(t);
    }
    if (wn(this.client.core.pairing.pairings.get(e).expiry)) {
      const { message: t } = ae("EXPIRED", `pairing topic: ${e}`);
      throw new Error(t);
    }
  }
  async isValidSessionTopic(e) {
    if (!it(e, false)) {
      const { message: t } = ae("MISSING_OR_INVALID", `session topic should be a string: ${e}`);
      throw new Error(t);
    }
    if (this.checkRecentlyDeleted(e), !this.client.session.keys.includes(e)) {
      const { message: t } = ae("NO_MATCHING_KEY", `session topic doesn't exist: ${e}`);
      throw new Error(t);
    }
    if (wn(this.client.session.get(e).expiry)) {
      await this.deleteSession({ topic: e });
      const { message: t } = ae("EXPIRED", `session topic: ${e}`);
      throw new Error(t);
    }
    if (!this.client.core.crypto.keychain.has(e)) {
      const { message: t } = ae("MISSING_OR_INVALID", `session topic does not exist in keychain: ${e}`);
      throw await this.deleteSession({ topic: e }), new Error(t);
    }
  }
  async isValidSessionOrPairingTopic(e) {
    if (this.checkRecentlyDeleted(e), this.client.session.keys.includes(e)) await this.isValidSessionTopic(e);
    else if (this.client.core.pairing.pairings.keys.includes(e)) this.isValidPairingTopic(e);
    else if (it(e, false)) {
      const { message: t } = ae("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${e}`);
      throw new Error(t);
    } else {
      const { message: t } = ae("MISSING_OR_INVALID", `session or pairing topic should be a string: ${e}`);
      throw new Error(t);
    }
  }
  async isValidProposalId(e) {
    if (!u3(e)) {
      const { message: t } = ae("MISSING_OR_INVALID", `proposal id should be a number: ${e}`);
      throw new Error(t);
    }
    if (!this.client.proposal.keys.includes(e)) {
      const { message: t } = ae("NO_MATCHING_KEY", `proposal id doesn't exist: ${e}`);
      throw new Error(t);
    }
    if (wn(this.client.proposal.get(e).expiryTimestamp)) {
      await this.deleteProposal(e);
      const { message: t } = ae("EXPIRED", `proposal id: ${e}`);
      throw new Error(t);
    }
  }
};
var rz = class extends fi {
  constructor(e, t) {
    super(e, t, BL, Hl), this.core = e, this.logger = t;
  }
};
var nz = class extends fi {
  constructor(e, t) {
    super(e, t, RL, Hl), this.core = e, this.logger = t;
  }
};
var iz = class extends fi {
  constructor(e, t) {
    super(e, t, QL, Hl, (n) => n.id), this.core = e, this.logger = t;
  }
};
var sz = class extends fi {
  constructor(e, t) {
    super(e, t, HL, Ja, () => So), this.core = e, this.logger = t;
  }
};
var oz = class extends fi {
  constructor(e, t) {
    super(e, t, GL, Ja), this.core = e, this.logger = t;
  }
};
var az = class extends fi {
  constructor(e, t) {
    super(e, t, WL, Ja, (n) => n.id), this.core = e, this.logger = t;
  }
};
var cz = Object.defineProperty;
var uz = (r, e, t) => e in r ? cz(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;
var ru = (r, e, t) => uz(r, typeof e != "symbol" ? e + "" : e, t);
var lz = class {
  constructor(e, t) {
    this.core = e, this.logger = t, ru(this, "authKeys"), ru(this, "pairingTopics"), ru(this, "requests"), this.authKeys = new sz(this.core, this.logger), this.pairingTopics = new oz(this.core, this.logger), this.requests = new az(this.core, this.logger);
  }
  async init() {
    await this.authKeys.init(), await this.pairingTopics.init(), await this.requests.init();
  }
};
var dz = Object.defineProperty;
var hz = (r, e, t) => e in r ? dz(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t;
var Ae = (r, e, t) => hz(r, typeof e != "symbol" ? e + "" : e, t);
var ta = class _ta extends XE {
  constructor(e) {
    super(e), Ae(this, "protocol", _w), Ae(this, "version", Dw), Ae(this, "name", eu.name), Ae(this, "metadata"), Ae(this, "core"), Ae(this, "logger"), Ae(this, "events", new Gt.EventEmitter()), Ae(this, "engine"), Ae(this, "session"), Ae(this, "proposal"), Ae(this, "pendingRequest"), Ae(this, "auth"), Ae(this, "signConfig"), Ae(this, "on", (n, s) => this.events.on(n, s)), Ae(this, "once", (n, s) => this.events.once(n, s)), Ae(this, "off", (n, s) => this.events.off(n, s)), Ae(this, "removeListener", (n, s) => this.events.removeListener(n, s)), Ae(this, "removeAllListeners", (n) => this.events.removeAllListeners(n)), Ae(this, "connect", async (n) => {
      try {
        return await this.engine.connect(n);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), Ae(this, "pair", async (n) => {
      try {
        return await this.engine.pair(n);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), Ae(this, "approve", async (n) => {
      try {
        return await this.engine.approve(n);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), Ae(this, "reject", async (n) => {
      try {
        return await this.engine.reject(n);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), Ae(this, "update", async (n) => {
      try {
        return await this.engine.update(n);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), Ae(this, "extend", async (n) => {
      try {
        return await this.engine.extend(n);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), Ae(this, "request", async (n) => {
      try {
        return await this.engine.request(n);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), Ae(this, "respond", async (n) => {
      try {
        return await this.engine.respond(n);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), Ae(this, "ping", async (n) => {
      try {
        return await this.engine.ping(n);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), Ae(this, "emit", async (n) => {
      try {
        return await this.engine.emit(n);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), Ae(this, "disconnect", async (n) => {
      try {
        return await this.engine.disconnect(n);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), Ae(this, "find", (n) => {
      try {
        return this.engine.find(n);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), Ae(this, "getPendingSessionRequests", () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (n) {
        throw this.logger.error(n.message), n;
      }
    }), Ae(this, "authenticate", async (n, s) => {
      try {
        return await this.engine.authenticate(n, s);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }), Ae(this, "formatAuthMessage", (n) => {
      try {
        return this.engine.formatAuthMessage(n);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), Ae(this, "approveSessionAuthenticate", async (n) => {
      try {
        return await this.engine.approveSessionAuthenticate(n);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), Ae(this, "rejectSessionAuthenticate", async (n) => {
      try {
        return await this.engine.rejectSessionAuthenticate(n);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }), this.name = (e == null ? void 0 : e.name) || eu.name, this.metadata = IA(e == null ? void 0 : e.metadata), this.signConfig = e == null ? void 0 : e.signConfig;
    const t = sw({ logger: (e == null ? void 0 : e.logger) || eu.logger, name: this.name });
    this.logger = t, this.core = (e == null ? void 0 : e.core) || new PL(e), this.session = new nz(this.core, this.logger), this.proposal = new rz(this.core, this.logger), this.pendingRequest = new iz(this.core, this.logger), this.engine = new tz(this), this.auth = new lz(this.core, this.logger);
  }
  static async init(e) {
    const t = new _ta(e);
    return await t.initialize(), t;
  }
  get context() {
    return Wt(this.logger);
  }
  get pairing() {
    return this.core.pairing.pairings;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.auth.init(), await this.engine.init(), this.logger.info("SignClient Initialization Success");
    } catch (e) {
      throw this.logger.info("SignClient Initialization Failure"), this.logger.error(e.message), e;
    }
  }
};
var fz = {
  USER_DISCONNECTED: {
    code: 6e3,
    message: "User disconnected"
  }
};
var yn = {
  NAME: "XRPL Connect",
  DESCRIPTION: "XRPL Wallet Connection",
  DEFAULT_URL: "https://xrpl.org",
  DEFAULT_ICON: "https://xrpl.org/favicon.ico"
};
var lp = {
  URI_PREVIEW_LENGTH: 50
  // Number of characters to show in URI preview logs
};
var pz = {
  ADDRESS_INDEX: 2
  // Index of address in "xrpl:chainId:rAddress" format
};
var Mo = {
  KEY: "xrpl",
  EVENTS: ["chainChanged", "accountsChanged"]
  // Cast to mutable array for WalletConnect types
};
var Ct = ra("[WalletConnect]");
var gz = class {
  constructor(e = {}) {
    this.id = "walletconnect", this.name = "WalletConnect", this.icon = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB4bWxuczp4b2RtPSJodHRwOi8vd3d3LmNvcmVsLmNvbS9jb3JlbGRyYXcvb2RtLzIwMDMiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMjQ5NyAyNDk3IiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCAyNDk3IDI0OTc7IiB4bWw6c3BhY2U9InByZXNlcnZlIj4KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4KCS5zdDB7ZmlsbDojMzM5NkZGO3N0cm9rZTojNjZCMUZGO3N0cm9rZS13aWR0aDozO3N0cm9rZS1taXRlcmxpbWl0OjIyLjkyNTY7fQoJLnN0MXtmaWxsOiNGRkZGRkY7fQo8L3N0eWxlPgo8ZyBpZD0iTGF5ZXJfeDAwMjBfMSI+Cgk8ZyBpZD0iXzI4MDYwNTAxMzY4OTYiPgoJCTxjaXJjbGUgY2xhc3M9InN0MCIgY3g9IjEyNDkiIGN5PSIxMjQ5IiByPSIxMjQ3Ij48L2NpcmNsZT4KCQk8cGF0aCBjbGFzcz0ic3QxIiBkPSJNNzY0LDkzMGMyNjctMjYxLDcwMS0yNjEsOTY5LDBsMzIsMzFjMTMsMTMsMTMsMzQsMCw0N2wtMTEwLDEwN2MtNyw3LTE4LDctMjQsMGwtNDQtNDMgICAgYy0xODctMTgyLTQ4OS0xODItNjc2LDBsLTQ3LDQ2Yy03LDctMTgsNy0yNCwwbC0xMTAtMTA3Yy0xMy0xMy0xMy0zNCwwLTQ3bDM1LTM0SDc2NHogTTE5NjAsMTE1Mmw5OCw5NmMxMywxMywxMywzNCwwLDQ3ICAgIGwtNDQyLDQzMWMtMTMsMTMtMzUsMTMtNDgsMGwtMzE0LTMwNmMtMy0zLTktMy0xMiwwbC0zMTQsMzA2Yy0xMywxMy0zNSwxMy00OCwwbC00NDItNDMxYy0xMy0xMy0xMy0zNCwwLTQ3bDk4LTk2ICAgIGMxMy0xMywzNS0xMyw0OCwwbDMxNCwzMDZjMywzLDksMywxMiwwbDMxNC0zMDZjMTMtMTMsMzUtMTMsNDgsMGwzMTQsMzA2YzMsMyw5LDMsMTIsMGwzMTQtMzA2QzE5MjUsMTEzOSwxOTQ3LDExMzksMTk2MCwxMTUyICAgIEwxOTYwLDExNTJ6Ij48L3BhdGg+Cgk8L2c+CjwvZz4KPC9zdmc+Cg==", this.url = "https://walletconnect.com", this.client = null, this.session = null, this.currentAccount = null, this.initializationPromise = null, this.pendingConnection = null, this.options = e;
  }
  /**
   * WalletConnect is always available (uses QR code)
   */
  async isAvailable() {
    return true;
  }
  /**
   * Pre-initialize WalletConnect by starting a connection session early
   * This generates the QR code URI before the user clicks WalletConnect
   * Based on ConnectKit's eager initialization pattern
   */
  async preInitialize(e, t) {
    const n = e || this.options.projectId;
    if (!n) {
      Ct.warn("Cannot pre-initialize without project ID");
      return;
    }
    if (this.pendingConnection) {
      Ct.debug("Already has pending connection, skipping pre-init");
      return;
    }
    Ct.debug("Pre-initializing connection session...");
    try {
      this.client || (this.initializationPromise || (this.initializationPromise = ta.init({
        projectId: n,
        metadata: this.options.metadata || {
          name: yn.NAME,
          description: yn.DESCRIPTION,
          url: typeof window < "u" ? window.location.origin : yn.DEFAULT_URL,
          icons: [yn.DEFAULT_ICON]
        }
      })), this.client = await this.initializationPromise, Ct.debug("SignClient initialized"));
      const s = this.resolveNetwork(t), i = {
        [Mo.KEY]: {
          chains: [s.walletConnectId || `xrpl:${s.id}`],
          methods: [
            "xrpl_signTransaction",
            "xrpl_signTransactionFor",
            "xrpl_signMessage"
          ],
          events: Mo.EVENTS
        }
      }, { uri: o, approval: a } = await this.client.connect({
        requiredNamespaces: i
      });
      if (!o)
        throw new Error("Failed to generate WalletConnect URI during pre-initialization");
      this.pendingConnection = { uri: o, approval: a }, Ct.debug("QR code URI pre-generated:", o.substring(0, lp.URI_PREVIEW_LENGTH) + "..."), this.options.onQRCode && (Ct.debug("Calling onQRCode callback during pre-init"), this.options.onQRCode(o));
    } catch (s) {
      Ct.error("Pre-initialization failed:", s), this.initializationPromise = null, this.pendingConnection = null;
    }
  }
  /**
   * Connect to WalletConnect
   */
  async connect(e) {
    var s;
    const t = (e == null ? void 0 : e.projectId) || this.options.projectId;
    if (!t)
      throw me.connectionFailed(
        this.name,
        new Error(
          "WalletConnect project ID is required. Get one from https://cloud.walletconnect.com or https://dashboard.reown.com"
        )
      );
    const n = (e == null ? void 0 : e.onQRCode) || this.options.onQRCode;
    try {
      const i = this.resolveNetwork(e == null ? void 0 : e.network);
      let o, a;
      if (this.pendingConnection)
        Ct.debug("Using pre-generated connection"), o = this.pendingConnection.uri, a = this.pendingConnection.approval, n && (Ct.debug("Calling onQRCode callback with pre-generated URI"), n(o));
      else {
        Ct.debug("No pre-generated connection, creating now"), this.client || (this.initializationPromise ? (Ct.debug("Using pre-initialized SignClient"), this.client = await this.initializationPromise) : (Ct.debug("Initializing SignClient"), this.client = await ta.init({
          projectId: t,
          metadata: this.options.metadata || {
            name: yn.NAME,
            description: yn.DESCRIPTION,
            url: typeof window < "u" ? window.location.origin : yn.DEFAULT_URL,
            icons: [yn.DEFAULT_ICON]
          }
        })));
        const d = {
          [Mo.KEY]: {
            chains: [i.walletConnectId || `xrpl:${i.id}`],
            methods: [
              "xrpl_signTransaction",
              "xrpl_signTransactionFor",
              "xrpl_signMessage"
            ],
            events: Mo.EVENTS
          }
        }, h = await this.client.connect({
          requiredNamespaces: d
        });
        if (!h.uri)
          throw new Error("Failed to generate WalletConnect URI");
        o = h.uri, a = h.approval, Ct.debug("Generated URI:", o.substring(0, lp.URI_PREVIEW_LENGTH) + "..."), Ct.debug("onQRCode callback exists:", !!n), n && (Ct.debug("Calling onQRCode callback"), n(o));
      }
      this.session = await a();
      const u = ((s = this.session.namespaces.xrpl) == null ? void 0 : s.accounts) || [];
      if (u.length === 0)
        throw new Error("No accounts returned from WalletConnect session");
      const l = u[0].split(":")[pz.ADDRESS_INDEX];
      return this.currentAccount = {
        address: l,
        network: i
      }, this.setupEventListeners(), this.currentAccount;
    } catch (i) {
      throw me.connectionFailed(this.name, i);
    }
  }
  /**
   * Disconnect from WalletConnect
   */
  async disconnect() {
    if (!(!this.client || !this.session))
      try {
        await this.client.disconnect({
          topic: this.session.topic,
          reason: fz.USER_DISCONNECTED
        }), this.cleanup();
      } catch {
        this.cleanup();
      }
  }
  /**
   * Get current account
   */
  async getAccount() {
    return this.currentAccount;
  }
  /**
   * Get current network
   */
  async getNetwork() {
    if (!this.currentAccount)
      throw me.notConnected();
    return this.currentAccount.network;
  }
  /**
   * Sign and optionally submit a transaction using xrpl_signTransaction method
   * @param transaction - The transaction to sign
   * @param submit - Whether to submit to the ledger (default: true)
   */
  async signAndSubmit(e, t = true) {
    if (!this.client || !this.session || !this.currentAccount)
      throw me.notConnected();
    try {
      const n = {
        ...e,
        Account: e.Account || this.currentAccount.address
      }, i = (await this.client.request({
        topic: this.session.topic,
        chainId: this.currentAccount.network.walletConnectId || `xrpl:${this.currentAccount.network.id}`,
        request: {
          method: "xrpl_signTransaction",
          params: {
            tx_json: n,
            autofill: true,
            submit: t
            // Controls whether to submit to ledger
          }
        }
      })).tx_json;
      return {
        hash: i.hash || "",
        tx_blob: i.TxnSignature
      };
    } catch (n) {
      throw n instanceof Error && n.message.toLowerCase().includes("reject") ? me.signRejected() : me.signFailed(n);
    }
  }
  /**
   * Sign a message - NOT SUPPORTED
   * WalletConnect does not currently support message signing for XRPL
   */
  async signMessage(e) {
    throw me.unsupportedMethod(
      "Message signing is not supported via WalletConnect. Please use Xaman, Crossmark, or GemWallet for signing messages."
    );
  }
  /**
   * Resolve network configuration
   */
  resolveNetwork(e) {
    if (!e)
      return Ci.mainnet;
    if (typeof e == "string") {
      const t = Ci[e];
      if (!t)
        throw me.unknown(`Unknown network: ${e}`);
      return t;
    }
    return e;
  }
  /**
   * Setup event listeners for session
   */
  setupEventListeners() {
    this.client && (this.client.on("session_delete", () => {
      this.cleanup();
    }), this.client.on("session_expire", () => {
      this.cleanup();
    }));
  }
  /**
   * Cleanup adapter state
   */
  cleanup() {
    this.client = null, this.session = null, this.currentAccount = null, this.initializationPromise = null, this.pendingConnection = null;
  }
  /**
   * Get deep link URI for mobile
   */
  getDeepLinkURI(e) {
    return this.options.onDeepLink ? this.options.onDeepLink(e) : e;
  }
};
var ak = {
  Xaman: im,
  Crossmark: om,
  GemWallet: jv,
  WalletConnect: gz
};
export {
  ak as Adapters,
  gp as BROWSER_PATTERNS,
  Hn as COLOR_ADJUSTMENT,
  om as CrossmarkAdapter,
  vz as DEFAULT_THEME,
  Xl as ERROR_CODES,
  rr as FONT_WEIGHTS,
  jv as GemWalletAdapter,
  Fr as LUMINANCE,
  zw as LocalStorageAdapter,
  fp as Logger,
  kw as MemoryStorageAdapter,
  lt as QR_CONFIG,
  Re as SIZES,
  Ci as STANDARD_NETWORKS,
  Uw as Storage,
  Pw as TIME,
  Cn as TIMINGS,
  gz as WalletConnectAdapter,
  Jl as WalletConnectorElement,
  St as WalletError,
  Bt as WalletErrorCode,
  bz as WalletManager,
  Mz as XAMAN,
  im as XamanAdapter,
  Gs as Z_INDEX,
  Zl as adjustColorBrightness,
  Rw as calculateLuminance,
  ra as createLogger,
  me as createWalletError,
  qw as delay,
  Ez as getContrastTextColor,
  mz as getErrorMessage,
  Fw as isMobile,
  $w as isSafari,
  wz as isWalletError,
  Qw as isXamanQRImage,
  Nz as truncateString
};
/*! Bundled license information:

xrpl-connect/xrpl-connect.mjs:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
  (*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
  (*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=xrpl-connect.js.map
